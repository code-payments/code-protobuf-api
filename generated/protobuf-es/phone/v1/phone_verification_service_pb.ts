// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file phone/v1/phone_verification_service.proto (package code.phone.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DeviceToken, PhoneNumber, Signature, SolanaAccountId } from "../../common/v1/model_pb";

/**
 * @generated from message code.phone.v1.SendVerificationCodeRequest
 */
export class SendVerificationCodeRequest extends Message<SendVerificationCodeRequest> {
  /**
   * The phone number to send a verification code over SMS to.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * Device token for antispam measures against fake devices
   *
   * @generated from field: code.common.v1.DeviceToken device_token = 2;
   */
  deviceToken?: DeviceToken;

  constructor(data?: PartialMessage<SendVerificationCodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.SendVerificationCodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "device_token", kind: "message", T: DeviceToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendVerificationCodeRequest | PlainMessage<SendVerificationCodeRequest> | undefined, b: SendVerificationCodeRequest | PlainMessage<SendVerificationCodeRequest> | undefined): boolean {
    return proto3.util.equals(SendVerificationCodeRequest, a, b);
  }
}

/**
 * @generated from message code.phone.v1.SendVerificationCodeResponse
 */
export class SendVerificationCodeResponse extends Message<SendVerificationCodeResponse> {
  /**
   * @generated from field: code.phone.v1.SendVerificationCodeResponse.Result result = 1;
   */
  result = SendVerificationCodeResponse_Result.OK;

  constructor(data?: PartialMessage<SendVerificationCodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.SendVerificationCodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SendVerificationCodeResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendVerificationCodeResponse | PlainMessage<SendVerificationCodeResponse> | undefined, b: SendVerificationCodeResponse | PlainMessage<SendVerificationCodeResponse> | undefined): boolean {
    return proto3.util.equals(SendVerificationCodeResponse, a, b);
  }
}

/**
 * @generated from enum code.phone.v1.SendVerificationCodeResponse.Result
 */
export enum SendVerificationCodeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The phone number is not invited and cannot use Code. The SMS will not
   * be sent until the user is invited. This result is only valid during
   * the invitation stage of the application and won't apply after general
   * public release.
   *
   * @generated from enum value: NOT_INVITED = 1;
   */
  NOT_INVITED = 1,

  /**
   * SMS is rate limited (eg. by IP, phone number, etc) and was not sent.
   * These will be set generously such that real users won't actually hit
   * the limits.
   *
   * @generated from enum value: RATE_LIMITED = 2;
   */
  RATE_LIMITED = 2,

  /**
   * The phone number is not real because it fails Twilio lookup.
   *
   * @generated from enum value: INVALID_PHONE_NUMBER = 3;
   */
  INVALID_PHONE_NUMBER = 3,

  /**
   * The phone number is valid, but it maps to an unsupported type of phone
   * like a landline.
   *
   * @generated from enum value: UNSUPPORTED_PHONE_TYPE = 4;
   */
  UNSUPPORTED_PHONE_TYPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SendVerificationCodeResponse_Result)
proto3.util.setEnumType(SendVerificationCodeResponse_Result, "code.phone.v1.SendVerificationCodeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_INVITED" },
  { no: 2, name: "RATE_LIMITED" },
  { no: 3, name: "INVALID_PHONE_NUMBER" },
  { no: 4, name: "UNSUPPORTED_PHONE_TYPE" },
]);

/**
 * @generated from message code.phone.v1.CheckVerificationCodeRequest
 */
export class CheckVerificationCodeRequest extends Message<CheckVerificationCodeRequest> {
  /**
   * The phone number being verified.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * The verification code received via SMS.
   *
   * @generated from field: code.phone.v1.VerificationCode code = 2;
   */
  code?: VerificationCode;

  constructor(data?: PartialMessage<CheckVerificationCodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.CheckVerificationCodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "code", kind: "message", T: VerificationCode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckVerificationCodeRequest | PlainMessage<CheckVerificationCodeRequest> | undefined, b: CheckVerificationCodeRequest | PlainMessage<CheckVerificationCodeRequest> | undefined): boolean {
    return proto3.util.equals(CheckVerificationCodeRequest, a, b);
  }
}

/**
 * @generated from message code.phone.v1.CheckVerificationCodeResponse
 */
export class CheckVerificationCodeResponse extends Message<CheckVerificationCodeResponse> {
  /**
   * @generated from field: code.phone.v1.CheckVerificationCodeResponse.Result result = 1;
   */
  result = CheckVerificationCodeResponse_Result.OK;

  /**
   * The token used to associate an owner account to a user using the verified
   * phone number.
   *
   * @generated from field: code.phone.v1.PhoneLinkingToken linking_token = 2;
   */
  linkingToken?: PhoneLinkingToken;

  constructor(data?: PartialMessage<CheckVerificationCodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.CheckVerificationCodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(CheckVerificationCodeResponse_Result) },
    { no: 2, name: "linking_token", kind: "message", T: PhoneLinkingToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckVerificationCodeResponse | PlainMessage<CheckVerificationCodeResponse> | undefined, b: CheckVerificationCodeResponse | PlainMessage<CheckVerificationCodeResponse> | undefined): boolean {
    return proto3.util.equals(CheckVerificationCodeResponse, a, b);
  }
}

/**
 * @generated from enum code.phone.v1.CheckVerificationCodeResponse.Result
 */
export enum CheckVerificationCodeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The provided verification code is invalid. The user may retry
   * enterring the code if this is received. When max attempts are
   * received, NO_VERIFICATION will be returned.
   *
   * @generated from enum value: INVALID_CODE = 1;
   */
  INVALID_CODE = 1,

  /**
   * There is no verification in progress for the phone number. Several
   * reasons this can occur include a verification being expired or having
   * reached a maximum check threshold. The client must initiate a new
   * verification using SendVerificationCode.
   *
   * @generated from enum value: NO_VERIFICATION = 2;
   */
  NO_VERIFICATION = 2,

  /**
   * The call is rate limited (eg. by IP, phone number, etc). The code is
   * not verified.
   *
   * @generated from enum value: RATE_LIMITED = 3;
   */
  RATE_LIMITED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckVerificationCodeResponse_Result)
proto3.util.setEnumType(CheckVerificationCodeResponse_Result, "code.phone.v1.CheckVerificationCodeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INVALID_CODE" },
  { no: 2, name: "NO_VERIFICATION" },
  { no: 3, name: "RATE_LIMITED" },
]);

/**
 * @generated from message code.phone.v1.GetAssociatedPhoneNumberRequest
 */
export class GetAssociatedPhoneNumberRequest extends Message<GetAssociatedPhoneNumberRequest> {
  /**
   * The public key of the owner account that is being queried for a linked
   * phone number.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner_account_id = 1;
   */
  ownerAccountId?: SolanaAccountId;

  /**
   * The signature is of serialize(GetAssociatedPhoneNumberRequest) without
   * this field set using the private key of owner_account_id. This provides
   * an authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetAssociatedPhoneNumberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.GetAssociatedPhoneNumberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAssociatedPhoneNumberRequest {
    return new GetAssociatedPhoneNumberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAssociatedPhoneNumberRequest {
    return new GetAssociatedPhoneNumberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAssociatedPhoneNumberRequest {
    return new GetAssociatedPhoneNumberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAssociatedPhoneNumberRequest | PlainMessage<GetAssociatedPhoneNumberRequest> | undefined, b: GetAssociatedPhoneNumberRequest | PlainMessage<GetAssociatedPhoneNumberRequest> | undefined): boolean {
    return proto3.util.equals(GetAssociatedPhoneNumberRequest, a, b);
  }
}

/**
 * @generated from message code.phone.v1.GetAssociatedPhoneNumberResponse
 */
export class GetAssociatedPhoneNumberResponse extends Message<GetAssociatedPhoneNumberResponse> {
  /**
   * @generated from field: code.phone.v1.GetAssociatedPhoneNumberResponse.Result result = 1;
   */
  result = GetAssociatedPhoneNumberResponse_Result.OK;

  /**
   * The latest phone number associated with the owner account.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 2;
   */
  phoneNumber?: PhoneNumber;

  /**
   * State that determines whether a phone number is linked to the owner
   * account. A phone number is linked if we can treat it as an alias.
   * This is notably different from association, which answers the question
   * of whether the number was linked at any point in time.
   *
   * @generated from field: bool is_linked = 3;
   */
  isLinked = false;

  constructor(data?: PartialMessage<GetAssociatedPhoneNumberResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.GetAssociatedPhoneNumberResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetAssociatedPhoneNumberResponse_Result) },
    { no: 2, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 3, name: "is_linked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAssociatedPhoneNumberResponse {
    return new GetAssociatedPhoneNumberResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAssociatedPhoneNumberResponse {
    return new GetAssociatedPhoneNumberResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAssociatedPhoneNumberResponse {
    return new GetAssociatedPhoneNumberResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAssociatedPhoneNumberResponse | PlainMessage<GetAssociatedPhoneNumberResponse> | undefined, b: GetAssociatedPhoneNumberResponse | PlainMessage<GetAssociatedPhoneNumberResponse> | undefined): boolean {
    return proto3.util.equals(GetAssociatedPhoneNumberResponse, a, b);
  }
}

/**
 * @generated from enum code.phone.v1.GetAssociatedPhoneNumberResponse.Result
 */
export enum GetAssociatedPhoneNumberResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * A phone number is not associated with the provided owner account.
   *
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * The phone number exists, but is no longer invited
   *
   * @generated from enum value: NOT_INVITED = 2;
   */
  NOT_INVITED = 2,

  /**
   * The phone number exists, but at least one timelock account is unlocked
   *
   * @generated from enum value: UNLOCKED_TIMELOCK_ACCOUNT = 3;
   */
  UNLOCKED_TIMELOCK_ACCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetAssociatedPhoneNumberResponse_Result)
proto3.util.setEnumType(GetAssociatedPhoneNumberResponse_Result, "code.phone.v1.GetAssociatedPhoneNumberResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
  { no: 2, name: "NOT_INVITED" },
  { no: 3, name: "UNLOCKED_TIMELOCK_ACCOUNT" },
]);

/**
 * @generated from message code.phone.v1.VerificationCode
 */
export class VerificationCode extends Message<VerificationCode> {
  /**
   * A 4-10 digit numerical code.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<VerificationCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.VerificationCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationCode {
    return new VerificationCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationCode {
    return new VerificationCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationCode {
    return new VerificationCode().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationCode | PlainMessage<VerificationCode> | undefined, b: VerificationCode | PlainMessage<VerificationCode> | undefined): boolean {
    return proto3.util.equals(VerificationCode, a, b);
  }
}

/**
 * A one-time use token that can be provided to the Identity service to link an
 * owner account to a user with the verified phone number. The client should
 * treat this token as opaque.
 *
 * @generated from message code.phone.v1.PhoneLinkingToken
 */
export class PhoneLinkingToken extends Message<PhoneLinkingToken> {
  /**
   * The verified phone number.
   *
   * @generated from field: code.common.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * The code that verified the phone number.
   *
   * @generated from field: code.phone.v1.VerificationCode code = 2;
   */
  code?: VerificationCode;

  constructor(data?: PartialMessage<PhoneLinkingToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.phone.v1.PhoneLinkingToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "code", kind: "message", T: VerificationCode },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhoneLinkingToken {
    return new PhoneLinkingToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhoneLinkingToken {
    return new PhoneLinkingToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhoneLinkingToken {
    return new PhoneLinkingToken().fromJsonString(jsonString, options);
  }

  static equals(a: PhoneLinkingToken | PlainMessage<PhoneLinkingToken> | undefined, b: PhoneLinkingToken | PlainMessage<PhoneLinkingToken> | undefined): boolean {
    return proto3.util.equals(PhoneLinkingToken, a, b);
  }
}

