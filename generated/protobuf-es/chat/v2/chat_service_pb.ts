// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file chat/v2/chat_service.proto (package code.chat.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { ChatId, ClientPong, IntentId, ServerPing, Signature, SolanaAccountId } from "../../common/v1/model_pb";
import { ExchangeData, ExchangeDataWithoutRate } from "../../transaction/v2/transaction_service_pb";

/**
 * @generated from enum code.chat.v2.ChatType
 */
export enum ChatType {
  /**
   * @generated from enum value: UNKNOWN_CHAT_TYPE = 0;
   */
  UNKNOWN_CHAT_TYPE = 0,

  /**
   * @generated from enum value: NOTIFICATION = 1;
   */
  NOTIFICATION = 1,

  /**
   * GROUP             = 3;
   *
   * @generated from enum value: TWO_WAY = 2;
   */
  TWO_WAY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ChatType)
proto3.util.setEnumType(ChatType, "code.chat.v2.ChatType", [
  { no: 0, name: "UNKNOWN_CHAT_TYPE" },
  { no: 1, name: "NOTIFICATION" },
  { no: 2, name: "TWO_WAY" },
]);

/**
 * @generated from enum code.chat.v2.Platform
 */
export enum Platform {
  /**
   * @generated from enum value: UNKNOWN_PLATFORM = 0;
   */
  UNKNOWN_PLATFORM = 0,

  /**
   * @generated from enum value: TWITTER = 1;
   */
  TWITTER = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Platform)
proto3.util.setEnumType(Platform, "code.chat.v2.Platform", [
  { no: 0, name: "UNKNOWN_PLATFORM" },
  { no: 1, name: "TWITTER" },
]);

/**
 * @generated from enum code.chat.v2.PointerType
 */
export enum PointerType {
  /**
   * @generated from enum value: UNKNOWN_POINTER_TYPE = 0;
   */
  UNKNOWN_POINTER_TYPE = 0,

  /**
   * Always inferred by OK result in SendMessageResponse or message presence in a chat
   *
   * @generated from enum value: SENT = 1;
   */
  SENT = 1,

  /**
   * @generated from enum value: DELIVERED = 2;
   */
  DELIVERED = 2,

  /**
   * @generated from enum value: READ = 3;
   */
  READ = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PointerType)
proto3.util.setEnumType(PointerType, "code.chat.v2.PointerType", [
  { no: 0, name: "UNKNOWN_POINTER_TYPE" },
  { no: 1, name: "SENT" },
  { no: 2, name: "DELIVERED" },
  { no: 3, name: "READ" },
]);

/**
 * @generated from message code.chat.v2.GetChatsRequest
 */
export class GetChatsRequest extends Message<GetChatsRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 3;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v2.Cursor cursor = 4;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v2.GetChatsRequest.Direction direction = 5;
   */
  direction = GetChatsRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetChatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetChatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "cursor", kind: "message", T: Cursor },
    { no: 5, name: "direction", kind: "enum", T: proto3.getEnumType(GetChatsRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined, b: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined): boolean {
    return proto3.util.equals(GetChatsRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetChatsRequest.Direction
 */
export enum GetChatsRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsRequest_Direction)
proto3.util.setEnumType(GetChatsRequest_Direction, "code.chat.v2.GetChatsRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v2.GetChatsResponse
 */
export class GetChatsResponse extends Message<GetChatsResponse> {
  /**
   * @generated from field: code.chat.v2.GetChatsResponse.Result result = 1;
   */
  result = GetChatsResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v2.ChatMetadata chats = 2;
   */
  chats: ChatMetadata[] = [];

  constructor(data?: PartialMessage<GetChatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetChatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetChatsResponse_Result) },
    { no: 2, name: "chats", kind: "message", T: ChatMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined, b: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined): boolean {
    return proto3.util.equals(GetChatsResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetChatsResponse.Result
 */
export enum GetChatsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsResponse_Result)
proto3.util.setEnumType(GetChatsResponse_Result, "code.chat.v2.GetChatsResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.GetMessagesRequest
 */
export class GetMessagesRequest extends Message<GetMessagesRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 5;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v2.Cursor cursor = 6;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v2.GetMessagesRequest.Direction direction = 7;
   */
  direction = GetMessagesRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetMessagesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetMessagesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
    { no: 5, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "cursor", kind: "message", T: Cursor },
    { no: 7, name: "direction", kind: "enum", T: proto3.getEnumType(GetMessagesRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined, b: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined): boolean {
    return proto3.util.equals(GetMessagesRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetMessagesRequest.Direction
 */
export enum GetMessagesRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesRequest_Direction)
proto3.util.setEnumType(GetMessagesRequest_Direction, "code.chat.v2.GetMessagesRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v2.GetMessagesResponse
 */
export class GetMessagesResponse extends Message<GetMessagesResponse> {
  /**
   * @generated from field: code.chat.v2.GetMessagesResponse.Result result = 1;
   */
  result = GetMessagesResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v2.ChatMessage messages = 2;
   */
  messages: ChatMessage[] = [];

  constructor(data?: PartialMessage<GetMessagesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetMessagesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetMessagesResponse_Result) },
    { no: 2, name: "messages", kind: "message", T: ChatMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined, b: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined): boolean {
    return proto3.util.equals(GetMessagesResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetMessagesResponse.Result
 */
export enum GetMessagesResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: MESSAGE_NOT_FOUND = 3;
   */
  MESSAGE_NOT_FOUND = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesResponse_Result)
proto3.util.setEnumType(GetMessagesResponse_Result, "code.chat.v2.GetMessagesResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "MESSAGE_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.OpenChatEventStream
 */
export class OpenChatEventStream extends Message<OpenChatEventStream> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<OpenChatEventStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.OpenChatEventStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromJsonString(jsonString, options);
  }

  static equals(a: OpenChatEventStream | PlainMessage<OpenChatEventStream> | undefined, b: OpenChatEventStream | PlainMessage<OpenChatEventStream> | undefined): boolean {
    return proto3.util.equals(OpenChatEventStream, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEvent
 */
export class ChatStreamEvent extends Message<ChatStreamEvent> {
  /**
   * @generated from oneof code.chat.v2.ChatStreamEvent.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.ChatMessage message = 1;
     */
    value: ChatMessage;
    case: "message";
  } | {
    /**
     * @generated from field: code.chat.v2.Pointer pointer = 2;
     */
    value: Pointer;
    case: "pointer";
  } | {
    /**
     * @generated from field: code.chat.v2.IsTyping is_typing = 3;
     */
    value: IsTyping;
    case: "isTyping";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ChatStreamEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "message", T: ChatMessage, oneof: "type" },
    { no: 2, name: "pointer", kind: "message", T: Pointer, oneof: "type" },
    { no: 3, name: "is_typing", kind: "message", T: IsTyping, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEvent | PlainMessage<ChatStreamEvent> | undefined, b: ChatStreamEvent | PlainMessage<ChatStreamEvent> | undefined): boolean {
    return proto3.util.equals(ChatStreamEvent, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEventBatch
 */
export class ChatStreamEventBatch extends Message<ChatStreamEventBatch> {
  /**
   * @generated from field: repeated code.chat.v2.ChatStreamEvent events = 2;
   */
  events: ChatStreamEvent[] = [];

  constructor(data?: PartialMessage<ChatStreamEventBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEventBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "events", kind: "message", T: ChatStreamEvent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEventBatch | PlainMessage<ChatStreamEventBatch> | undefined, b: ChatStreamEventBatch | PlainMessage<ChatStreamEventBatch> | undefined): boolean {
    return proto3.util.equals(ChatStreamEventBatch, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEventError
 */
export class ChatStreamEventError extends Message<ChatStreamEventError> {
  /**
   * @generated from field: code.chat.v2.ChatStreamEventError.Code code = 1;
   */
  code = ChatStreamEventError_Code.DENIED;

  constructor(data?: PartialMessage<ChatStreamEventError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEventError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ChatStreamEventError_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEventError | PlainMessage<ChatStreamEventError> | undefined, b: ChatStreamEventError | PlainMessage<ChatStreamEventError> | undefined): boolean {
    return proto3.util.equals(ChatStreamEventError, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.ChatStreamEventError.Code
 */
export enum ChatStreamEventError_Code {
  /**
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 1;
   */
  CHAT_NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ChatStreamEventError_Code)
proto3.util.setEnumType(ChatStreamEventError_Code, "code.chat.v2.ChatStreamEventError.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "CHAT_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.StreamChatEventsRequest
 */
export class StreamChatEventsRequest extends Message<StreamChatEventsRequest> {
  /**
   * @generated from oneof code.chat.v2.StreamChatEventsRequest.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.OpenChatEventStream open_stream = 1;
     */
    value: OpenChatEventStream;
    case: "openStream";
  } | {
    /**
     * @generated from field: code.common.v1.ClientPong pong = 2;
     */
    value: ClientPong;
    case: "pong";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StreamChatEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_stream", kind: "message", T: OpenChatEventStream, oneof: "type" },
    { no: 2, name: "pong", kind: "message", T: ClientPong, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined, b: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StreamChatEventsResponse
 */
export class StreamChatEventsResponse extends Message<StreamChatEventsResponse> {
  /**
   * @generated from oneof code.chat.v2.StreamChatEventsResponse.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.ChatStreamEventBatch events = 1;
     */
    value: ChatStreamEventBatch;
    case: "events";
  } | {
    /**
     * @generated from field: code.common.v1.ServerPing ping = 2;
     */
    value: ServerPing;
    case: "ping";
  } | {
    /**
     * @generated from field: code.chat.v2.ChatStreamEventError error = 3;
     */
    value: ChatStreamEventError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StreamChatEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: ChatStreamEventBatch, oneof: "type" },
    { no: 2, name: "ping", kind: "message", T: ServerPing, oneof: "type" },
    { no: 3, name: "error", kind: "message", T: ChatStreamEventError, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined, b: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StartChatRequest
 */
export class StartChatRequest extends Message<StartChatRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from oneof code.chat.v2.StartChatRequest.parameters
   */
  parameters: {
    /**
     * GroupChatParameters group_chat  = 4;
     *
     * @generated from field: code.chat.v2.StartTipChatParameters tip_chat = 3;
     */
    value: StartTipChatParameters;
    case: "tipChat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "tip_chat", kind: "message", T: StartTipChatParameters, oneof: "parameters" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatRequest {
    return new StartChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatRequest | PlainMessage<StartChatRequest> | undefined, b: StartChatRequest | PlainMessage<StartChatRequest> | undefined): boolean {
    return proto3.util.equals(StartChatRequest, a, b);
  }
}

/**
 * Starts a two-way chat between a tipper and tippee. Chat members are
 * inferred from the 12 word public keys involved in the intent. Only
 * the tippee can start the chat, and the tipper is anonymous if this
 * is the first between the involved Code users.
 *
 * @generated from message code.chat.v2.StartTipChatParameters
 */
export class StartTipChatParameters extends Message<StartTipChatParameters> {
  /**
   * The tip's intent ID, which can be extracted from the reference in
   * an ExchangeDataContent message content where the verb is RECEIVED_TIP.
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  constructor(data?: PartialMessage<StartTipChatParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartTipChatParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartTipChatParameters {
    return new StartTipChatParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartTipChatParameters {
    return new StartTipChatParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartTipChatParameters {
    return new StartTipChatParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StartTipChatParameters | PlainMessage<StartTipChatParameters> | undefined, b: StartTipChatParameters | PlainMessage<StartTipChatParameters> | undefined): boolean {
    return proto3.util.equals(StartTipChatParameters, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StartChatResponse
 */
export class StartChatResponse extends Message<StartChatResponse> {
  /**
   * @generated from field: code.chat.v2.StartChatResponse.Result result = 1;
   */
  result = StartChatResponse_Result.OK;

  /**
   * The chat to use if the RPC was successful
   *
   * @generated from field: code.chat.v2.ChatMetadata chat = 2;
   */
  chat?: ChatMetadata;

  constructor(data?: PartialMessage<StartChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(StartChatResponse_Result) },
    { no: 2, name: "chat", kind: "message", T: ChatMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatResponse {
    return new StartChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatResponse | PlainMessage<StartChatResponse> | undefined, b: StartChatResponse | PlainMessage<StartChatResponse> | undefined): boolean {
    return proto3.util.equals(StartChatResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.StartChatResponse.Result
 */
export enum StartChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: INVALID_PARAMETER = 2;
   */
  INVALID_PARAMETER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StartChatResponse_Result)
proto3.util.setEnumType(StartChatResponse_Result, "code.chat.v2.StartChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "INVALID_PARAMETER" },
]);

/**
 * @generated from message code.chat.v2.SendMessageRequest
 */
export class SendMessageRequest extends Message<SendMessageRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * Allowed content types that can be sent by client:
   *  - TextContent
   *  - ThankYouContent
   *
   * @generated from field: repeated code.chat.v2.Content content = 3;
   */
  content: Content[] = [];

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 4;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SendMessageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SendMessageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "content", kind: "message", T: Content, repeated: true },
    { no: 4, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendMessageRequest | PlainMessage<SendMessageRequest> | undefined, b: SendMessageRequest | PlainMessage<SendMessageRequest> | undefined): boolean {
    return proto3.util.equals(SendMessageRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.SendMessageResponse
 */
export class SendMessageResponse extends Message<SendMessageResponse> {
  /**
   * @generated from field: code.chat.v2.SendMessageResponse.Result result = 1;
   */
  result = SendMessageResponse_Result.OK;

  /**
   * The chat message that was sent if the RPC was succesful, which includes
   * server-side metadata like the generated message ID and official timestamp
   *
   * @generated from field: code.chat.v2.ChatMessage message = 2;
   */
  message?: ChatMessage;

  constructor(data?: PartialMessage<SendMessageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SendMessageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SendMessageResponse_Result) },
    { no: 2, name: "message", kind: "message", T: ChatMessage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined, b: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined): boolean {
    return proto3.util.equals(SendMessageResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.SendMessageResponse.Result
 */
export enum SendMessageResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: INVALID_CHAT_TYPE = 3;
   */
  INVALID_CHAT_TYPE = 3,

  /**
   * @generated from enum value: INVALID_CONTENT_TYPE = 4;
   */
  INVALID_CONTENT_TYPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SendMessageResponse_Result)
proto3.util.setEnumType(SendMessageResponse_Result, "code.chat.v2.SendMessageResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "INVALID_CHAT_TYPE" },
  { no: 4, name: "INVALID_CONTENT_TYPE" },
]);

/**
 * @generated from message code.chat.v2.AdvancePointerRequest
 */
export class AdvancePointerRequest extends Message<AdvancePointerRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.Pointer pointer = 2;
   */
  pointer?: Pointer;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AdvancePointerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.AdvancePointerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "pointer", kind: "message", T: Pointer },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined, b: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined): boolean {
    return proto3.util.equals(AdvancePointerRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.AdvancePointerResponse
 */
export class AdvancePointerResponse extends Message<AdvancePointerResponse> {
  /**
   * @generated from field: code.chat.v2.AdvancePointerResponse.Result result = 1;
   */
  result = AdvancePointerResponse_Result.OK;

  constructor(data?: PartialMessage<AdvancePointerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.AdvancePointerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AdvancePointerResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined, b: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined): boolean {
    return proto3.util.equals(AdvancePointerResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.AdvancePointerResponse.Result
 */
export enum AdvancePointerResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: MESSAGE_NOT_FOUND = 3;
   */
  MESSAGE_NOT_FOUND = 3,

  /**
   * @generated from enum value: INVALID_POINTER_TYPE = 4;
   */
  INVALID_POINTER_TYPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AdvancePointerResponse_Result)
proto3.util.setEnumType(AdvancePointerResponse_Result, "code.chat.v2.AdvancePointerResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "MESSAGE_NOT_FOUND" },
  { no: 4, name: "INVALID_POINTER_TYPE" },
]);

/**
 * @generated from message code.chat.v2.RevealIdentityRequest
 */
export class RevealIdentityRequest extends Message<RevealIdentityRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: code.chat.v2.ChatMemberIdentity identity = 3;
   */
  identity?: ChatMemberIdentity;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 4;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<RevealIdentityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.RevealIdentityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "identity", kind: "message", T: ChatMemberIdentity },
    { no: 4, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevealIdentityRequest {
    return new RevealIdentityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevealIdentityRequest {
    return new RevealIdentityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevealIdentityRequest {
    return new RevealIdentityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RevealIdentityRequest | PlainMessage<RevealIdentityRequest> | undefined, b: RevealIdentityRequest | PlainMessage<RevealIdentityRequest> | undefined): boolean {
    return proto3.util.equals(RevealIdentityRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.RevealIdentityResponse
 */
export class RevealIdentityResponse extends Message<RevealIdentityResponse> {
  /**
   * @generated from field: code.chat.v2.RevealIdentityResponse.Result result = 1;
   */
  result = RevealIdentityResponse_Result.OK;

  /**
   * The chat message that was sent if the RPC was successful
   *
   * @generated from field: code.chat.v2.ChatMessage message = 2;
   */
  message?: ChatMessage;

  constructor(data?: PartialMessage<RevealIdentityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.RevealIdentityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(RevealIdentityResponse_Result) },
    { no: 2, name: "message", kind: "message", T: ChatMessage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RevealIdentityResponse {
    return new RevealIdentityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RevealIdentityResponse {
    return new RevealIdentityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RevealIdentityResponse {
    return new RevealIdentityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RevealIdentityResponse | PlainMessage<RevealIdentityResponse> | undefined, b: RevealIdentityResponse | PlainMessage<RevealIdentityResponse> | undefined): boolean {
    return proto3.util.equals(RevealIdentityResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.RevealIdentityResponse.Result
 */
export enum RevealIdentityResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: DIFFERENT_IDENTITY_REVEALED = 3;
   */
  DIFFERENT_IDENTITY_REVEALED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RevealIdentityResponse_Result)
proto3.util.setEnumType(RevealIdentityResponse_Result, "code.chat.v2.RevealIdentityResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "DIFFERENT_IDENTITY_REVEALED" },
]);

/**
 * @generated from message code.chat.v2.SetMuteStateRequest
 */
export class SetMuteStateRequest extends Message<SetMuteStateRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: bool is_muted = 3;
   */
  isMuted = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 4;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SetMuteStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetMuteStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined, b: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined): boolean {
    return proto3.util.equals(SetMuteStateRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.SetMuteStateResponse
 */
export class SetMuteStateResponse extends Message<SetMuteStateResponse> {
  /**
   * @generated from field: code.chat.v2.SetMuteStateResponse.Result result = 1;
   */
  result = SetMuteStateResponse_Result.OK;

  constructor(data?: PartialMessage<SetMuteStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetMuteStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetMuteStateResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined, b: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined): boolean {
    return proto3.util.equals(SetMuteStateResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.SetMuteStateResponse.Result
 */
export enum SetMuteStateResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: CANT_MUTE = 3;
   */
  CANT_MUTE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SetMuteStateResponse_Result)
proto3.util.setEnumType(SetMuteStateResponse_Result, "code.chat.v2.SetMuteStateResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "CANT_MUTE" },
]);

/**
 * @generated from message code.chat.v2.SetSubscriptionStateRequest
 */
export class SetSubscriptionStateRequest extends Message<SetSubscriptionStateRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: bool is_subscribed = 3;
   */
  isSubscribed = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 4;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SetSubscriptionStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetSubscriptionStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "is_subscribed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetSubscriptionStateRequest | PlainMessage<SetSubscriptionStateRequest> | undefined, b: SetSubscriptionStateRequest | PlainMessage<SetSubscriptionStateRequest> | undefined): boolean {
    return proto3.util.equals(SetSubscriptionStateRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.SetSubscriptionStateResponse
 */
export class SetSubscriptionStateResponse extends Message<SetSubscriptionStateResponse> {
  /**
   * @generated from field: code.chat.v2.SetSubscriptionStateResponse.Result result = 1;
   */
  result = SetSubscriptionStateResponse_Result.OK;

  constructor(data?: PartialMessage<SetSubscriptionStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetSubscriptionStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetSubscriptionStateResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetSubscriptionStateResponse | PlainMessage<SetSubscriptionStateResponse> | undefined, b: SetSubscriptionStateResponse | PlainMessage<SetSubscriptionStateResponse> | undefined): boolean {
    return proto3.util.equals(SetSubscriptionStateResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.SetSubscriptionStateResponse.Result
 */
export enum SetSubscriptionStateResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,

  /**
   * @generated from enum value: CANT_UNSUBSCRIBE = 3;
   */
  CANT_UNSUBSCRIBE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SetSubscriptionStateResponse_Result)
proto3.util.setEnumType(SetSubscriptionStateResponse_Result, "code.chat.v2.SetSubscriptionStateResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
  { no: 3, name: "CANT_UNSUBSCRIBE" },
]);

/**
 * @generated from message code.chat.v2.NotifyIsTypingRequest
 */
export class NotifyIsTypingRequest extends Message<NotifyIsTypingRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 2;
   */
  memberId?: ChatMemberId;

  /**
   * @generated from field: bool is_typing = 3;
   */
  isTyping = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 4;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<NotifyIsTypingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NotifyIsTypingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "is_typing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NotifyIsTypingRequest | PlainMessage<NotifyIsTypingRequest> | undefined, b: NotifyIsTypingRequest | PlainMessage<NotifyIsTypingRequest> | undefined): boolean {
    return proto3.util.equals(NotifyIsTypingRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.NotifyIsTypingResponse
 */
export class NotifyIsTypingResponse extends Message<NotifyIsTypingResponse> {
  /**
   * @generated from field: code.chat.v2.NotifyIsTypingResponse.Result result = 1;
   */
  result = NotifyIsTypingResponse_Result.OK;

  constructor(data?: PartialMessage<NotifyIsTypingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NotifyIsTypingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(NotifyIsTypingResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: NotifyIsTypingResponse | PlainMessage<NotifyIsTypingResponse> | undefined, b: NotifyIsTypingResponse | PlainMessage<NotifyIsTypingResponse> | undefined): boolean {
    return proto3.util.equals(NotifyIsTypingResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.NotifyIsTypingResponse.Result
 */
export enum NotifyIsTypingResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 2;
   */
  CHAT_NOT_FOUND = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(NotifyIsTypingResponse_Result)
proto3.util.setEnumType(NotifyIsTypingResponse_Result, "code.chat.v2.NotifyIsTypingResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CHAT_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.ChatMessageId
 */
export class ChatMessageId extends Message<ChatMessageId> {
  /**
   * Guaranteed to be a time-based UUID. This should be used to construct a
   * consistently ordered message history based on time using a simple byte
   * comparison.
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<ChatMessageId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMessageId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessageId {
    return new ChatMessageId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessageId {
    return new ChatMessageId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessageId {
    return new ChatMessageId().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessageId | PlainMessage<ChatMessageId> | undefined, b: ChatMessageId | PlainMessage<ChatMessageId> | undefined): boolean {
    return proto3.util.equals(ChatMessageId, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatMemberId
 */
export class ChatMemberId extends Message<ChatMemberId> {
  /**
   * Globally random UUID
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<ChatMemberId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMemberId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMemberId {
    return new ChatMemberId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMemberId {
    return new ChatMemberId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMemberId {
    return new ChatMemberId().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMemberId | PlainMessage<ChatMemberId> | undefined, b: ChatMemberId | PlainMessage<ChatMemberId> | undefined): boolean {
    return proto3.util.equals(ChatMemberId, a, b);
  }
}

/**
 * A chat
 *
 * todo: Support is_verified in a clean way
 *
 * @generated from message code.chat.v2.ChatMetadata
 */
export class ChatMetadata extends Message<ChatMetadata> {
  /**
   * Globally unique ID for this chat
   *
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * The type of chat
   *
   * @generated from field: code.chat.v2.ChatType type = 2;
   */
  type = ChatType.UNKNOWN_CHAT_TYPE;

  /**
   * The chat title, which will be localized by server when applicable
   *
   * @generated from field: string title = 3;
   */
  title = "";

  /**
   * The members in this chat
   *
   * For NOTIFICATION chats, this list has exactly 1 item
   * For TWO_WAY chats, this list has exactly 2 items
   *
   * todo: If we support group chats, then we'll likely return the first page
   *       or a prioritized list. The remaining members would be fetched via
   *       a new RPC.
   *
   * @generated from field: repeated code.chat.v2.ChatMember members = 4;
   */
  members: ChatMember[] = [];

  /**
   * Can the user mute this chat?
   *
   * @generated from field: bool can_mute = 5;
   */
  canMute = false;

  /**
   * Can the user unsubscribe from this chat?
   *
   * @generated from field: bool can_unsubscribe = 6;
   */
  canUnsubscribe = false;

  /**
   * Cursor value for this chat for reference in subsequent GetChatsRequest
   *
   * @generated from field: code.chat.v2.Cursor cursor = 7;
   */
  cursor?: Cursor;

  constructor(data?: PartialMessage<ChatMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ChatType) },
    { no: 3, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "members", kind: "message", T: ChatMember, repeated: true },
    { no: 5, name: "can_mute", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "can_unsubscribe", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMetadata {
    return new ChatMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMetadata {
    return new ChatMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMetadata {
    return new ChatMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMetadata | PlainMessage<ChatMetadata> | undefined, b: ChatMetadata | PlainMessage<ChatMetadata> | undefined): boolean {
    return proto3.util.equals(ChatMetadata, a, b);
  }
}

/**
 * A message in a chat
 *
 * @generated from message code.chat.v2.ChatMessage
 */
export class ChatMessage extends Message<ChatMessage> {
  /**
   * Globally unique ID for this message
   *
   * @generated from field: code.chat.v2.ChatMessageId message_id = 1;
   */
  messageId?: ChatMessageId;

  /**
   * The chat member that sent the message. For NOTIFICATION chats, this field
   * is omitted since the chat has exactly 1 member.
   *
   * @generated from field: code.chat.v2.ChatMemberId sender_id = 2;
   */
  senderId?: ChatMemberId;

  /**
   * Ordered message content. A message may have more than one piece of content.
   *
   * @generated from field: repeated code.chat.v2.Content content = 3;
   */
  content: Content[] = [];

  /**
   * Timestamp this message was generated at. This value is also encoded in
   * any time-based UUID message IDs.
   *
   * @generated from field: google.protobuf.Timestamp ts = 4;
   */
  ts?: Timestamp;

  /**
   * Cursor value for this message for reference in a paged GetMessagesRequest
   *
   * @generated from field: code.chat.v2.Cursor cursor = 5;
   */
  cursor?: Cursor;

  constructor(data?: PartialMessage<ChatMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_id", kind: "message", T: ChatMessageId },
    { no: 2, name: "sender_id", kind: "message", T: ChatMemberId },
    { no: 3, name: "content", kind: "message", T: Content, repeated: true },
    { no: 4, name: "ts", kind: "message", T: Timestamp },
    { no: 5, name: "cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessage {
    return new ChatMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessage | PlainMessage<ChatMessage> | undefined, b: ChatMessage | PlainMessage<ChatMessage> | undefined): boolean {
    return proto3.util.equals(ChatMessage, a, b);
  }
}

/**
 * A user in a chat
 *
 * @generated from message code.chat.v2.ChatMember
 */
export class ChatMember extends Message<ChatMember> {
  /**
   * Globally unique ID for this chat member
   *
   * @generated from field: code.chat.v2.ChatMemberId member_id = 1;
   */
  memberId?: ChatMemberId;

  /**
   * Is this chat member yourself? This enables client to identify which member_id
   * is themselves.
   *
   * @generated from field: bool is_self = 2;
   */
  isSelf = false;

  /**
   * The chat member's identity if it has been revealed.
   *
   * @generated from field: code.chat.v2.ChatMemberIdentity identity = 3;
   */
  identity?: ChatMemberIdentity;

  /**
   * Chat message state for this member. This list will have DELIVERED and READ
   * pointers, if they exist. SENT pointers should be inferred by persistence
   * on server.
   *
   * @generated from field: repeated code.chat.v2.Pointer pointers = 4;
   */
  pointers: Pointer[] = [];

  /**
   * Estimated number of unread messages for the chat member in this chat
   *
   * Only valid when is_self = true
   *
   * @generated from field: uint32 num_unread = 5;
   */
  numUnread = 0;

  /**
   * Has the chat member muted this chat?
   *
   * Only valid when is_self = true
   *
   * @generated from field: bool is_muted = 6;
   */
  isMuted = false;

  /**
   * Is the chat member subscribed to this chat?
   *
   * Only valid when is_self = true
   *
   * @generated from field: bool is_subscribed = 7;
   */
  isSubscribed = false;

  constructor(data?: PartialMessage<ChatMember>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMember";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 2, name: "is_self", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "identity", kind: "message", T: ChatMemberIdentity },
    { no: 4, name: "pointers", kind: "message", T: Pointer, repeated: true },
    { no: 5, name: "num_unread", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "is_subscribed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMember {
    return new ChatMember().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMember {
    return new ChatMember().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMember {
    return new ChatMember().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMember | PlainMessage<ChatMember> | undefined, b: ChatMember | PlainMessage<ChatMember> | undefined): boolean {
    return proto3.util.equals(ChatMember, a, b);
  }
}

/**
 * Identity to an external social platform that can be linked to a Code account
 *
 * @generated from message code.chat.v2.ChatMemberIdentity
 */
export class ChatMemberIdentity extends Message<ChatMemberIdentity> {
  /**
   * The external social platform linked to this chat member
   *
   * @generated from field: code.chat.v2.Platform platform = 1;
   */
  platform = Platform.UNKNOWN_PLATFORM;

  /**
   * The chat member's username on the external social platform
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * If present, the URL of the users profile pic.
   *
   * @generated from field: string profile_pic_url = 3;
   */
  profilePicUrl = "";

  constructor(data?: PartialMessage<ChatMemberIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatMemberIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "platform", kind: "enum", T: proto3.getEnumType(Platform) },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "profile_pic_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMemberIdentity {
    return new ChatMemberIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMemberIdentity {
    return new ChatMemberIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMemberIdentity {
    return new ChatMemberIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMemberIdentity | PlainMessage<ChatMemberIdentity> | undefined, b: ChatMemberIdentity | PlainMessage<ChatMemberIdentity> | undefined): boolean {
    return proto3.util.equals(ChatMemberIdentity, a, b);
  }
}

/**
 * Pointer in a chat indicating a user's message history state in a chat.
 *
 * @generated from message code.chat.v2.Pointer
 */
export class Pointer extends Message<Pointer> {
  /**
   * The type of pointer indicates which user's message history state can be
   * inferred from the pointer value. It is also possible to infer cross-pointer
   * state. For example, if a chat member has a READ pointer for a message with
   * ID N, then the DELIVERED pointer must be at least N.
   *
   * @generated from field: code.chat.v2.PointerType type = 1;
   */
  type = PointerType.UNKNOWN_POINTER_TYPE;

  /**
   * Everything at or before this message ID is considered to have the state
   * inferred by the type of pointer.
   *
   * @generated from field: code.chat.v2.ChatMessageId value = 2;
   */
  value?: ChatMessageId;

  /**
   * The chat member associated with this pointer state
   *
   * @generated from field: code.chat.v2.ChatMemberId member_id = 3;
   */
  memberId?: ChatMemberId;

  constructor(data?: PartialMessage<Pointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Pointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(PointerType) },
    { no: 2, name: "value", kind: "message", T: ChatMessageId },
    { no: 3, name: "member_id", kind: "message", T: ChatMemberId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pointer {
    return new Pointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJsonString(jsonString, options);
  }

  static equals(a: Pointer | PlainMessage<Pointer> | undefined, b: Pointer | PlainMessage<Pointer> | undefined): boolean {
    return proto3.util.equals(Pointer, a, b);
  }
}

/**
 * Content for a chat message
 *
 * @generated from message code.chat.v2.Content
 */
export class Content extends Message<Content> {
  /**
   * @generated from oneof code.chat.v2.Content.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.TextContent text = 1;
     */
    value: TextContent;
    case: "text";
  } | {
    /**
     * @generated from field: code.chat.v2.LocalizedContent localized = 2;
     */
    value: LocalizedContent;
    case: "localized";
  } | {
    /**
     * @generated from field: code.chat.v2.ExchangeDataContent exchange_data = 3;
     */
    value: ExchangeDataContent;
    case: "exchangeData";
  } | {
    /**
     * @generated from field: code.chat.v2.NaclBoxEncryptedContent nacl_box = 4;
     */
    value: NaclBoxEncryptedContent;
    case: "naclBox";
  } | {
    /**
     * @generated from field: code.chat.v2.ThankYouContent thank_you = 5;
     */
    value: ThankYouContent;
    case: "thankYou";
  } | {
    /**
     * @generated from field: code.chat.v2.IdentityRevealedContent identity_revealed = 6;
     */
    value: IdentityRevealedContent;
    case: "identityRevealed";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Content>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Content";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: TextContent, oneof: "type" },
    { no: 2, name: "localized", kind: "message", T: LocalizedContent, oneof: "type" },
    { no: 3, name: "exchange_data", kind: "message", T: ExchangeDataContent, oneof: "type" },
    { no: 4, name: "nacl_box", kind: "message", T: NaclBoxEncryptedContent, oneof: "type" },
    { no: 5, name: "thank_you", kind: "message", T: ThankYouContent, oneof: "type" },
    { no: 6, name: "identity_revealed", kind: "message", T: IdentityRevealedContent, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Content {
    return new Content().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJsonString(jsonString, options);
  }

  static equals(a: Content | PlainMessage<Content> | undefined, b: Content | PlainMessage<Content> | undefined): boolean {
    return proto3.util.equals(Content, a, b);
  }
}

/**
 * Raw text content
 *
 * @generated from message code.chat.v2.TextContent
 */
export class TextContent extends Message<TextContent> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<TextContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.TextContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextContent {
    return new TextContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextContent {
    return new TextContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextContent {
    return new TextContent().fromJsonString(jsonString, options);
  }

  static equals(a: TextContent | PlainMessage<TextContent> | undefined, b: TextContent | PlainMessage<TextContent> | undefined): boolean {
    return proto3.util.equals(TextContent, a, b);
  }
}

/**
 * Text content that is either a localization key that should be translated on
 * client, or a server-side translated piece of text.
 *
 * @generated from message code.chat.v2.LocalizedContent
 */
export class LocalizedContent extends Message<LocalizedContent> {
  /**
   * @generated from field: string key_or_text = 1;
   */
  keyOrText = "";

  constructor(data?: PartialMessage<LocalizedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.LocalizedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_or_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedContent {
    return new LocalizedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedContent | PlainMessage<LocalizedContent> | undefined, b: LocalizedContent | PlainMessage<LocalizedContent> | undefined): boolean {
    return proto3.util.equals(LocalizedContent, a, b);
  }
}

/**
 * Exchange data content for movement of a value of Kin
 *
 * @generated from message code.chat.v2.ExchangeDataContent
 */
export class ExchangeDataContent extends Message<ExchangeDataContent> {
  /**
   * Verb describing how the amount of Kin was exchanged
   *
   * Note: The current definition is not suitable outside a NOTIFICATION chat
   *       as not enough context is provided as to which member this verb is
   *       associated with.
   *
   * @generated from field: code.chat.v2.ExchangeDataContent.Verb verb = 1;
   */
  verb = ExchangeDataContent_Verb.UNKNOWN;

  /**
   * An amount of Kin being exchanged
   *
   * @generated from oneof code.chat.v2.ExchangeDataContent.exchange_data
   */
  exchangeData: {
    /**
     * @generated from field: code.transaction.v2.ExchangeData exact = 2;
     */
    value: ExchangeData;
    case: "exact";
  } | {
    /**
     * @generated from field: code.transaction.v2.ExchangeDataWithoutRate partial = 3;
     */
    value: ExchangeDataWithoutRate;
    case: "partial";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * An ID that can be referenced to the source of the exchange of Kin
   *
   * @generated from oneof code.chat.v2.ExchangeDataContent.reference
   */
  reference: {
    /**
     * @generated from field: code.common.v1.IntentId intent = 4;
     */
    value: IntentId;
    case: "intent";
  } | {
    /**
     * @generated from field: code.common.v1.Signature signature = 5;
     */
    value: Signature;
    case: "signature";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExchangeDataContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ExchangeDataContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verb", kind: "enum", T: proto3.getEnumType(ExchangeDataContent_Verb) },
    { no: 2, name: "exact", kind: "message", T: ExchangeData, oneof: "exchange_data" },
    { no: 3, name: "partial", kind: "message", T: ExchangeDataWithoutRate, oneof: "exchange_data" },
    { no: 4, name: "intent", kind: "message", T: IntentId, oneof: "reference" },
    { no: 5, name: "signature", kind: "message", T: Signature, oneof: "reference" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined, b: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined): boolean {
    return proto3.util.equals(ExchangeDataContent, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.ExchangeDataContent.Verb
 */
export enum ExchangeDataContent_Verb {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: GAVE = 1;
   */
  GAVE = 1,

  /**
   * @generated from enum value: RECEIVED = 2;
   */
  RECEIVED = 2,

  /**
   * @generated from enum value: WITHDREW = 3;
   */
  WITHDREW = 3,

  /**
   * @generated from enum value: DEPOSITED = 4;
   */
  DEPOSITED = 4,

  /**
   * @generated from enum value: SENT = 5;
   */
  SENT = 5,

  /**
   * @generated from enum value: RETURNED = 6;
   */
  RETURNED = 6,

  /**
   * @generated from enum value: SPENT = 7;
   */
  SPENT = 7,

  /**
   * @generated from enum value: PAID = 8;
   */
  PAID = 8,

  /**
   * @generated from enum value: PURCHASED = 9;
   */
  PURCHASED = 9,

  /**
   * @generated from enum value: RECEIVED_TIP = 10;
   */
  RECEIVED_TIP = 10,

  /**
   * @generated from enum value: SENT_TIP = 11;
   */
  SENT_TIP = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(ExchangeDataContent_Verb)
proto3.util.setEnumType(ExchangeDataContent_Verb, "code.chat.v2.ExchangeDataContent.Verb", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "GAVE" },
  { no: 2, name: "RECEIVED" },
  { no: 3, name: "WITHDREW" },
  { no: 4, name: "DEPOSITED" },
  { no: 5, name: "SENT" },
  { no: 6, name: "RETURNED" },
  { no: 7, name: "SPENT" },
  { no: 8, name: "PAID" },
  { no: 9, name: "PURCHASED" },
  { no: 10, name: "RECEIVED_TIP" },
  { no: 11, name: "SENT_TIP" },
]);

/**
 * Encrypted piece of content using NaCl box encryption
 *
 * @generated from message code.chat.v2.NaclBoxEncryptedContent
 */
export class NaclBoxEncryptedContent extends Message<NaclBoxEncryptedContent> {
  /**
   * The sender's public key that is used to derive the shared private key for
   * decryption for message content.
   *
   * @generated from field: code.common.v1.SolanaAccountId peer_public_key = 1;
   */
  peerPublicKey?: SolanaAccountId;

  /**
   * Globally random nonce that is unique to this encrypted piece of content
   *
   * @generated from field: bytes nonce = 2;
   */
  nonce = new Uint8Array(0);

  /**
   * The encrypted piece of message content
   *
   * @generated from field: bytes encrypted_payload = 3;
   */
  encryptedPayload = new Uint8Array(0);

  constructor(data?: PartialMessage<NaclBoxEncryptedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NaclBoxEncryptedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "peer_public_key", kind: "message", T: SolanaAccountId },
    { no: 2, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "encrypted_payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJsonString(jsonString, options);
  }

  static equals(a: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined, b: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined): boolean {
    return proto3.util.equals(NaclBoxEncryptedContent, a, b);
  }
}

/**
 * Thank you content that is used to thank Code users for tips
 *
 * @generated from message code.chat.v2.ThankYouContent
 */
export class ThankYouContent extends Message<ThankYouContent> {
  /**
   * The tip intent that is being thanked.
   *
   * @generated from field: code.common.v1.IntentId tip_intent = 1;
   */
  tipIntent?: IntentId;

  constructor(data?: PartialMessage<ThankYouContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ThankYouContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tip_intent", kind: "message", T: IntentId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThankYouContent {
    return new ThankYouContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThankYouContent {
    return new ThankYouContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThankYouContent {
    return new ThankYouContent().fromJsonString(jsonString, options);
  }

  static equals(a: ThankYouContent | PlainMessage<ThankYouContent> | undefined, b: ThankYouContent | PlainMessage<ThankYouContent> | undefined): boolean {
    return proto3.util.equals(ThankYouContent, a, b);
  }
}

/**
 * Identity revealed content that is inserted into chat whenever a chat member
 * reveals their identity
 *
 * @generated from message code.chat.v2.IdentityRevealedContent
 */
export class IdentityRevealedContent extends Message<IdentityRevealedContent> {
  /**
   * The chat member who revealed their identity
   *
   * @generated from field: code.chat.v2.ChatMemberId member_id = 1;
   */
  memberId?: ChatMemberId;

  /**
   * The identity that was revealed
   *
   * @generated from field: code.chat.v2.ChatMemberIdentity identity = 2;
   */
  identity?: ChatMemberIdentity;

  constructor(data?: PartialMessage<IdentityRevealedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.IdentityRevealedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 2, name: "identity", kind: "message", T: ChatMemberIdentity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentityRevealedContent {
    return new IdentityRevealedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentityRevealedContent {
    return new IdentityRevealedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentityRevealedContent {
    return new IdentityRevealedContent().fromJsonString(jsonString, options);
  }

  static equals(a: IdentityRevealedContent | PlainMessage<IdentityRevealedContent> | undefined, b: IdentityRevealedContent | PlainMessage<IdentityRevealedContent> | undefined): boolean {
    return proto3.util.equals(IdentityRevealedContent, a, b);
  }
}

/**
 * Opaque cursor used across paged APIs. Underlying bytes may change as paging
 * strategies evolve. Expected length value will vary based on the RPC being
 * executed.
 *
 * @generated from message code.chat.v2.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

/**
 * @generated from message code.chat.v2.IsTyping
 */
export class IsTyping extends Message<IsTyping> {
  /**
   * @generated from field: code.chat.v2.ChatMemberId member_id = 1;
   */
  memberId?: ChatMemberId;

  /**
   * is_typing indicates whether or not the user is typing.
   * If false, the user has explicitly stopped typing.
   *
   * @generated from field: bool is_typing = 2;
   */
  isTyping = false;

  constructor(data?: PartialMessage<IsTyping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.IsTyping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_id", kind: "message", T: ChatMemberId },
    { no: 2, name: "is_typing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsTyping {
    return new IsTyping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsTyping {
    return new IsTyping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsTyping {
    return new IsTyping().fromJsonString(jsonString, options);
  }

  static equals(a: IsTyping | PlainMessage<IsTyping> | undefined, b: IsTyping | PlainMessage<IsTyping> | undefined): boolean {
    return proto3.util.equals(IsTyping, a, b);
  }
}

