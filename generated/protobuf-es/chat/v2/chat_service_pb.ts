// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file chat/v2/chat_service.proto (package code.chat.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message as Message$1, proto3, Timestamp } from "@bufbuild/protobuf";
import { ChatId, ClientPong, IntentId, ServerPing, Signature, SolanaAccountId } from "../../common/v1/model_pb";
import { ExchangeData, ExchangeDataWithoutRate } from "../../transaction/v2/transaction_service_pb";

/**
 * @generated from enum code.chat.v2.ChatType
 */
export enum ChatType {
  /**
   * @generated from enum value: UNKNOWN_CHAT_TYPE = 0;
   */
  UNKNOWN_CHAT_TYPE = 0,

  /**
   * GROUP             = 3;
   *
   * @generated from enum value: TWO_WAY = 1;
   */
  TWO_WAY = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ChatType)
proto3.util.setEnumType(ChatType, "code.chat.v2.ChatType", [
  { no: 0, name: "UNKNOWN_CHAT_TYPE" },
  { no: 1, name: "TWO_WAY" },
]);

/**
 * @generated from enum code.chat.v2.Platform
 */
export enum Platform {
  /**
   * @generated from enum value: UNKNOWN_PLATFORM = 0;
   */
  UNKNOWN_PLATFORM = 0,

  /**
   * @generated from enum value: TWITTER = 1;
   */
  TWITTER = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Platform)
proto3.util.setEnumType(Platform, "code.chat.v2.Platform", [
  { no: 0, name: "UNKNOWN_PLATFORM" },
  { no: 1, name: "TWITTER" },
]);

/**
 * @generated from enum code.chat.v2.PointerType
 */
export enum PointerType {
  /**
   * @generated from enum value: UNKNOWN_POINTER_TYPE = 0;
   */
  UNKNOWN_POINTER_TYPE = 0,

  /**
   * Always inferred by OK result in SendMessageResponse or message presence in a chat
   *
   * @generated from enum value: SENT = 1;
   */
  SENT = 1,

  /**
   * @generated from enum value: DELIVERED = 2;
   */
  DELIVERED = 2,

  /**
   * @generated from enum value: READ = 3;
   */
  READ = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PointerType)
proto3.util.setEnumType(PointerType, "code.chat.v2.PointerType", [
  { no: 0, name: "UNKNOWN_POINTER_TYPE" },
  { no: 1, name: "SENT" },
  { no: 2, name: "DELIVERED" },
  { no: 3, name: "READ" },
]);

/**
 * @generated from message code.chat.v2.GetChatsRequest
 */
export class GetChatsRequest extends Message$1<GetChatsRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 3;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v2.Cursor cursor = 4;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v2.GetChatsRequest.Direction direction = 5;
   */
  direction = GetChatsRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetChatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetChatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "cursor", kind: "message", T: Cursor },
    { no: 5, name: "direction", kind: "enum", T: proto3.getEnumType(GetChatsRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined, b: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined): boolean {
    return proto3.util.equals(GetChatsRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetChatsRequest.Direction
 */
export enum GetChatsRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsRequest_Direction)
proto3.util.setEnumType(GetChatsRequest_Direction, "code.chat.v2.GetChatsRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v2.GetChatsResponse
 */
export class GetChatsResponse extends Message$1<GetChatsResponse> {
  /**
   * @generated from field: code.chat.v2.GetChatsResponse.Result result = 1;
   */
  result = GetChatsResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v2.Metadata chats = 2;
   */
  chats: Metadata[] = [];

  constructor(data?: PartialMessage<GetChatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetChatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetChatsResponse_Result) },
    { no: 2, name: "chats", kind: "message", T: Metadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined, b: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined): boolean {
    return proto3.util.equals(GetChatsResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetChatsResponse.Result
 */
export enum GetChatsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsResponse_Result)
proto3.util.setEnumType(GetChatsResponse_Result, "code.chat.v2.GetChatsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.chat.v2.GetMessagesRequest
 */
export class GetMessagesRequest extends Message$1<GetMessagesRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 4;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v2.Cursor cursor = 5;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v2.GetMessagesRequest.Direction direction = 6;
   */
  direction = GetMessagesRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetMessagesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetMessagesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
    { no: 4, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "cursor", kind: "message", T: Cursor },
    { no: 6, name: "direction", kind: "enum", T: proto3.getEnumType(GetMessagesRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined, b: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined): boolean {
    return proto3.util.equals(GetMessagesRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetMessagesRequest.Direction
 */
export enum GetMessagesRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesRequest_Direction)
proto3.util.setEnumType(GetMessagesRequest_Direction, "code.chat.v2.GetMessagesRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v2.GetMessagesResponse
 */
export class GetMessagesResponse extends Message$1<GetMessagesResponse> {
  /**
   * @generated from field: code.chat.v2.GetMessagesResponse.Result result = 1;
   */
  result = GetMessagesResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v2.Message messages = 2;
   */
  messages: Message[] = [];

  constructor(data?: PartialMessage<GetMessagesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.GetMessagesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetMessagesResponse_Result) },
    { no: 2, name: "messages", kind: "message", T: Message, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined, b: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined): boolean {
    return proto3.util.equals(GetMessagesResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.GetMessagesResponse.Result
 */
export enum GetMessagesResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesResponse_Result)
proto3.util.setEnumType(GetMessagesResponse_Result, "code.chat.v2.GetMessagesResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message code.chat.v2.OpenChatEventStream
 */
export class OpenChatEventStream extends Message$1<OpenChatEventStream> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<OpenChatEventStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.OpenChatEventStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenChatEventStream {
    return new OpenChatEventStream().fromJsonString(jsonString, options);
  }

  static equals(a: OpenChatEventStream | PlainMessage<OpenChatEventStream> | undefined, b: OpenChatEventStream | PlainMessage<OpenChatEventStream> | undefined): boolean {
    return proto3.util.equals(OpenChatEventStream, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEvent
 */
export class ChatStreamEvent extends Message$1<ChatStreamEvent> {
  /**
   * @generated from oneof code.chat.v2.ChatStreamEvent.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.Message message = 1;
     */
    value: Message;
    case: "message";
  } | {
    /**
     * @generated from field: code.chat.v2.Pointer pointer = 2;
     */
    value: Pointer;
    case: "pointer";
  } | {
    /**
     * @generated from field: code.chat.v2.IsTyping is_typing = 3;
     */
    value: IsTyping;
    case: "isTyping";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ChatStreamEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "message", T: Message, oneof: "type" },
    { no: 2, name: "pointer", kind: "message", T: Pointer, oneof: "type" },
    { no: 3, name: "is_typing", kind: "message", T: IsTyping, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEvent {
    return new ChatStreamEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEvent | PlainMessage<ChatStreamEvent> | undefined, b: ChatStreamEvent | PlainMessage<ChatStreamEvent> | undefined): boolean {
    return proto3.util.equals(ChatStreamEvent, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEventBatch
 */
export class ChatStreamEventBatch extends Message$1<ChatStreamEventBatch> {
  /**
   * @generated from field: repeated code.chat.v2.ChatStreamEvent events = 2;
   */
  events: ChatStreamEvent[] = [];

  constructor(data?: PartialMessage<ChatStreamEventBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEventBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "events", kind: "message", T: ChatStreamEvent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEventBatch {
    return new ChatStreamEventBatch().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEventBatch | PlainMessage<ChatStreamEventBatch> | undefined, b: ChatStreamEventBatch | PlainMessage<ChatStreamEventBatch> | undefined): boolean {
    return proto3.util.equals(ChatStreamEventBatch, a, b);
  }
}

/**
 * @generated from message code.chat.v2.ChatStreamEventError
 */
export class ChatStreamEventError extends Message$1<ChatStreamEventError> {
  /**
   * @generated from field: code.chat.v2.ChatStreamEventError.Code code = 1;
   */
  code = ChatStreamEventError_Code.DENIED;

  constructor(data?: PartialMessage<ChatStreamEventError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ChatStreamEventError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ChatStreamEventError_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatStreamEventError {
    return new ChatStreamEventError().fromJsonString(jsonString, options);
  }

  static equals(a: ChatStreamEventError | PlainMessage<ChatStreamEventError> | undefined, b: ChatStreamEventError | PlainMessage<ChatStreamEventError> | undefined): boolean {
    return proto3.util.equals(ChatStreamEventError, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.ChatStreamEventError.Code
 */
export enum ChatStreamEventError_Code {
  /**
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(ChatStreamEventError_Code)
proto3.util.setEnumType(ChatStreamEventError_Code, "code.chat.v2.ChatStreamEventError.Code", [
  { no: 0, name: "DENIED" },
]);

/**
 * @generated from message code.chat.v2.StreamChatEventsRequest
 */
export class StreamChatEventsRequest extends Message$1<StreamChatEventsRequest> {
  /**
   * @generated from oneof code.chat.v2.StreamChatEventsRequest.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.OpenChatEventStream open_stream = 1;
     */
    value: OpenChatEventStream;
    case: "openStream";
  } | {
    /**
     * @generated from field: code.common.v1.ClientPong pong = 2;
     */
    value: ClientPong;
    case: "pong";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StreamChatEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_stream", kind: "message", T: OpenChatEventStream, oneof: "type" },
    { no: 2, name: "pong", kind: "message", T: ClientPong, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsRequest {
    return new StreamChatEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined, b: StreamChatEventsRequest | PlainMessage<StreamChatEventsRequest> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StreamChatEventsResponse
 */
export class StreamChatEventsResponse extends Message$1<StreamChatEventsResponse> {
  /**
   * @generated from oneof code.chat.v2.StreamChatEventsResponse.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.ChatStreamEventBatch events = 1;
     */
    value: ChatStreamEventBatch;
    case: "events";
  } | {
    /**
     * @generated from field: code.common.v1.ServerPing ping = 2;
     */
    value: ServerPing;
    case: "ping";
  } | {
    /**
     * @generated from field: code.chat.v2.ChatStreamEventError error = 3;
     */
    value: ChatStreamEventError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamChatEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StreamChatEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: ChatStreamEventBatch, oneof: "type" },
    { no: 2, name: "ping", kind: "message", T: ServerPing, oneof: "type" },
    { no: 3, name: "error", kind: "message", T: ChatStreamEventError, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamChatEventsResponse {
    return new StreamChatEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined, b: StreamChatEventsResponse | PlainMessage<StreamChatEventsResponse> | undefined): boolean {
    return proto3.util.equals(StreamChatEventsResponse, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StartChatRequest
 */
export class StartChatRequest extends Message$1<StartChatRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from oneof code.chat.v2.StartChatRequest.parameters
   */
  parameters: {
    /**
     * @generated from field: code.chat.v2.StartTwoWayChatParameters two_way_chat = 3;
     */
    value: StartTwoWayChatParameters;
    case: "twoWayChat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartChatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartChatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "two_way_chat", kind: "message", T: StartTwoWayChatParameters, oneof: "parameters" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatRequest {
    return new StartChatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatRequest {
    return new StartChatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatRequest | PlainMessage<StartChatRequest> | undefined, b: StartChatRequest | PlainMessage<StartChatRequest> | undefined): boolean {
    return proto3.util.equals(StartChatRequest, a, b);
  }
}

/**
 * StartTwoWayChatParameters contains the parameters required to start
 * or recover a two way chat between the caller and the specified 'other_user'.
 *
 * The 'other_user' is currently the 'tip_address', normally retrieved from
 * user.Identity.GetTwitterUser(username).
 *
 * @generated from message code.chat.v2.StartTwoWayChatParameters
 */
export class StartTwoWayChatParameters extends Message$1<StartTwoWayChatParameters> {
  /**
   * The account id of the user the caller wishes to chat with.
   *
   * This will be the `tip` (or equivalent) address.
   *
   * @generated from field: code.common.v1.SolanaAccountId other_user = 1;
   */
  otherUser?: SolanaAccountId;

  /**
   * The intent_id of the payment that initiated the chat/friendship.
   *
   * This field is optional. It is used as an optimization when the server has not
   * yet observed the establishment of a friendship. In this case, the server will
   * use the provided intent_id to verify the friendship.
   *
   * This is most likely to occur when initiating a chat with a user for the first
   * time.
   *
   * @generated from field: code.common.v1.IntentId intent_id = 2;
   */
  intentId?: IntentId;

  constructor(data?: PartialMessage<StartTwoWayChatParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartTwoWayChatParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "other_user", kind: "message", T: SolanaAccountId },
    { no: 2, name: "intent_id", kind: "message", T: IntentId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartTwoWayChatParameters {
    return new StartTwoWayChatParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartTwoWayChatParameters {
    return new StartTwoWayChatParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartTwoWayChatParameters {
    return new StartTwoWayChatParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StartTwoWayChatParameters | PlainMessage<StartTwoWayChatParameters> | undefined, b: StartTwoWayChatParameters | PlainMessage<StartTwoWayChatParameters> | undefined): boolean {
    return proto3.util.equals(StartTwoWayChatParameters, a, b);
  }
}

/**
 * @generated from message code.chat.v2.StartChatResponse
 */
export class StartChatResponse extends Message$1<StartChatResponse> {
  /**
   * @generated from field: code.chat.v2.StartChatResponse.Result result = 1;
   */
  result = StartChatResponse_Result.OK;

  /**
   * The chat to use if the RPC was successful.
   *
   * @generated from field: code.chat.v2.Metadata chat = 2;
   */
  chat?: Metadata;

  constructor(data?: PartialMessage<StartChatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.StartChatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(StartChatResponse_Result) },
    { no: 2, name: "chat", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartChatResponse {
    return new StartChatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartChatResponse {
    return new StartChatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartChatResponse | PlainMessage<StartChatResponse> | undefined, b: StartChatResponse | PlainMessage<StartChatResponse> | undefined): boolean {
    return proto3.util.equals(StartChatResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.StartChatResponse.Result
 */
export enum StartChatResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * DENIED indicates the caller is not allowed to start/join the chat.
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * INVALID_PRAMETER indicates one of the parameters is invalid.
   *
   * @generated from enum value: INVALID_PARAMETER = 2;
   */
  INVALID_PARAMETER = 2,

  /**
   * PENDING indicates that the payment (for chat) intent is pending confirmation
   * before the service will permit the creation of the chat. This can happen in
   * cases where the block chain is particularly slow (beyond our RPC timeouts).
   *
   * @generated from enum value: PENDING = 3;
   */
  PENDING = 3,

  /**
   * MISSING_IDENTITY indicates that there is no identity for the user (creator).
   *
   * @generated from enum value: MISSING_IDENTITY = 4;
   */
  MISSING_IDENTITY = 4,

  /**
   * USER_NOT_FOUND indicates that (one of) the target user's was not found.
   *
   * @generated from enum value: USER_NOT_FOUND = 5;
   */
  USER_NOT_FOUND = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(StartChatResponse_Result)
proto3.util.setEnumType(StartChatResponse_Result, "code.chat.v2.StartChatResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "INVALID_PARAMETER" },
  { no: 3, name: "PENDING" },
  { no: 4, name: "MISSING_IDENTITY" },
  { no: 5, name: "USER_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.SendMessageRequest
 */
export class SendMessageRequest extends Message$1<SendMessageRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * Allowed content types that can be sent by client:
   *  - TextContent
   *  - ThankYouContent
   *
   * @generated from field: repeated code.chat.v2.Content content = 2;
   */
  content: Content[] = [];

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SendMessageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SendMessageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "content", kind: "message", T: Content, repeated: true },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendMessageRequest {
    return new SendMessageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendMessageRequest | PlainMessage<SendMessageRequest> | undefined, b: SendMessageRequest | PlainMessage<SendMessageRequest> | undefined): boolean {
    return proto3.util.equals(SendMessageRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.SendMessageResponse
 */
export class SendMessageResponse extends Message$1<SendMessageResponse> {
  /**
   * @generated from field: code.chat.v2.SendMessageResponse.Result result = 1;
   */
  result = SendMessageResponse_Result.OK;

  /**
   * The chat message that was sent if the RPC was succesful, which includes
   * server-side metadata like the generated message ID and official timestamp
   *
   * @generated from field: code.chat.v2.Message message = 2;
   */
  message?: Message;

  constructor(data?: PartialMessage<SendMessageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SendMessageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SendMessageResponse_Result) },
    { no: 2, name: "message", kind: "message", T: Message },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined, b: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined): boolean {
    return proto3.util.equals(SendMessageResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.SendMessageResponse.Result
 */
export enum SendMessageResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: INVALID_CONTENT_TYPE = 2;
   */
  INVALID_CONTENT_TYPE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SendMessageResponse_Result)
proto3.util.setEnumType(SendMessageResponse_Result, "code.chat.v2.SendMessageResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "INVALID_CONTENT_TYPE" },
]);

/**
 * @generated from message code.chat.v2.AdvancePointerRequest
 */
export class AdvancePointerRequest extends Message$1<AdvancePointerRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v2.Pointer pointer = 2;
   */
  pointer?: Pointer;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AdvancePointerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.AdvancePointerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "pointer", kind: "message", T: Pointer },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined, b: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined): boolean {
    return proto3.util.equals(AdvancePointerRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.AdvancePointerResponse
 */
export class AdvancePointerResponse extends Message$1<AdvancePointerResponse> {
  /**
   * @generated from field: code.chat.v2.AdvancePointerResponse.Result result = 1;
   */
  result = AdvancePointerResponse_Result.OK;

  constructor(data?: PartialMessage<AdvancePointerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.AdvancePointerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AdvancePointerResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined, b: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined): boolean {
    return proto3.util.equals(AdvancePointerResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.AdvancePointerResponse.Result
 */
export enum AdvancePointerResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: MESSAGE_NOT_FOUND = 2;
   */
  MESSAGE_NOT_FOUND = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AdvancePointerResponse_Result)
proto3.util.setEnumType(AdvancePointerResponse_Result, "code.chat.v2.AdvancePointerResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "MESSAGE_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v2.SetMuteStateRequest
 */
export class SetMuteStateRequest extends Message$1<SetMuteStateRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: bool is_muted = 2;
   */
  isMuted = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SetMuteStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetMuteStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined, b: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined): boolean {
    return proto3.util.equals(SetMuteStateRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.SetMuteStateResponse
 */
export class SetMuteStateResponse extends Message$1<SetMuteStateResponse> {
  /**
   * @generated from field: code.chat.v2.SetMuteStateResponse.Result result = 1;
   */
  result = SetMuteStateResponse_Result.OK;

  constructor(data?: PartialMessage<SetMuteStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.SetMuteStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetMuteStateResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined, b: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined): boolean {
    return proto3.util.equals(SetMuteStateResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.SetMuteStateResponse.Result
 */
export enum SetMuteStateResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * @generated from enum value: CANT_MUTE = 2;
   */
  CANT_MUTE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetMuteStateResponse_Result)
proto3.util.setEnumType(SetMuteStateResponse_Result, "code.chat.v2.SetMuteStateResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CANT_MUTE" },
]);

/**
 * @generated from message code.chat.v2.NotifyIsTypingRequest
 */
export class NotifyIsTypingRequest extends Message$1<NotifyIsTypingRequest> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: bool is_typing = 2;
   */
  isTyping = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<NotifyIsTypingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NotifyIsTypingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "is_typing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotifyIsTypingRequest {
    return new NotifyIsTypingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NotifyIsTypingRequest | PlainMessage<NotifyIsTypingRequest> | undefined, b: NotifyIsTypingRequest | PlainMessage<NotifyIsTypingRequest> | undefined): boolean {
    return proto3.util.equals(NotifyIsTypingRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v2.NotifyIsTypingResponse
 */
export class NotifyIsTypingResponse extends Message$1<NotifyIsTypingResponse> {
  /**
   * @generated from field: code.chat.v2.NotifyIsTypingResponse.Result result = 1;
   */
  result = NotifyIsTypingResponse_Result.OK;

  constructor(data?: PartialMessage<NotifyIsTypingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NotifyIsTypingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(NotifyIsTypingResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotifyIsTypingResponse {
    return new NotifyIsTypingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: NotifyIsTypingResponse | PlainMessage<NotifyIsTypingResponse> | undefined, b: NotifyIsTypingResponse | PlainMessage<NotifyIsTypingResponse> | undefined): boolean {
    return proto3.util.equals(NotifyIsTypingResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.NotifyIsTypingResponse.Result
 */
export enum NotifyIsTypingResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(NotifyIsTypingResponse_Result)
proto3.util.setEnumType(NotifyIsTypingResponse_Result, "code.chat.v2.NotifyIsTypingResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
]);

/**
 * @generated from message code.chat.v2.MessageId
 */
export class MessageId extends Message$1<MessageId> {
  /**
   * A lexicographically sortable ID that can be used to sort source of
   * chat history.
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<MessageId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.MessageId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageId {
    return new MessageId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageId {
    return new MessageId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MessageId {
    return new MessageId().fromJsonString(jsonString, options);
  }

  static equals(a: MessageId | PlainMessage<MessageId> | undefined, b: MessageId | PlainMessage<MessageId> | undefined): boolean {
    return proto3.util.equals(MessageId, a, b);
  }
}

/**
 * @generated from message code.chat.v2.MemberId
 */
export class MemberId extends Message$1<MemberId> {
  /**
   * The publically available 'deposit' address of the user.
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<MemberId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.MemberId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberId {
    return new MemberId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberId {
    return new MemberId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberId {
    return new MemberId().fromJsonString(jsonString, options);
  }

  static equals(a: MemberId | PlainMessage<MemberId> | undefined, b: MemberId | PlainMessage<MemberId> | undefined): boolean {
    return proto3.util.equals(MemberId, a, b);
  }
}

/**
 * A chat
 *
 * todo: Support is_verified in a clean way
 *
 * @generated from message code.chat.v2.Metadata
 */
export class Metadata extends Message$1<Metadata> {
  /**
   * @generated from field: code.common.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * The type of chat
   *
   * @generated from field: code.chat.v2.ChatType type = 2;
   */
  type = ChatType.UNKNOWN_CHAT_TYPE;

  /**
   * Cursor value for this chat for reference in subsequent GetChatsRequest
   *
   * @generated from field: code.chat.v2.Cursor cursor = 3;
   */
  cursor?: Cursor;

  /**
   * The chat title, which is _only_ set by server if an explicit title
   * was set. Otherwise, clients should fill in an appropriate chat title.
   *
   * @generated from field: string title = 4;
   */
  title = "";

  /**
   * The members in this chat.
   *
   * @generated from field: repeated code.chat.v2.Member members = 5;
   */
  members: Member[] = [];

  /**
   * Whether or not the chat is muted (from the perspective of the caller).
   *
   * @generated from field: bool is_muted = 6;
   */
  isMuted = false;

  /**
   * Whether or not the chat is mutable (from the persective of the caller).
   *
   * @generated from field: bool muteable = 7;
   */
  muteable = false;

  /**
   * Number of (estimated) unread message (from the perspective of the caller).
   *
   * @generated from field: uint32 num_unread = 8;
   */
  numUnread = 0;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ChatType) },
    { no: 3, name: "cursor", kind: "message", T: Cursor },
    { no: 4, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "members", kind: "message", T: Member, repeated: true },
    { no: 6, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "muteable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "num_unread", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * A message in a chat
 *
 * @generated from message code.chat.v2.Message
 */
export class Message extends Message$1<Message> {
  /**
   * Globally unique ID for this message
   *
   * @generated from field: code.chat.v2.MessageId message_id = 1;
   */
  messageId?: MessageId;

  /**
   * The chat member that sent the message. For NOTIFICATION chats, this field
   * is omitted since the chat has exactly 1 member.
   *
   * @generated from field: code.chat.v2.MemberId sender_id = 2;
   */
  senderId?: MemberId;

  /**
   * Ordered message content. A message may have more than one piece of content.
   *
   * @generated from field: repeated code.chat.v2.Content content = 3;
   */
  content: Content[] = [];

  /**
   * Timestamp this message was generated at. This value is also encoded in
   * any time-based UUID message IDs.
   *
   * @generated from field: google.protobuf.Timestamp ts = 4;
   */
  ts?: Timestamp;

  /**
   * Cursor value for this message for reference in a paged GetMessagesRequest
   *
   * @generated from field: code.chat.v2.Cursor cursor = 5;
   */
  cursor?: Cursor;

  constructor(data?: PartialMessage<Message>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Message";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_id", kind: "message", T: MessageId },
    { no: 2, name: "sender_id", kind: "message", T: MemberId },
    { no: 3, name: "content", kind: "message", T: Content, repeated: true },
    { no: 4, name: "ts", kind: "message", T: Timestamp },
    { no: 5, name: "cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message {
    return new Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJsonString(jsonString, options);
  }

  static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean {
    return proto3.util.equals(Message, a, b);
  }
}

/**
 * A user in a chat
 *
 * @generated from message code.chat.v2.Member
 */
export class Member extends Message$1<Member> {
  /**
   * Public AccountId (for is self...is derived via deposit address)
   *
   * @generated from field: code.chat.v2.MemberId member_id = 1;
   */
  memberId?: MemberId;

  /**
   * The chat member's identity if it has been revealed.
   *
   * Multiple identities here? Well really only needs twitter/other handles
   * Repeated PlatformHandles (where code doesn't matter)?
   *
   * @generated from field: code.chat.v2.MemberIdentity identity = 2;
   */
  identity?: MemberIdentity;

  /**
   * Chat message state for this member.
   *
   * If set, the list may contain DELIVERED and READ pointers. SENT pointers
   * are only shared between the sender and server, to indicate persistence.
   *
   * The server may wish to omit all pointers in various types of group chats
   * or as relief valves.
   *
   * @generated from field: repeated code.chat.v2.Pointer pointers = 3;
   */
  pointers: Pointer[] = [];

  constructor(data?: PartialMessage<Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_id", kind: "message", T: MemberId },
    { no: 2, name: "identity", kind: "message", T: MemberIdentity },
    { no: 3, name: "pointers", kind: "message", T: Pointer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Member {
    return new Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJsonString(jsonString, options);
  }

  static equals(a: Member | PlainMessage<Member> | undefined, b: Member | PlainMessage<Member> | undefined): boolean {
    return proto3.util.equals(Member, a, b);
  }
}

/**
 * Identity to an external social platform that can be linked to a Code account
 *
 * @generated from message code.chat.v2.MemberIdentity
 */
export class MemberIdentity extends Message$1<MemberIdentity> {
  /**
   * The external social platform linked to this chat member
   *
   * @generated from field: code.chat.v2.Platform platform = 1;
   */
  platform = Platform.UNKNOWN_PLATFORM;

  /**
   * The chat member's username on the external social platform.
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * If present, the display name of the user.
   *
   * @generated from field: string display_name = 3;
   */
  displayName = "";

  /**
   * If present, the URL of the users profile pic.
   *
   * @generated from field: string profile_pic_url = 4;
   */
  profilePicUrl = "";

  constructor(data?: PartialMessage<MemberIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.MemberIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "platform", kind: "enum", T: proto3.getEnumType(Platform) },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "profile_pic_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberIdentity {
    return new MemberIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberIdentity {
    return new MemberIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberIdentity {
    return new MemberIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: MemberIdentity | PlainMessage<MemberIdentity> | undefined, b: MemberIdentity | PlainMessage<MemberIdentity> | undefined): boolean {
    return proto3.util.equals(MemberIdentity, a, b);
  }
}

/**
 * Pointer in a chat indicating a user's message history state in a chat.
 *
 * @generated from message code.chat.v2.Pointer
 */
export class Pointer extends Message$1<Pointer> {
  /**
   * The type of pointer indicates which user's message history state can be
   * inferred from the pointer value. It is also possible to infer cross-pointer
   * state. For example, if a chat member has a READ pointer for a message with
   * ID N, then the DELIVERED pointer must be at least N.
   *
   * @generated from field: code.chat.v2.PointerType type = 1;
   */
  type = PointerType.UNKNOWN_POINTER_TYPE;

  /**
   * Everything at or before this message ID is considered to have the state
   * inferred by the type of pointer.
   *
   * @generated from field: code.chat.v2.MessageId value = 2;
   */
  value?: MessageId;

  /**
   * The chat member associated with this pointer state
   *
   * @generated from field: code.chat.v2.MemberId member_id = 3;
   */
  memberId?: MemberId;

  constructor(data?: PartialMessage<Pointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Pointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(PointerType) },
    { no: 2, name: "value", kind: "message", T: MessageId },
    { no: 3, name: "member_id", kind: "message", T: MemberId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pointer {
    return new Pointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJsonString(jsonString, options);
  }

  static equals(a: Pointer | PlainMessage<Pointer> | undefined, b: Pointer | PlainMessage<Pointer> | undefined): boolean {
    return proto3.util.equals(Pointer, a, b);
  }
}

/**
 * Content for a chat message
 *
 * @generated from message code.chat.v2.Content
 */
export class Content extends Message$1<Content> {
  /**
   * @generated from oneof code.chat.v2.Content.type
   */
  type: {
    /**
     * @generated from field: code.chat.v2.TextContent text = 1;
     */
    value: TextContent;
    case: "text";
  } | {
    /**
     * @generated from field: code.chat.v2.LocalizedContent localized = 2;
     */
    value: LocalizedContent;
    case: "localized";
  } | {
    /**
     * @generated from field: code.chat.v2.ExchangeDataContent exchange_data = 3;
     */
    value: ExchangeDataContent;
    case: "exchangeData";
  } | {
    /**
     * @generated from field: code.chat.v2.NaclBoxEncryptedContent nacl_box = 4;
     */
    value: NaclBoxEncryptedContent;
    case: "naclBox";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Content>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Content";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: TextContent, oneof: "type" },
    { no: 2, name: "localized", kind: "message", T: LocalizedContent, oneof: "type" },
    { no: 3, name: "exchange_data", kind: "message", T: ExchangeDataContent, oneof: "type" },
    { no: 4, name: "nacl_box", kind: "message", T: NaclBoxEncryptedContent, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Content {
    return new Content().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJsonString(jsonString, options);
  }

  static equals(a: Content | PlainMessage<Content> | undefined, b: Content | PlainMessage<Content> | undefined): boolean {
    return proto3.util.equals(Content, a, b);
  }
}

/**
 * Raw text content
 *
 * @generated from message code.chat.v2.TextContent
 */
export class TextContent extends Message$1<TextContent> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<TextContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.TextContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextContent {
    return new TextContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextContent {
    return new TextContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextContent {
    return new TextContent().fromJsonString(jsonString, options);
  }

  static equals(a: TextContent | PlainMessage<TextContent> | undefined, b: TextContent | PlainMessage<TextContent> | undefined): boolean {
    return proto3.util.equals(TextContent, a, b);
  }
}

/**
 * Text content that is either a localization key that should be translated on
 * client, or a server-side translated piece of text.
 *
 * @generated from message code.chat.v2.LocalizedContent
 */
export class LocalizedContent extends Message$1<LocalizedContent> {
  /**
   * @generated from field: string key_or_text = 1;
   */
  keyOrText = "";

  constructor(data?: PartialMessage<LocalizedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.LocalizedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_or_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedContent {
    return new LocalizedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedContent | PlainMessage<LocalizedContent> | undefined, b: LocalizedContent | PlainMessage<LocalizedContent> | undefined): boolean {
    return proto3.util.equals(LocalizedContent, a, b);
  }
}

/**
 * Exchange data content for movement of a value of Kin
 *
 * @generated from message code.chat.v2.ExchangeDataContent
 */
export class ExchangeDataContent extends Message$1<ExchangeDataContent> {
  /**
   * Verb describing how the amount of Kin was exchanged
   *
   * Note: The current definition is not suitable outside a NOTIFICATION chat
   *       as not enough context is provided as to which member this verb is
   *       associated with.
   *
   * @generated from field: code.chat.v2.ExchangeDataContent.Verb verb = 1;
   */
  verb = ExchangeDataContent_Verb.UNKNOWN;

  /**
   * An amount of Kin being exchanged
   *
   * @generated from oneof code.chat.v2.ExchangeDataContent.exchange_data
   */
  exchangeData: {
    /**
     * @generated from field: code.transaction.v2.ExchangeData exact = 2;
     */
    value: ExchangeData;
    case: "exact";
  } | {
    /**
     * @generated from field: code.transaction.v2.ExchangeDataWithoutRate partial = 3;
     */
    value: ExchangeDataWithoutRate;
    case: "partial";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * An ID that can be referenced to the source of the exchange of Kin
   *
   * @generated from oneof code.chat.v2.ExchangeDataContent.reference
   */
  reference: {
    /**
     * @generated from field: code.common.v1.IntentId intent = 4;
     */
    value: IntentId;
    case: "intent";
  } | {
    /**
     * @generated from field: code.common.v1.Signature signature = 5;
     */
    value: Signature;
    case: "signature";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExchangeDataContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.ExchangeDataContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verb", kind: "enum", T: proto3.getEnumType(ExchangeDataContent_Verb) },
    { no: 2, name: "exact", kind: "message", T: ExchangeData, oneof: "exchange_data" },
    { no: 3, name: "partial", kind: "message", T: ExchangeDataWithoutRate, oneof: "exchange_data" },
    { no: 4, name: "intent", kind: "message", T: IntentId, oneof: "reference" },
    { no: 5, name: "signature", kind: "message", T: Signature, oneof: "reference" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined, b: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined): boolean {
    return proto3.util.equals(ExchangeDataContent, a, b);
  }
}

/**
 * @generated from enum code.chat.v2.ExchangeDataContent.Verb
 */
export enum ExchangeDataContent_Verb {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: GAVE = 1;
   */
  GAVE = 1,

  /**
   * @generated from enum value: RECEIVED = 2;
   */
  RECEIVED = 2,

  /**
   * @generated from enum value: WITHDREW = 3;
   */
  WITHDREW = 3,

  /**
   * @generated from enum value: DEPOSITED = 4;
   */
  DEPOSITED = 4,

  /**
   * @generated from enum value: SENT = 5;
   */
  SENT = 5,

  /**
   * @generated from enum value: RETURNED = 6;
   */
  RETURNED = 6,

  /**
   * @generated from enum value: SPENT = 7;
   */
  SPENT = 7,

  /**
   * @generated from enum value: PAID = 8;
   */
  PAID = 8,

  /**
   * @generated from enum value: PURCHASED = 9;
   */
  PURCHASED = 9,

  /**
   * @generated from enum value: RECEIVED_TIP = 10;
   */
  RECEIVED_TIP = 10,

  /**
   * @generated from enum value: SENT_TIP = 11;
   */
  SENT_TIP = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(ExchangeDataContent_Verb)
proto3.util.setEnumType(ExchangeDataContent_Verb, "code.chat.v2.ExchangeDataContent.Verb", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "GAVE" },
  { no: 2, name: "RECEIVED" },
  { no: 3, name: "WITHDREW" },
  { no: 4, name: "DEPOSITED" },
  { no: 5, name: "SENT" },
  { no: 6, name: "RETURNED" },
  { no: 7, name: "SPENT" },
  { no: 8, name: "PAID" },
  { no: 9, name: "PURCHASED" },
  { no: 10, name: "RECEIVED_TIP" },
  { no: 11, name: "SENT_TIP" },
]);

/**
 * Encrypted piece of content using NaCl box encryption
 *
 * @generated from message code.chat.v2.NaclBoxEncryptedContent
 */
export class NaclBoxEncryptedContent extends Message$1<NaclBoxEncryptedContent> {
  /**
   * The sender's public key that is used to derive the shared private key for
   * decryption for message content.
   *
   * @generated from field: code.common.v1.SolanaAccountId peer_public_key = 1;
   */
  peerPublicKey?: SolanaAccountId;

  /**
   * Globally random nonce that is unique to this encrypted piece of content
   *
   * @generated from field: bytes nonce = 2;
   */
  nonce = new Uint8Array(0);

  /**
   * The encrypted piece of message content
   *
   * @generated from field: bytes encrypted_payload = 3;
   */
  encryptedPayload = new Uint8Array(0);

  constructor(data?: PartialMessage<NaclBoxEncryptedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.NaclBoxEncryptedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "peer_public_key", kind: "message", T: SolanaAccountId },
    { no: 2, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "encrypted_payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJsonString(jsonString, options);
  }

  static equals(a: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined, b: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined): boolean {
    return proto3.util.equals(NaclBoxEncryptedContent, a, b);
  }
}

/**
 * Opaque cursor used across paged APIs. Underlying bytes may change as paging
 * strategies evolve. Expected length value will vary based on the RPC being
 * executed.
 *
 * @generated from message code.chat.v2.Cursor
 */
export class Cursor extends Message$1<Cursor> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

/**
 * @generated from message code.chat.v2.IsTyping
 */
export class IsTyping extends Message$1<IsTyping> {
  /**
   * @generated from field: code.chat.v2.MemberId member_id = 1;
   */
  memberId?: MemberId;

  /**
   * is_typing indicates whether or not the user is typing.
   * If false, the user has explicitly stopped typing.
   *
   * @generated from field: bool is_typing = 2;
   */
  isTyping = false;

  constructor(data?: PartialMessage<IsTyping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v2.IsTyping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_id", kind: "message", T: MemberId },
    { no: 2, name: "is_typing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsTyping {
    return new IsTyping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsTyping {
    return new IsTyping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsTyping {
    return new IsTyping().fromJsonString(jsonString, options);
  }

  static equals(a: IsTyping | PlainMessage<IsTyping> | undefined, b: IsTyping | PlainMessage<IsTyping> | undefined): boolean {
    return proto3.util.equals(IsTyping, a, b);
  }
}

