// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file chat/v1/chat_service.proto (package code.chat.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Domain, Signature, SolanaAccountId } from "../../common/v1/model_pb";
import { ExchangeData, ExchangeDataWithoutRate } from "../../transaction/v2/transaction_service_pb";

/**
 * @generated from message code.chat.v1.GetChatsRequest
 */
export class GetChatsRequest extends Message<GetChatsRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 3;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v1.Cursor cursor = 4;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v1.GetChatsRequest.Direction direction = 5;
   */
  direction = GetChatsRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetChatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.GetChatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "cursor", kind: "message", T: Cursor },
    { no: 5, name: "direction", kind: "enum", T: proto3.getEnumType(GetChatsRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsRequest {
    return new GetChatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined, b: GetChatsRequest | PlainMessage<GetChatsRequest> | undefined): boolean {
    return proto3.util.equals(GetChatsRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.GetChatsRequest.Direction
 */
export enum GetChatsRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsRequest_Direction)
proto3.util.setEnumType(GetChatsRequest_Direction, "code.chat.v1.GetChatsRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v1.GetChatsResponse
 */
export class GetChatsResponse extends Message<GetChatsResponse> {
  /**
   * @generated from field: code.chat.v1.GetChatsResponse.Result result = 1;
   */
  result = GetChatsResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v1.ChatMetadata chats = 2;
   */
  chats: ChatMetadata[] = [];

  constructor(data?: PartialMessage<GetChatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.GetChatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetChatsResponse_Result) },
    { no: 2, name: "chats", kind: "message", T: ChatMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChatsResponse {
    return new GetChatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined, b: GetChatsResponse | PlainMessage<GetChatsResponse> | undefined): boolean {
    return proto3.util.equals(GetChatsResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.GetChatsResponse.Result
 */
export enum GetChatsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetChatsResponse_Result)
proto3.util.setEnumType(GetChatsResponse_Result, "code.chat.v1.GetChatsResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v1.GetMessagesRequest
 */
export class GetMessagesRequest extends Message<GetMessagesRequest> {
  /**
   * @generated from field: code.chat.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  /**
   * @generated from field: uint32 page_size = 4;
   */
  pageSize = 0;

  /**
   * @generated from field: code.chat.v1.Cursor cursor = 5;
   */
  cursor?: Cursor;

  /**
   * @generated from field: code.chat.v1.GetMessagesRequest.Direction direction = 6;
   */
  direction = GetMessagesRequest_Direction.ASC;

  constructor(data?: PartialMessage<GetMessagesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.GetMessagesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
    { no: 4, name: "page_size", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "cursor", kind: "message", T: Cursor },
    { no: 6, name: "direction", kind: "enum", T: proto3.getEnumType(GetMessagesRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesRequest {
    return new GetMessagesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined, b: GetMessagesRequest | PlainMessage<GetMessagesRequest> | undefined): boolean {
    return proto3.util.equals(GetMessagesRequest, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.GetMessagesRequest.Direction
 */
export enum GetMessagesRequest_Direction {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesRequest_Direction)
proto3.util.setEnumType(GetMessagesRequest_Direction, "code.chat.v1.GetMessagesRequest.Direction", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * @generated from message code.chat.v1.GetMessagesResponse
 */
export class GetMessagesResponse extends Message<GetMessagesResponse> {
  /**
   * @generated from field: code.chat.v1.GetMessagesResponse.Result result = 1;
   */
  result = GetMessagesResponse_Result.OK;

  /**
   * @generated from field: repeated code.chat.v1.ChatMessage messages = 2;
   */
  messages: ChatMessage[] = [];

  constructor(data?: PartialMessage<GetMessagesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.GetMessagesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetMessagesResponse_Result) },
    { no: 2, name: "messages", kind: "message", T: ChatMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMessagesResponse {
    return new GetMessagesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined, b: GetMessagesResponse | PlainMessage<GetMessagesResponse> | undefined): boolean {
    return proto3.util.equals(GetMessagesResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.GetMessagesResponse.Result
 */
export enum GetMessagesResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetMessagesResponse_Result)
proto3.util.setEnumType(GetMessagesResponse_Result, "code.chat.v1.GetMessagesResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v1.AdvancePointerRequest
 */
export class AdvancePointerRequest extends Message<AdvancePointerRequest> {
  /**
   * @generated from field: code.chat.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: code.chat.v1.Pointer pointer = 2;
   */
  pointer?: Pointer;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AdvancePointerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.AdvancePointerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "pointer", kind: "message", T: Pointer },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerRequest {
    return new AdvancePointerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined, b: AdvancePointerRequest | PlainMessage<AdvancePointerRequest> | undefined): boolean {
    return proto3.util.equals(AdvancePointerRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v1.AdvancePointerResponse
 */
export class AdvancePointerResponse extends Message<AdvancePointerResponse> {
  /**
   * @generated from field: code.chat.v1.AdvancePointerResponse.Result result = 1;
   */
  result = AdvancePointerResponse_Result.OK;

  constructor(data?: PartialMessage<AdvancePointerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.AdvancePointerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AdvancePointerResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdvancePointerResponse {
    return new AdvancePointerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined, b: AdvancePointerResponse | PlainMessage<AdvancePointerResponse> | undefined): boolean {
    return proto3.util.equals(AdvancePointerResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.AdvancePointerResponse.Result
 */
export enum AdvancePointerResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 1;
   */
  CHAT_NOT_FOUND = 1,

  /**
   * @generated from enum value: MESSAGE_NOT_FOUND = 2;
   */
  MESSAGE_NOT_FOUND = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AdvancePointerResponse_Result)
proto3.util.setEnumType(AdvancePointerResponse_Result, "code.chat.v1.AdvancePointerResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "CHAT_NOT_FOUND" },
  { no: 2, name: "MESSAGE_NOT_FOUND" },
]);

/**
 * @generated from message code.chat.v1.SetMuteStateRequest
 */
export class SetMuteStateRequest extends Message<SetMuteStateRequest> {
  /**
   * @generated from field: code.chat.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: bool is_muted = 2;
   */
  isMuted = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SetMuteStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.SetMuteStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateRequest {
    return new SetMuteStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined, b: SetMuteStateRequest | PlainMessage<SetMuteStateRequest> | undefined): boolean {
    return proto3.util.equals(SetMuteStateRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v1.SetMuteStateResponse
 */
export class SetMuteStateResponse extends Message<SetMuteStateResponse> {
  /**
   * @generated from field: code.chat.v1.SetMuteStateResponse.Result result = 1;
   */
  result = SetMuteStateResponse_Result.OK;

  constructor(data?: PartialMessage<SetMuteStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.SetMuteStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetMuteStateResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMuteStateResponse {
    return new SetMuteStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined, b: SetMuteStateResponse | PlainMessage<SetMuteStateResponse> | undefined): boolean {
    return proto3.util.equals(SetMuteStateResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.SetMuteStateResponse.Result
 */
export enum SetMuteStateResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 1;
   */
  CHAT_NOT_FOUND = 1,

  /**
   * @generated from enum value: CANT_MUTE = 2;
   */
  CANT_MUTE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetMuteStateResponse_Result)
proto3.util.setEnumType(SetMuteStateResponse_Result, "code.chat.v1.SetMuteStateResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "CHAT_NOT_FOUND" },
  { no: 2, name: "CANT_MUTE" },
]);

/**
 * @generated from message code.chat.v1.SetSubscriptionStateRequest
 */
export class SetSubscriptionStateRequest extends Message<SetSubscriptionStateRequest> {
  /**
   * @generated from field: code.chat.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * @generated from field: bool is_subscribed = 2;
   */
  isSubscribed = false;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 3;
   */
  owner?: SolanaAccountId;

  /**
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SetSubscriptionStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.SetSubscriptionStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "is_subscribed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSubscriptionStateRequest {
    return new SetSubscriptionStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetSubscriptionStateRequest | PlainMessage<SetSubscriptionStateRequest> | undefined, b: SetSubscriptionStateRequest | PlainMessage<SetSubscriptionStateRequest> | undefined): boolean {
    return proto3.util.equals(SetSubscriptionStateRequest, a, b);
  }
}

/**
 * @generated from message code.chat.v1.SetSubscriptionStateResponse
 */
export class SetSubscriptionStateResponse extends Message<SetSubscriptionStateResponse> {
  /**
   * @generated from field: code.chat.v1.SetSubscriptionStateResponse.Result result = 1;
   */
  result = SetSubscriptionStateResponse_Result.OK;

  constructor(data?: PartialMessage<SetSubscriptionStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.SetSubscriptionStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SetSubscriptionStateResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSubscriptionStateResponse {
    return new SetSubscriptionStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetSubscriptionStateResponse | PlainMessage<SetSubscriptionStateResponse> | undefined, b: SetSubscriptionStateResponse | PlainMessage<SetSubscriptionStateResponse> | undefined): boolean {
    return proto3.util.equals(SetSubscriptionStateResponse, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.SetSubscriptionStateResponse.Result
 */
export enum SetSubscriptionStateResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: CHAT_NOT_FOUND = 1;
   */
  CHAT_NOT_FOUND = 1,

  /**
   * @generated from enum value: CANT_UNSUBSCRIBE = 2;
   */
  CANT_UNSUBSCRIBE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetSubscriptionStateResponse_Result)
proto3.util.setEnumType(SetSubscriptionStateResponse_Result, "code.chat.v1.SetSubscriptionStateResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "CHAT_NOT_FOUND" },
  { no: 2, name: "CANT_UNSUBSCRIBE" },
]);

/**
 * @generated from message code.chat.v1.ChatId
 */
export class ChatId extends Message<ChatId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<ChatId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.ChatId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatId {
    return new ChatId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatId {
    return new ChatId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatId {
    return new ChatId().fromJsonString(jsonString, options);
  }

  static equals(a: ChatId | PlainMessage<ChatId> | undefined, b: ChatId | PlainMessage<ChatId> | undefined): boolean {
    return proto3.util.equals(ChatId, a, b);
  }
}

/**
 * @generated from message code.chat.v1.ChatMessageId
 */
export class ChatMessageId extends Message<ChatMessageId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<ChatMessageId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.ChatMessageId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessageId {
    return new ChatMessageId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessageId {
    return new ChatMessageId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessageId {
    return new ChatMessageId().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessageId | PlainMessage<ChatMessageId> | undefined, b: ChatMessageId | PlainMessage<ChatMessageId> | undefined): boolean {
    return proto3.util.equals(ChatMessageId, a, b);
  }
}

/**
 * @generated from message code.chat.v1.Pointer
 */
export class Pointer extends Message<Pointer> {
  /**
   * @generated from field: code.chat.v1.Pointer.Kind kind = 1;
   */
  kind = Pointer_Kind.UNKNOWN;

  /**
   * @generated from field: code.chat.v1.ChatMessageId value = 2;
   */
  value?: ChatMessageId;

  constructor(data?: PartialMessage<Pointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.Pointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(Pointer_Kind) },
    { no: 2, name: "value", kind: "message", T: ChatMessageId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pointer {
    return new Pointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pointer {
    return new Pointer().fromJsonString(jsonString, options);
  }

  static equals(a: Pointer | PlainMessage<Pointer> | undefined, b: Pointer | PlainMessage<Pointer> | undefined): boolean {
    return proto3.util.equals(Pointer, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.Pointer.Kind
 */
export enum Pointer_Kind {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: READ = 1;
   */
  READ = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Pointer_Kind)
proto3.util.setEnumType(Pointer_Kind, "code.chat.v1.Pointer.Kind", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "READ" },
]);

/**
 * @generated from message code.chat.v1.ChatMetadata
 */
export class ChatMetadata extends Message<ChatMetadata> {
  /**
   * @generated from field: code.chat.v1.ChatId chat_id = 1;
   */
  chatId?: ChatId;

  /**
   * Recommended chat title inferred by the type of chat
   *
   * @generated from oneof code.chat.v1.ChatMetadata.title
   */
  title: {
    /**
     * @generated from field: code.chat.v1.LocalizedContent localized = 2;
     */
    value: LocalizedContent;
    case: "localized";
  } | {
    /**
     * @generated from field: code.common.v1.Domain domain = 3;
     */
    value: Domain;
    case: "domain";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Pointer in the chat indicating the most recently read message by the user
   *
   * @generated from field: code.chat.v1.Pointer read_pointer = 4;
   */
  readPointer?: Pointer;

  /**
   * Estimated number of unread messages in this chat
   *
   * @generated from field: uint32 num_unread = 5;
   */
  numUnread = 0;

  /**
   * Has the user muted this chat?
   *
   * @generated from field: bool is_muted = 6;
   */
  isMuted = false;

  /**
   * Is the user subscribed to this chat?
   *
   * @generated from field: bool is_subscribed = 7;
   */
  isSubscribed = false;

  /**
   * Can the user mute this chat?
   *
   * @generated from field: bool can_mute = 8;
   */
  canMute = false;

  /**
   * Can the user unsubscribe from this chat?
   *
   * @generated from field: bool can_unsubscribe = 9;
   */
  canUnsubscribe = false;

  /**
   * Cursor value for this chat for reference in subsequent GetChatsRequest 
   *
   * @generated from field: code.chat.v1.Cursor cursor = 10;
   */
  cursor?: Cursor;

  /**
   * Is this a verified chat?
   *
   * Note: It's possible to have two chats with the same title, but with
   * different verification statuses. They should be treated separately.
   *
   * @generated from field: bool is_verified = 11;
   */
  isVerified = false;

  constructor(data?: PartialMessage<ChatMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.ChatMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chat_id", kind: "message", T: ChatId },
    { no: 2, name: "localized", kind: "message", T: LocalizedContent, oneof: "title" },
    { no: 3, name: "domain", kind: "message", T: Domain, oneof: "title" },
    { no: 4, name: "read_pointer", kind: "message", T: Pointer },
    { no: 5, name: "num_unread", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "is_muted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "is_subscribed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "can_mute", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "can_unsubscribe", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "cursor", kind: "message", T: Cursor },
    { no: 11, name: "is_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMetadata {
    return new ChatMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMetadata {
    return new ChatMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMetadata {
    return new ChatMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMetadata | PlainMessage<ChatMetadata> | undefined, b: ChatMetadata | PlainMessage<ChatMetadata> | undefined): boolean {
    return proto3.util.equals(ChatMetadata, a, b);
  }
}

/**
 * @generated from message code.chat.v1.ChatMessage
 */
export class ChatMessage extends Message<ChatMessage> {
  /**
   * Unique ID for this message
   *
   * @generated from field: code.chat.v1.ChatMessageId message_id = 1;
   */
  messageId?: ChatMessageId;

  /**
   * Timestamp this message was generated at
   *
   * @generated from field: google.protobuf.Timestamp ts = 2;
   */
  ts?: Timestamp;

  /**
   * Ordered message content. A message may have more than one piece of content.
   *
   * @generated from field: repeated code.chat.v1.Content content = 3;
   */
  content: Content[] = [];

  /**
   * Cursor value for this message for reference in subsequent GetMessagesRequest 
   *
   * @generated from field: code.chat.v1.Cursor cursor = 4;
   */
  cursor?: Cursor;

  constructor(data?: PartialMessage<ChatMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.ChatMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_id", kind: "message", T: ChatMessageId },
    { no: 2, name: "ts", kind: "message", T: Timestamp },
    { no: 3, name: "content", kind: "message", T: Content, repeated: true },
    { no: 4, name: "cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessage {
    return new ChatMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessage {
    return new ChatMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessage | PlainMessage<ChatMessage> | undefined, b: ChatMessage | PlainMessage<ChatMessage> | undefined): boolean {
    return proto3.util.equals(ChatMessage, a, b);
  }
}

/**
 * @generated from message code.chat.v1.Content
 */
export class Content extends Message<Content> {
  /**
   * @generated from oneof code.chat.v1.Content.type
   */
  type: {
    /**
     * @generated from field: code.chat.v1.LocalizedContent localized = 1;
     */
    value: LocalizedContent;
    case: "localized";
  } | {
    /**
     * @generated from field: code.chat.v1.ExchangeDataContent exchange_data = 2;
     */
    value: ExchangeDataContent;
    case: "exchangeData";
  } | {
    /**
     * @generated from field: code.chat.v1.NaclBoxEncryptedContent nacl_box = 3;
     */
    value: NaclBoxEncryptedContent;
    case: "naclBox";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Content>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.Content";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "localized", kind: "message", T: LocalizedContent, oneof: "type" },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeDataContent, oneof: "type" },
    { no: 3, name: "nacl_box", kind: "message", T: NaclBoxEncryptedContent, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Content {
    return new Content().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Content {
    return new Content().fromJsonString(jsonString, options);
  }

  static equals(a: Content | PlainMessage<Content> | undefined, b: Content | PlainMessage<Content> | undefined): boolean {
    return proto3.util.equals(Content, a, b);
  }
}

/**
 * @generated from message code.chat.v1.LocalizedContent
 */
export class LocalizedContent extends Message<LocalizedContent> {
  /**
   * When server-side localization is in place, clients will always see the
   * localized text.
   *
   * @generated from field: string key_or_text = 1;
   */
  keyOrText = "";

  constructor(data?: PartialMessage<LocalizedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.LocalizedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_or_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedContent {
    return new LocalizedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedContent {
    return new LocalizedContent().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedContent | PlainMessage<LocalizedContent> | undefined, b: LocalizedContent | PlainMessage<LocalizedContent> | undefined): boolean {
    return proto3.util.equals(LocalizedContent, a, b);
  }
}

/**
 * @generated from message code.chat.v1.ExchangeDataContent
 */
export class ExchangeDataContent extends Message<ExchangeDataContent> {
  /**
   * @generated from field: code.chat.v1.ExchangeDataContent.Verb verb = 1;
   */
  verb = ExchangeDataContent_Verb.UNKNOWN;

  /**
   * @generated from oneof code.chat.v1.ExchangeDataContent.exchange_data
   */
  exchangeData: {
    /**
     * @generated from field: code.transaction.v2.ExchangeData exact = 2;
     */
    value: ExchangeData;
    case: "exact";
  } | {
    /**
     * @generated from field: code.transaction.v2.ExchangeDataWithoutRate partial = 3;
     */
    value: ExchangeDataWithoutRate;
    case: "partial";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExchangeDataContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.ExchangeDataContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verb", kind: "enum", T: proto3.getEnumType(ExchangeDataContent_Verb) },
    { no: 2, name: "exact", kind: "message", T: ExchangeData, oneof: "exchange_data" },
    { no: 3, name: "partial", kind: "message", T: ExchangeDataWithoutRate, oneof: "exchange_data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataContent {
    return new ExchangeDataContent().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined, b: ExchangeDataContent | PlainMessage<ExchangeDataContent> | undefined): boolean {
    return proto3.util.equals(ExchangeDataContent, a, b);
  }
}

/**
 * @generated from enum code.chat.v1.ExchangeDataContent.Verb
 */
export enum ExchangeDataContent_Verb {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: GAVE = 1;
   */
  GAVE = 1,

  /**
   * @generated from enum value: RECEIVED = 2;
   */
  RECEIVED = 2,

  /**
   * @generated from enum value: WITHDREW = 3;
   */
  WITHDREW = 3,

  /**
   * @generated from enum value: DEPOSITED = 4;
   */
  DEPOSITED = 4,

  /**
   * @generated from enum value: SENT = 5;
   */
  SENT = 5,

  /**
   * @generated from enum value: RETURNED = 6;
   */
  RETURNED = 6,

  /**
   * @generated from enum value: SPENT = 7;
   */
  SPENT = 7,

  /**
   * @generated from enum value: PAID = 8;
   */
  PAID = 8,

  /**
   * @generated from enum value: PURCHASED = 9;
   */
  PURCHASED = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(ExchangeDataContent_Verb)
proto3.util.setEnumType(ExchangeDataContent_Verb, "code.chat.v1.ExchangeDataContent.Verb", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "GAVE" },
  { no: 2, name: "RECEIVED" },
  { no: 3, name: "WITHDREW" },
  { no: 4, name: "DEPOSITED" },
  { no: 5, name: "SENT" },
  { no: 6, name: "RETURNED" },
  { no: 7, name: "SPENT" },
  { no: 8, name: "PAID" },
  { no: 9, name: "PURCHASED" },
]);

/**
 * @generated from message code.chat.v1.NaclBoxEncryptedContent
 */
export class NaclBoxEncryptedContent extends Message<NaclBoxEncryptedContent> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId peer_public_key = 1;
   */
  peerPublicKey?: SolanaAccountId;

  /**
   * @generated from field: bytes nonce = 2;
   */
  nonce = new Uint8Array(0);

  /**
   * @generated from field: bytes encrypted_payload = 3;
   */
  encryptedPayload = new Uint8Array(0);

  constructor(data?: PartialMessage<NaclBoxEncryptedContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.NaclBoxEncryptedContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "peer_public_key", kind: "message", T: SolanaAccountId },
    { no: 2, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "encrypted_payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NaclBoxEncryptedContent {
    return new NaclBoxEncryptedContent().fromJsonString(jsonString, options);
  }

  static equals(a: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined, b: NaclBoxEncryptedContent | PlainMessage<NaclBoxEncryptedContent> | undefined): boolean {
    return proto3.util.equals(NaclBoxEncryptedContent, a, b);
  }
}

/**
 * Opaque cursor used across paged APIs. Underlying bytes may change as paging
 * strategies evolve.
 *
 * @generated from message code.chat.v1.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.chat.v1.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

