// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file common/v1/model.proto (package code.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * AccountType associates a type to an account, which infers how an account is used
 * within the Code ecosystem.
 *
 * @generated from enum code.common.v1.AccountType
 */
export enum AccountType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: PRIMARY = 1;
   */
  PRIMARY = 1,

  /**
   * @generated from enum value: REMOTE_SEND_GIFT_CARD = 12;
   */
  REMOTE_SEND_GIFT_CARD = 12,

  /**
   * @generated from enum value: SWAP = 14;
   */
  SWAP = 14,

  /**
   * @generated from enum value: ASSOCIATED_TOKEN_ACCOUNT = 15;
   */
  ASSOCIATED_TOKEN_ACCOUNT = 15,

  /**
   * @generated from enum value: POOL = 16;
   */
  POOL = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(AccountType)
proto3.util.setEnumType(AccountType, "code.common.v1.AccountType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "PRIMARY" },
  { no: 12, name: "REMOTE_SEND_GIFT_CARD" },
  { no: 14, name: "SWAP" },
  { no: 15, name: "ASSOCIATED_TOKEN_ACCOUNT" },
  { no: 16, name: "POOL" },
]);

/**
 * SolanaAccountId is a raw binary Ed25519 public key for a Solana account
 *
 * @generated from message code.common.v1.SolanaAccountId
 */
export class SolanaAccountId extends Message<SolanaAccountId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SolanaAccountId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.SolanaAccountId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SolanaAccountId {
    return new SolanaAccountId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SolanaAccountId {
    return new SolanaAccountId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SolanaAccountId {
    return new SolanaAccountId().fromJsonString(jsonString, options);
  }

  static equals(a: SolanaAccountId | PlainMessage<SolanaAccountId> | undefined, b: SolanaAccountId | PlainMessage<SolanaAccountId> | undefined): boolean {
    return proto3.util.equals(SolanaAccountId, a, b);
  }
}

/**
 * A Solana address lookup table used in versioned transactions
 *
 * @generated from message code.common.v1.SolanaAddressLookupTable
 */
export class SolanaAddressLookupTable extends Message<SolanaAddressLookupTable> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId address = 1;
   */
  address?: SolanaAccountId;

  /**
   * @generated from field: repeated code.common.v1.SolanaAccountId entries = 2;
   */
  entries: SolanaAccountId[] = [];

  constructor(data?: PartialMessage<SolanaAddressLookupTable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.SolanaAddressLookupTable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: SolanaAccountId },
    { no: 2, name: "entries", kind: "message", T: SolanaAccountId, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SolanaAddressLookupTable {
    return new SolanaAddressLookupTable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SolanaAddressLookupTable {
    return new SolanaAddressLookupTable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SolanaAddressLookupTable {
    return new SolanaAddressLookupTable().fromJsonString(jsonString, options);
  }

  static equals(a: SolanaAddressLookupTable | PlainMessage<SolanaAddressLookupTable> | undefined, b: SolanaAddressLookupTable | PlainMessage<SolanaAddressLookupTable> | undefined): boolean {
    return proto3.util.equals(SolanaAddressLookupTable, a, b);
  }
}

/**
 * Transaction is a raw binary Solana transaction
 *
 * @generated from message code.common.v1.Transaction
 */
export class Transaction extends Message<Transaction> {
  /**
   * Maximum size taken from: https://github.com/solana-labs/solana/blob/39b3ac6a8d29e14faa1de73d8b46d390ad41797b/sdk/src/packet.rs#L9-L13
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Transaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Transaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transaction {
    return new Transaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJsonString(jsonString, options);
  }

  static equals(a: Transaction | PlainMessage<Transaction> | undefined, b: Transaction | PlainMessage<Transaction> | undefined): boolean {
    return proto3.util.equals(Transaction, a, b);
  }
}

/**
 * Blockhash is a raw binary Solana blockchash
 *
 * @generated from message code.common.v1.Blockhash
 */
export class Blockhash extends Message<Blockhash> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Blockhash>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Blockhash";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Blockhash {
    return new Blockhash().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Blockhash {
    return new Blockhash().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Blockhash {
    return new Blockhash().fromJsonString(jsonString, options);
  }

  static equals(a: Blockhash | PlainMessage<Blockhash> | undefined, b: Blockhash | PlainMessage<Blockhash> | undefined): boolean {
    return proto3.util.equals(Blockhash, a, b);
  }
}

/**
 * Signature is a raw binary Ed25519 signature
 *
 * @generated from message code.common.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * IntentId is a client-side generated ID that maps to an intent to perform actions
 * on the blockchain fulfilled by the Code sequencer.
 *
 * @generated from message code.common.v1.IntentId
 */
export class IntentId extends Message<IntentId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<IntentId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.IntentId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntentId {
    return new IntentId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntentId {
    return new IntentId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntentId {
    return new IntentId().fromJsonString(jsonString, options);
  }

  static equals(a: IntentId | PlainMessage<IntentId> | undefined, b: IntentId | PlainMessage<IntentId> | undefined): boolean {
    return proto3.util.equals(IntentId, a, b);
  }
}

/**
 * Hash is a raw binary 32 byte hash value
 *
 * @generated from message code.common.v1.Hash
 */
export class Hash extends Message<Hash> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Hash>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Hash";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hash {
    return new Hash().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hash {
    return new Hash().fromJsonString(jsonString, options);
  }

  static equals(a: Hash | PlainMessage<Hash> | undefined, b: Hash | PlainMessage<Hash> | undefined): boolean {
    return proto3.util.equals(Hash, a, b);
  }
}

/**
 * UUID is a 16 byte UUID value
 *
 * @generated from message code.common.v1.UUID
 */
export class UUID extends Message<UUID> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<UUID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.UUID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UUID {
    return new UUID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UUID {
    return new UUID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UUID {
    return new UUID().fromJsonString(jsonString, options);
  }

  static equals(a: UUID | PlainMessage<UUID> | undefined, b: UUID | PlainMessage<UUID> | undefined): boolean {
    return proto3.util.equals(UUID, a, b);
  }
}

/**
 * Request is a generic wrapper for gRPC requests
 *
 * @generated from message code.common.v1.Request
 */
export class Request extends Message<Request> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string service = 2;
   */
  service = "";

  /**
   * @generated from field: string method = 3;
   */
  method = "";

  /**
   * @generated from field: bytes body = 4;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * Response is a generic wrapper for gRPC responses
 *
 * @generated from message code.common.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: code.common.v1.Response.Result result = 1;
   */
  result = Response_Result.OK;

  /**
   * @generated from field: bytes body = 2;
   */
  body = new Uint8Array(0);

  /**
   * @generated from field: string message = 3;
   */
  message = "";

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(Response_Result) },
    { no: 2, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from enum code.common.v1.Response.Result
 */
export enum Response_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: ERROR = 1;
   */
  ERROR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Response_Result)
proto3.util.setEnumType(Response_Result, "code.common.v1.Response.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "ERROR" },
]);

/**
 * @generated from message code.common.v1.ServerPing
 */
export class ServerPing extends Message<ServerPing> {
  /**
   * Timestamp the ping was sent on the stream, for client to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The delay server will apply before sending the next ping
   *
   * @generated from field: google.protobuf.Duration ping_delay = 2;
   */
  pingDelay?: Duration;

  constructor(data?: PartialMessage<ServerPing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.ServerPing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "ping_delay", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerPing {
    return new ServerPing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJsonString(jsonString, options);
  }

  static equals(a: ServerPing | PlainMessage<ServerPing> | undefined, b: ServerPing | PlainMessage<ServerPing> | undefined): boolean {
    return proto3.util.equals(ServerPing, a, b);
  }
}

/**
 * @generated from message code.common.v1.ClientPong
 */
export class ClientPong extends Message<ClientPong> {
  /**
   * Timestamp the Pong was sent on the stream, for server to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ClientPong>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.common.v1.ClientPong";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientPong {
    return new ClientPong().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJsonString(jsonString, options);
  }

  static equals(a: ClientPong | PlainMessage<ClientPong> | undefined, b: ClientPong | PlainMessage<ClientPong> | undefined): boolean {
    return proto3.util.equals(ClientPong, a, b);
  }
}

