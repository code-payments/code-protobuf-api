// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file transaction/v2/transaction_service.proto (package code.transaction.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccountType, Blockhash, Hash, InstructionAccount, IntentId, Signature, SolanaAccountId, Transaction, UUID } from "../../common/v1/model_pb";

/**
 * @generated from enum code.transaction.v2.AirdropType
 */
export enum AirdropType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Reward for giving someone else their first crypto
   *
   * @generated from enum value: GIVE_FIRST_CRYPTO = 1;
   */
  GIVE_FIRST_CRYPTO = 1,

  /**
   * Airdrop for getting a user started with first crypto balance
   *
   * @generated from enum value: GET_FIRST_CRYPTO = 2;
   */
  GET_FIRST_CRYPTO = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropType)
proto3.util.setEnumType(AirdropType, "code.transaction.v2.AirdropType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "GIVE_FIRST_CRYPTO" },
  { no: 2, name: "GET_FIRST_CRYPTO" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest
 */
export class SubmitIntentRequest extends Message<SubmitIntentRequest> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitActions submit_actions = 1;
     */
    value: SubmitIntentRequest_SubmitActions;
    case: "submitActions";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitSignatures submit_signatures = 2;
     */
    value: SubmitIntentRequest_SubmitSignatures;
    case: "submitSignatures";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "submit_actions", kind: "message", T: SubmitIntentRequest_SubmitActions, oneof: "request" },
    { no: 2, name: "submit_signatures", kind: "message", T: SubmitIntentRequest_SubmitSignatures, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined, b: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitActions
 */
export class SubmitIntentRequest_SubmitActions extends Message<SubmitIntentRequest_SubmitActions> {
  /**
   * The globally unique client generated intent ID. Use the original intent
   * ID when operating on actions that mutate the intent.
   *
   * @generated from field: code.common.v1.IntentId id = 1;
   */
  id?: IntentId;

  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * Additional metadata that describes the high-level intention
   *
   * @generated from field: code.transaction.v2.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * The set of all ordered actions required to fulfill the intent
   *
   * @generated from field: repeated code.transaction.v2.Action actions = 4;
   */
  actions: Action[] = [];

  /**
   * The signature is of serialize(SubmitActions) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitActions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitActions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
    { no: 4, name: "actions", kind: "message", T: Action, repeated: true },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined, b: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitActions, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitSignatures
 */
export class SubmitIntentRequest_SubmitSignatures extends Message<SubmitIntentRequest_SubmitSignatures> {
  /**
   * The set of all signatures for each transaction or virtual instruction requiring
   * signature from the authority accounts.
   *
   * The signature for a transaction is for the marshalled transaction.
   * The signature for a virtual instruction is the hash of the marshalled instruction.
   *
   * @generated from field: repeated code.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined, b: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitSignatures, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse
 */
export class SubmitIntentResponse extends Message<SubmitIntentResponse> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.ServerParameters server_parameters = 1;
     */
    value: SubmitIntentResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Success success = 2;
     */
    value: SubmitIntentResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Error error = 3;
     */
    value: SubmitIntentResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SubmitIntentResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SubmitIntentResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SubmitIntentResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined, b: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.ServerParameters
 */
export class SubmitIntentResponse_ServerParameters extends Message<SubmitIntentResponse_ServerParameters> {
  /**
   * The set of all server paremeters required to fill missing transaction
   * or virtual instruction details. Server guarantees to provide a message
   * for each client action in an order consistent with the received action
   * list. 
   *
   * @generated from field: repeated code.transaction.v2.ServerParameter server_parameters = 1;
   */
  serverParameters: ServerParameter[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: ServerParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined, b: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Success
 */
export class SubmitIntentResponse_Success extends Message<SubmitIntentResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Success.Code code = 1;
   */
  code = SubmitIntentResponse_Success_Code.OK;

  constructor(data?: PartialMessage<SubmitIntentResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined, b: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Success.Code
 */
export enum SubmitIntentResponse_Success_Code {
  /**
   * The intent was successfully created and is now scheduled.
   *
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Success_Code)
proto3.util.setEnumType(SubmitIntentResponse_Success_Code, "code.transaction.v2.SubmitIntentResponse.Success.Code", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Error
 */
export class SubmitIntentResponse_Error extends Message<SubmitIntentResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Error.Code code = 1;
   */
  code = SubmitIntentResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined, b: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Error.Code
 */
export enum SubmitIntentResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * The intent is invalid.
   *
   * @generated from enum value: INVALID_INTENT = 1;
   */
  INVALID_INTENT = 1,

  /**
   * There is an issue with provided signatures.
   *
   * @generated from enum value: SIGNATURE_ERROR = 2;
   */
  SIGNATURE_ERROR = 2,

  /**
   * Server detected client has stale state.
   *
   * @generated from enum value: STALE_STATE = 3;
   */
  STALE_STATE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Error_Code)
proto3.util.setEnumType(SubmitIntentResponse_Error_Code, "code.transaction.v2.SubmitIntentResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "INVALID_INTENT" },
  { no: 2, name: "SIGNATURE_ERROR" },
  { no: 3, name: "STALE_STATE" },
]);

/**
 * @generated from message code.transaction.v2.GetIntentMetadataRequest
 */
export class GetIntentMetadataRequest extends Message<GetIntentMetadataRequest> {
  /**
   * The intent ID to query
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The verified owner account public key when not signing with the rendezvous
   * key. Only owner accounts involved in the intent can access the metadata.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetIntentStatusRequest) without this field set
   * using the private key of the rendezvous or owner account. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetIntentMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined, b: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetIntentMetadataResponse
 */
export class GetIntentMetadataResponse extends Message<GetIntentMetadataResponse> {
  /**
   * @generated from field: code.transaction.v2.GetIntentMetadataResponse.Result result = 1;
   */
  result = GetIntentMetadataResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<GetIntentMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetIntentMetadataResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined, b: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetIntentMetadataResponse.Result
 */
export enum GetIntentMetadataResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetIntentMetadataResponse_Result)
proto3.util.setEnumType(GetIntentMetadataResponse_Result, "code.transaction.v2.GetIntentMetadataResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.GetLimitsRequest
 */
export class GetLimitsRequest extends Message<GetLimitsRequest> {
  /**
   * The owner account whose limits will be calculated. Any other owner accounts
   * linked with the same identity of the owner will also be applied.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetLimitsRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * All transactions starting at this time will be incorporated into the consumed
   * limit calculation. Clients should set this to the start of the current day in
   * the client's current time zone (because server has no knowledge of this atm).
   *
   * @generated from field: google.protobuf.Timestamp consumed_since = 3;
   */
  consumedSince?: Timestamp;

  constructor(data?: PartialMessage<GetLimitsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "consumed_since", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined, b: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined): boolean {
    return proto3.util.equals(GetLimitsRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetLimitsResponse
 */
export class GetLimitsResponse extends Message<GetLimitsResponse> {
  /**
   * @generated from field: code.transaction.v2.GetLimitsResponse.Result result = 1;
   */
  result = GetLimitsResponse_Result.OK;

  /**
   * Send limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.SendLimit> send_limits_by_currency = 2;
   */
  sendLimitsByCurrency: { [key: string]: SendLimit } = {};

  /**
   * Micro payment limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.MicroPaymentLimit> micro_payment_limits_by_currency = 4;
   */
  microPaymentLimitsByCurrency: { [key: string]: MicroPaymentLimit } = {};

  /**
   * Buy module limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.BuyModuleLimit> buy_module_limits_by_currency = 5;
   */
  buyModuleLimitsByCurrency: { [key: string]: BuyModuleLimit } = {};

  constructor(data?: PartialMessage<GetLimitsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetLimitsResponse_Result) },
    { no: 2, name: "send_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SendLimit} },
    { no: 4, name: "micro_payment_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: MicroPaymentLimit} },
    { no: 5, name: "buy_module_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: BuyModuleLimit} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined, b: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined): boolean {
    return proto3.util.equals(GetLimitsResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetLimitsResponse.Result
 */
export enum GetLimitsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetLimitsResponse_Result)
proto3.util.setEnumType(GetLimitsResponse_Result, "code.transaction.v2.GetLimitsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountRequest
 */
export class CanWithdrawToAccountRequest extends Message<CanWithdrawToAccountRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId account = 1;
   */
  account?: SolanaAccountId;

  constructor(data?: PartialMessage<CanWithdrawToAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined, b: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountResponse
 */
export class CanWithdrawToAccountResponse extends Message<CanWithdrawToAccountResponse> {
  /**
   * Metadata so the client knows how to withdraw to the account. Server cannot
   * provide precalculated addresses in this response to maintain non-custodial
   * status.
   *
   * @generated from field: code.transaction.v2.CanWithdrawToAccountResponse.AccountType account_type = 2;
   */
  accountType = CanWithdrawToAccountResponse_AccountType.Unknown;

  /**
   * Server-controlled flag to indicate if the account can be withdrawn to.
   * There are several reasons server may deny it, including:
   *  - Wrong type of Code account
   *  - Not wanting to subsidize the creation of an ATA
   *  - Unsupported external account type (eg. token account but of the wrong mint)
   * This is guaranteed to be false when account_type = Unknown.
   *
   * @generated from field: bool is_valid_payment_destination = 1;
   */
  isValidPaymentDestination = false;

  /**
   * Token account requires initialization before the withdrawal can occur.
   * Server has chosen not to subsidize the fees. The response is guaranteed
   * to have set is_valid_payment_destination = false in this case.
   *
   * @generated from field: bool requires_initialization = 3;
   */
  requiresInitialization = false;

  constructor(data?: PartialMessage<CanWithdrawToAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "account_type", kind: "enum", T: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType) },
    { no: 1, name: "is_valid_payment_destination", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "requires_initialization", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined, b: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.CanWithdrawToAccountResponse.AccountType
 */
export enum CanWithdrawToAccountResponse_AccountType {
  /**
   * Server cannot determine
   *
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * Client uses the address as is in SubmitIntent
   *
   * @generated from enum value: TokenAccount = 1;
   */
  TokenAccount = 1,

  /**
   * Client locally derives the ATA to use in SubmitIntent
   *
   * @generated from enum value: OwnerAccount = 2;
   */
  OwnerAccount = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType)
proto3.util.setEnumType(CanWithdrawToAccountResponse_AccountType, "code.transaction.v2.CanWithdrawToAccountResponse.AccountType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "TokenAccount" },
  { no: 2, name: "OwnerAccount" },
]);

/**
 * @generated from message code.transaction.v2.AirdropRequest
 */
export class AirdropRequest extends Message<AirdropRequest> {
  /**
   * The type of airdrop to claim
   *
   * @generated from field: code.transaction.v2.AirdropType airdrop_type = 1;
   */
  airdropType = AirdropType.UNKNOWN;

  /**
   * The owner account to airdrop core mint tokens to
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(AirdropRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AirdropRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "airdrop_type", kind: "enum", T: proto3.getEnumType(AirdropType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropRequest {
    return new AirdropRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropRequest | PlainMessage<AirdropRequest> | undefined, b: AirdropRequest | PlainMessage<AirdropRequest> | undefined): boolean {
    return proto3.util.equals(AirdropRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.AirdropResponse
 */
export class AirdropResponse extends Message<AirdropResponse> {
  /**
   * @generated from field: code.transaction.v2.AirdropResponse.Result result = 1;
   */
  result = AirdropResponse_Result.OK;

  /**
   * Exchange data for the amount of core mint tokens airdropped when successful
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<AirdropResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AirdropResponse_Result) },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropResponse {
    return new AirdropResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropResponse | PlainMessage<AirdropResponse> | undefined, b: AirdropResponse | PlainMessage<AirdropResponse> | undefined): boolean {
    return proto3.util.equals(AirdropResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.AirdropResponse.Result
 */
export enum AirdropResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * Airdrops are unavailable
   *
   * @generated from enum value: UNAVAILABLE = 1;
   */
  UNAVAILABLE = 1,

  /**
   * The airdrop has already been claimed by the owner
   *
   * @generated from enum value: ALREADY_CLAIMED = 2;
   */
  ALREADY_CLAIMED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropResponse_Result)
proto3.util.setEnumType(AirdropResponse_Result, "code.transaction.v2.AirdropResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "UNAVAILABLE" },
  { no: 2, name: "ALREADY_CLAIMED" },
]);

/**
 * @generated from message code.transaction.v2.SwapRequest
 */
export class SwapRequest extends Message<SwapRequest> {
  /**
   * @generated from oneof code.transaction.v2.SwapRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.Initiate initiate = 1;
     */
    value: SwapRequest_Initiate;
    case: "initiate";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.SubmitSignature submit_signature = 2;
     */
    value: SwapRequest_SubmitSignature;
    case: "submitSignature";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "initiate", kind: "message", T: SwapRequest_Initiate, oneof: "request" },
    { no: 2, name: "submit_signature", kind: "message", T: SwapRequest_SubmitSignature, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest {
    return new SwapRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest {
    return new SwapRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest {
    return new SwapRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest | PlainMessage<SwapRequest> | undefined, b: SwapRequest | PlainMessage<SwapRequest> | undefined): boolean {
    return proto3.util.equals(SwapRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.Initiate
 */
export class SwapRequest_Initiate extends Message<SwapRequest_Initiate> {
  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The user authority account that will sign to authorize the swap. Ideally,
   * this is an account derived off the owner account that is solely responsible
   * for swapping.
   *
   * @generated from field: code.common.v1.SolanaAccountId swap_authority = 2;
   */
  swapAuthority?: SolanaAccountId;

  /**
   * Maximum amount to swap from the source mint, in quarks. If value is set to zero,
   * the entire amount will be swapped.
   *
   * @generated from field: uint64 limit = 3;
   */
  limit = protoInt64.zero;

  /**
   * Whether the client wants the RPC to wait for blockchain status. If false,
   * then the RPC will return Success when the swap is submitted to the blockchain.
   * Otherwise, the RPC will observe and report back the status of the transaction.
   *
   * @generated from field: bool wait_for_blockchain_status = 4;
   */
  waitForBlockchainStatus = false;

  /**
   * The signature is of serialize(Initiate) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SwapRequest_Initiate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.Initiate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "swap_authority", kind: "message", T: SolanaAccountId },
    { no: 3, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "wait_for_blockchain_status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_Initiate | PlainMessage<SwapRequest_Initiate> | undefined, b: SwapRequest_Initiate | PlainMessage<SwapRequest_Initiate> | undefined): boolean {
    return proto3.util.equals(SwapRequest_Initiate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.SubmitSignature
 */
export class SwapRequest_SubmitSignature extends Message<SwapRequest_SubmitSignature> {
  /**
   * The signature for the locally constructed swap transaction
   *
   * @generated from field: code.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SwapRequest_SubmitSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.SubmitSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_SubmitSignature {
    return new SwapRequest_SubmitSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_SubmitSignature {
    return new SwapRequest_SubmitSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_SubmitSignature {
    return new SwapRequest_SubmitSignature().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_SubmitSignature | PlainMessage<SwapRequest_SubmitSignature> | undefined, b: SwapRequest_SubmitSignature | PlainMessage<SwapRequest_SubmitSignature> | undefined): boolean {
    return proto3.util.equals(SwapRequest_SubmitSignature, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse
 */
export class SwapResponse extends Message<SwapResponse> {
  /**
   * @generated from oneof code.transaction.v2.SwapResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.ServerParameters server_parameters = 1;
     */
    value: SwapResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.Success success = 2;
     */
    value: SwapResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.Error error = 3;
     */
    value: SwapResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SwapResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SwapResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SwapResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse {
    return new SwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse {
    return new SwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse {
    return new SwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse | PlainMessage<SwapResponse> | undefined, b: SwapResponse | PlainMessage<SwapResponse> | undefined): boolean {
    return proto3.util.equals(SwapResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse.ServerParameters
 */
export class SwapResponse_ServerParameters extends Message<SwapResponse_ServerParameters> {
  /**
   * Subisdizer account that will be paying for the swap
   *
   * @generated from field: code.common.v1.SolanaAccountId payer = 1;
   */
  payer?: SolanaAccountId;

  /**
   * Recent blockhash
   *
   * @generated from field: code.common.v1.Blockhash recent_blockhash = 2;
   */
  recentBlockhash?: Blockhash;

  /**
   * Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint32 compute_unit_limit = 3;
   */
  computeUnitLimit = 0;

  /**
   * Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint64 compute_unit_price = 4;
   */
  computeUnitPrice = protoInt64.zero;

  /**
   * On-chain program that will be performing the swap
   *
   * @generated from field: code.common.v1.SolanaAccountId swap_program = 5;
   */
  swapProgram?: SolanaAccountId;

  /**
   * Accounts provided to the swap instruction
   *
   * @generated from field: repeated code.common.v1.InstructionAccount swap_ixn_accounts = 6;
   */
  swapIxnAccounts: InstructionAccount[] = [];

  /**
   * Instruction data for the swap instruction
   *
   * @generated from field: bytes swap_ixn_data = 7;
   */
  swapIxnData = new Uint8Array(0);

  /**
   * Maximum quarks that will be sent out of the source account after
   * executing the swap. If not, the validation instruction will cause
   * the transaction to fail.
   *
   * @generated from field: uint64 max_to_send = 8;
   */
  maxToSend = protoInt64.zero;

  /**
   * Minimum quarks that will be received into the destination account
   * after executing the swap. If not, the validation instruction will
   * cause the transaction to fail.
   *
   * @generated from field: uint64 min_to_receive = 9;
   */
  minToReceive = protoInt64.zero;

  /**
   * Nonce to use in swap validator state account PDA
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 10;
   */
  nonce?: SolanaAccountId;

  constructor(data?: PartialMessage<SwapResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payer", kind: "message", T: SolanaAccountId },
    { no: 2, name: "recent_blockhash", kind: "message", T: Blockhash },
    { no: 3, name: "compute_unit_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "compute_unit_price", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "swap_program", kind: "message", T: SolanaAccountId },
    { no: 6, name: "swap_ixn_accounts", kind: "message", T: InstructionAccount, repeated: true },
    { no: 7, name: "swap_ixn_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "max_to_send", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "min_to_receive", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "nonce", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_ServerParameters | PlainMessage<SwapResponse_ServerParameters> | undefined, b: SwapResponse_ServerParameters | PlainMessage<SwapResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SwapResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse.Success
 */
export class SwapResponse_Success extends Message<SwapResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SwapResponse.Success.Code code = 1;
   */
  code = SwapResponse_Success_Code.SWAP_SUBMITTED;

  constructor(data?: PartialMessage<SwapResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SwapResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_Success | PlainMessage<SwapResponse_Success> | undefined, b: SwapResponse_Success | PlainMessage<SwapResponse_Success> | undefined): boolean {
    return proto3.util.equals(SwapResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SwapResponse.Success.Code
 */
export enum SwapResponse_Success_Code {
  /**
   * The swap was submitted to the blockchain.
   *
   * @generated from enum value: SWAP_SUBMITTED = 0;
   */
  SWAP_SUBMITTED = 0,

  /**
   * The swap was finalized on the blockchain.
   *
   * @generated from enum value: SWAP_FINALIZED = 1;
   */
  SWAP_FINALIZED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SwapResponse_Success_Code)
proto3.util.setEnumType(SwapResponse_Success_Code, "code.transaction.v2.SwapResponse.Success.Code", [
  { no: 0, name: "SWAP_SUBMITTED" },
  { no: 1, name: "SWAP_FINALIZED" },
]);

/**
 * @generated from message code.transaction.v2.SwapResponse.Error
 */
export class SwapResponse_Error extends Message<SwapResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SwapResponse.Error.Code code = 1;
   */
  code = SwapResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SwapResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SwapResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_Error | PlainMessage<SwapResponse_Error> | undefined, b: SwapResponse_Error | PlainMessage<SwapResponse_Error> | undefined): boolean {
    return proto3.util.equals(SwapResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SwapResponse.Error.Code
 */
export enum SwapResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * There is an issue with the provided signature.
   *
   * @generated from enum value: SIGNATURE_ERROR = 2;
   */
  SIGNATURE_ERROR = 2,

  /**
   * The swap failed server-side validation
   *
   * @generated from enum value: INVALID_SWAP = 3;
   */
  INVALID_SWAP = 3,

  /**
   * The submitted swap transaction failed. Attempt the swap again.
   *
   * @generated from enum value: SWAP_FAILED = 4;
   */
  SWAP_FAILED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SwapResponse_Error_Code)
proto3.util.setEnumType(SwapResponse_Error_Code, "code.transaction.v2.SwapResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 2, name: "SIGNATURE_ERROR" },
  { no: 3, name: "INVALID_SWAP" },
  { no: 4, name: "SWAP_FAILED" },
]);

/**
 * @generated from message code.transaction.v2.DeclareFiatOnrampPurchaseAttemptRequest
 */
export class DeclareFiatOnrampPurchaseAttemptRequest extends Message<DeclareFiatOnrampPurchaseAttemptRequest> {
  /**
   * The owner account invoking the buy module
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The amount being purchased
   *
   * @generated from field: code.transaction.v2.ExchangeDataWithoutRate purchase_amount = 2;
   */
  purchaseAmount?: ExchangeDataWithoutRate;

  /**
   * A nonce value unique to the purchase. If it's included in a memo for the
   * transaction for the deposit to the owner, then purchase_amount will be used
   * for display values. Otherwise, the amount will be inferred from the transaction.
   *
   * @generated from field: code.common.v1.UUID nonce = 3;
   */
  nonce?: UUID;

  /**
   * The signature is of serialize(DeclareFiatOnrampPurchaseAttemptRequest) without
   * this field set using the private key of the owner account. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<DeclareFiatOnrampPurchaseAttemptRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DeclareFiatOnrampPurchaseAttemptRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "purchase_amount", kind: "message", T: ExchangeDataWithoutRate },
    { no: 3, name: "nonce", kind: "message", T: UUID },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeclareFiatOnrampPurchaseAttemptRequest {
    return new DeclareFiatOnrampPurchaseAttemptRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeclareFiatOnrampPurchaseAttemptRequest {
    return new DeclareFiatOnrampPurchaseAttemptRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeclareFiatOnrampPurchaseAttemptRequest {
    return new DeclareFiatOnrampPurchaseAttemptRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeclareFiatOnrampPurchaseAttemptRequest | PlainMessage<DeclareFiatOnrampPurchaseAttemptRequest> | undefined, b: DeclareFiatOnrampPurchaseAttemptRequest | PlainMessage<DeclareFiatOnrampPurchaseAttemptRequest> | undefined): boolean {
    return proto3.util.equals(DeclareFiatOnrampPurchaseAttemptRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.DeclareFiatOnrampPurchaseAttemptResponse
 */
export class DeclareFiatOnrampPurchaseAttemptResponse extends Message<DeclareFiatOnrampPurchaseAttemptResponse> {
  /**
   * @generated from field: code.transaction.v2.DeclareFiatOnrampPurchaseAttemptResponse.Result result = 1;
   */
  result = DeclareFiatOnrampPurchaseAttemptResponse_Result.OK;

  constructor(data?: PartialMessage<DeclareFiatOnrampPurchaseAttemptResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DeclareFiatOnrampPurchaseAttemptResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(DeclareFiatOnrampPurchaseAttemptResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeclareFiatOnrampPurchaseAttemptResponse {
    return new DeclareFiatOnrampPurchaseAttemptResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeclareFiatOnrampPurchaseAttemptResponse {
    return new DeclareFiatOnrampPurchaseAttemptResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeclareFiatOnrampPurchaseAttemptResponse {
    return new DeclareFiatOnrampPurchaseAttemptResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeclareFiatOnrampPurchaseAttemptResponse | PlainMessage<DeclareFiatOnrampPurchaseAttemptResponse> | undefined, b: DeclareFiatOnrampPurchaseAttemptResponse | PlainMessage<DeclareFiatOnrampPurchaseAttemptResponse> | undefined): boolean {
    return proto3.util.equals(DeclareFiatOnrampPurchaseAttemptResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.DeclareFiatOnrampPurchaseAttemptResponse.Result
 */
export enum DeclareFiatOnrampPurchaseAttemptResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The owner account is not valid (ie. it isn't a Code account)
   *
   * @generated from enum value: INVALID_OWNER = 1;
   */
  INVALID_OWNER = 1,

  /**
   * The currency isn't supported
   *
   * @generated from enum value: UNSUPPORTED_CURRENCY = 2;
   */
  UNSUPPORTED_CURRENCY = 2,

  /**
   * The amount specified exceeds limits
   *
   * @generated from enum value: AMOUNT_EXCEEDS_MAXIMUM = 3;
   */
  AMOUNT_EXCEEDS_MAXIMUM = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(DeclareFiatOnrampPurchaseAttemptResponse_Result)
proto3.util.setEnumType(DeclareFiatOnrampPurchaseAttemptResponse_Result, "code.transaction.v2.DeclareFiatOnrampPurchaseAttemptResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "INVALID_OWNER" },
  { no: 2, name: "UNSUPPORTED_CURRENCY" },
  { no: 3, name: "AMOUNT_EXCEEDS_MAXIMUM" },
]);

/**
 * @generated from message code.transaction.v2.VoidGiftCardRequest
 */
export class VoidGiftCardRequest extends Message<VoidGiftCardRequest> {
  /**
   * The owner account that issued the gift card account
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The vault of the gift card account to void
   *
   * @generated from field: code.common.v1.SolanaAccountId gift_card_vault = 2;
   */
  giftCardVault?: SolanaAccountId;

  /**
   * The signature is of serialize(VoidGiftCardRequest) without this field set using
   * the private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<VoidGiftCardRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "gift_card_vault", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined, b: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.VoidGiftCardResponse
 */
export class VoidGiftCardResponse extends Message<VoidGiftCardResponse> {
  /**
   * @generated from field: code.transaction.v2.VoidGiftCardResponse.Result result = 1;
   */
  result = VoidGiftCardResponse_Result.OK;

  constructor(data?: PartialMessage<VoidGiftCardResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(VoidGiftCardResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined, b: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.VoidGiftCardResponse.Result
 */
export enum VoidGiftCardResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The owner account didn't issue the gift card accoun
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * A different owner account than the issuer claimed the gift card
   *
   * @generated from enum value: CLAIMED_BY_OTHER_USER = 2;
   */
  CLAIMED_BY_OTHER_USER = 2,

  /**
   * The gift card doesn't exist
   *
   * @generated from enum value: NOT_FOUND = 3;
   */
  NOT_FOUND = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(VoidGiftCardResponse_Result)
proto3.util.setEnumType(VoidGiftCardResponse_Result, "code.transaction.v2.VoidGiftCardResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CLAIMED_BY_OTHER_USER" },
  { no: 3, name: "NOT_FOUND" },
]);

/**
 * Metadata describes the high-level details of an intent
 *
 * @generated from message code.transaction.v2.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from oneof code.transaction.v2.Metadata.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountsMetadata open_accounts = 1;
     */
    value: OpenAccountsMetadata;
    case: "openAccounts";
  } | {
    /**
     * @generated from field: code.transaction.v2.SendPublicPaymentMetadata send_public_payment = 6;
     */
    value: SendPublicPaymentMetadata;
    case: "sendPublicPayment";
  } | {
    /**
     * @generated from field: code.transaction.v2.ReceivePaymentsPubliclyMetadata receive_payments_publicly = 7;
     */
    value: ReceivePaymentsPubliclyMetadata;
    case: "receivePaymentsPublicly";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_accounts", kind: "message", T: OpenAccountsMetadata, oneof: "type" },
    { no: 6, name: "send_public_payment", kind: "message", T: SendPublicPaymentMetadata, oneof: "type" },
    { no: 7, name: "receive_payments_publicly", kind: "message", T: ReceivePaymentsPubliclyMetadata, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * Open a set of accounts. Currently, clients should only use this for new users
 * to open all required accounts up front..
 *
 * Action Spec:
 *
 * for account in [PRIMARY]
 *   actions.push_back(OpenAccountAction(account))
 *
 * Nothing is currently required
 *
 * @generated from message code.transaction.v2.OpenAccountsMetadata
 */
export class OpenAccountsMetadata extends Message<OpenAccountsMetadata> {
  constructor(data?: PartialMessage<OpenAccountsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined, b: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined): boolean {
    return proto3.util.equals(OpenAccountsMetadata, a, b);
  }
}

/**
 * Send a payment to a destination account publicly.
 *
 * Action Spec (Payment, Withdrawal):
 *
 * actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
 *
 * Action Spec (Remote Send):
 *
 * actions = [
 *   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
 *   NoPrivacyTransferAction(PRIMARY, REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
 *   NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, ExchangeData.Quarks, is_auto_return=true),
 * ]
 *
 * todo: Possibly use a different action type for deferred closing?
 *
 * @generated from message code.transaction.v2.SendPublicPaymentMetadata
 */
export class SendPublicPaymentMetadata extends Message<SendPublicPaymentMetadata> {
  /**
   * The primary account where funds will be sent from. The primary account is assumed if this
   * field is not set for backwards compatibility with old clients.
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 4;
   */
  source?: SolanaAccountId;

  /**
   * The destination token account to send funds to.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * The exchange data of total funds being sent to the destination
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is the payment a withdrawal?
   *
   * @generated from field: bool is_withdrawal = 3;
   */
  isWithdrawal = false;

  /**
   * Is the payment going to a new gift card? Note is_withdrawal must be false.
   *
   * @generated from field: bool is_remote_send = 5;
   */
  isRemoteSend = false;

  constructor(data?: PartialMessage<SendPublicPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendPublicPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "source", kind: "message", T: SolanaAccountId },
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "is_withdrawal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined, b: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(SendPublicPaymentMetadata, a, b);
  }
}

/**
 * Receive funds into a user-owned account publicly. All use cases of this intent
 * close the account, so all funds must be moved.
 *
 * Action Spec (Remote Send):
 *
 * actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, quarks)]
 *
 * @generated from message code.transaction.v2.ReceivePaymentsPubliclyMetadata
 */
export class ReceivePaymentsPubliclyMetadata extends Message<ReceivePaymentsPubliclyMetadata> {
  /**
   * The remote send gift card to receive funds from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The exact amount of core mint quarks being received
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  /**
   * Is the receipt of funds from a remote send gift card? Currently, this is
   * the only use case for this intent and validation enforces the flag to true.
   *
   * @generated from field: bool is_remote_send = 3;
   */
  isRemoteSend = false;

  /**
   * If is_remote_send is true, is the gift card being voided? The user owner
   * account's 12 words that issued the gift card may only set this flag to true.
   * Functionally, this doesn't affect the intent, but rather if we decide to show
   * it in a user-friendly payment history.
   *
   * @generated from field: bool is_issuer_voiding_gift_card = 4;
   */
  isIssuerVoidingGiftCard = false;

  /**
   * If is_remote_send is true, the original exchange data that was provided as
   * part of creating the gift card account. This is purely a server-provided value.
   * SubmitIntent will disallow this being set.
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 5;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<ReceivePaymentsPubliclyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReceivePaymentsPubliclyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "is_issuer_voiding_gift_card", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined, b: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined): boolean {
    return proto3.util.equals(ReceivePaymentsPubliclyMetadata, a, b);
  }
}

/**
 * Action is a well-defined, ordered and small set of transactions or virtual instructions
 * for a unit of work that the client wants to perform on the blockchain. Clients provide
 * parameters known to them in the action.
 *
 * @generated from message code.transaction.v2.Action
 */
export class Action extends Message<Action> {
  /**
   * The ID of this action, which is unique within an intent. It must match
   * the index of the action's location in the SubmitAction's actions field.
   *
   * @generated from field: uint32 id = 1;
   */
  id = 0;

  /**
   * The type of action to perform.
   *
   * @generated from oneof code.transaction.v2.Action.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountAction open_account = 2;
     */
    value: OpenAccountAction;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferAction no_privacy_transfer = 5;
     */
    value: NoPrivacyTransferAction;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawAction no_privacy_withdraw = 6;
     */
    value: NoPrivacyWithdrawAction;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentAction fee_payment = 10;
     */
    value: FeePaymentAction;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "open_account", kind: "message", T: OpenAccountAction, oneof: "type" },
    { no: 5, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferAction, oneof: "type" },
    { no: 6, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawAction, oneof: "type" },
    { no: 10, name: "fee_payment", kind: "message", T: FeePaymentAction, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * No client signature required
 *
 * @generated from message code.transaction.v2.OpenAccountAction
 */
export class OpenAccountAction extends Message<OpenAccountAction> {
  /**
   * The type of account, which will dictate its intended use
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The owner of the account. For accounts liked to a user's 12 words, this is
   * the verified parent owner account public key. All other account types should
   * set this to the authority value.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The index used to for accounts that are derived from owner
   *
   * @generated from field: uint64 index = 3;
   */
  index = protoInt64.zero;

  /**
   * The public key of the private key that has authority over the opened token account
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 4;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being opened
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 5;
   */
  token?: SolanaAccountId;

  /**
   * The signature is of serialize(OpenAccountAction) without this field set
   * using the private key of the authority account. This provides a proof
   * of authorization to link authority to owner.
   *
   * @generated from field: code.common.v1.Signature authority_signature = 6;
   */
  authoritySignature?: Signature;

  constructor(data?: PartialMessage<OpenAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 5, name: "token", kind: "message", T: SolanaAccountId },
    { no: 6, name: "authority_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined, b: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined): boolean {
    return proto3.util.equals(OpenAccountAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferAction
 */
export class NoPrivacyTransferAction extends Message<NoPrivacyTransferAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The core mint quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<NoPrivacyTransferAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined, b: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawAction
 */
export class NoPrivacyWithdrawAction extends Message<NoPrivacyWithdrawAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The intended core mint quark amount to withdraw
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * Whether the account is closed afterwards. This is always true, since there
   * are no current se cases to leave it open.
   *
   * @generated from field: bool should_close = 5;
   */
  shouldClose = false;

  /**
   * Whether this action is for an auto-return, which client allows server to defer
   * scheduling at its own discretion to return funds back to the owner (to their primary
   * account) that funded source.
   *
   * @generated from field: bool is_auto_return = 6;
   */
  isAutoReturn = false;

  constructor(data?: PartialMessage<NoPrivacyWithdrawAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "should_close", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "is_auto_return", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined, b: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.FeePaymentAction
 */
export class FeePaymentAction extends Message<FeePaymentAction> {
  /**
   * The type of fee being operated on
   *
   * @generated from field: code.transaction.v2.FeePaymentAction.FeeType type = 4;
   */
  type = FeePaymentAction_FeeType.CODE;

  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The core mint quark amount to transfer
   *
   * @generated from field: uint64 amount = 3;
   */
  amount = protoInt64.zero;

  /**
   * The destination where the fee payment is being made for fees outside of
   * Code.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 5;
   */
  destination?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(FeePaymentAction_FeeType) },
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined, b: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined): boolean {
    return proto3.util.equals(FeePaymentAction, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.FeePaymentAction.FeeType
 */
export enum FeePaymentAction_FeeType {
  /**
   * Hardcoded $0.01 USD fee to a dynamic fee account specified by server
   *
   * @generated from enum value: CODE = 0;
   */
  CODE = 0,

  /**
   * Third party fee specified at time of payment request
   *
   * @generated from enum value: THIRD_PARTY = 1;
   */
  THIRD_PARTY = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(FeePaymentAction_FeeType)
proto3.util.setEnumType(FeePaymentAction_FeeType, "code.transaction.v2.FeePaymentAction.FeeType", [
  { no: 0, name: "CODE" },
  { no: 1, name: "THIRD_PARTY" },
]);

/**
 * ServerParameter are a set of parameters known and returned by server that
 * enables clients to complete transaction construction. Any necessary proofs,
 * which are required to be locally verifiable, are also provided to ensure
 * safe use in the event of a malicious server.
 *
 * @generated from message code.transaction.v2.ServerParameter
 */
export class ServerParameter extends Message<ServerParameter> {
  /**
   * The action the server parameters belong to
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * The set of nonces used for the action. Server will only provide values
   * for transactions requiring client signatures.
   *
   * @generated from field: repeated code.transaction.v2.NoncedTransactionMetadata nonces = 2;
   */
  nonces: NoncedTransactionMetadata[] = [];

  /**
   * The type of server parameter which maps to the type of action requested
   *
   * @generated from oneof code.transaction.v2.ServerParameter.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountServerParameter open_account = 3;
     */
    value: OpenAccountServerParameter;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferServerParameter no_privacy_transfer = 6;
     */
    value: NoPrivacyTransferServerParameter;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawServerParameter no_privacy_withdraw = 7;
     */
    value: NoPrivacyWithdrawServerParameter;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentServerParameter fee_payment = 11;
     */
    value: FeePaymentServerParameter;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "nonces", kind: "message", T: NoncedTransactionMetadata, repeated: true },
    { no: 3, name: "open_account", kind: "message", T: OpenAccountServerParameter, oneof: "type" },
    { no: 6, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferServerParameter, oneof: "type" },
    { no: 7, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawServerParameter, oneof: "type" },
    { no: 11, name: "fee_payment", kind: "message", T: FeePaymentServerParameter, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerParameter {
    return new ServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ServerParameter | PlainMessage<ServerParameter> | undefined, b: ServerParameter | PlainMessage<ServerParameter> | undefined): boolean {
    return proto3.util.equals(ServerParameter, a, b);
  }
}

/**
 * For transactions, the nonce is a standard nonce on Solana
 * For virtual instructions, the nonce is a virtual nonce on the Code VM
 *
 * @generated from message code.transaction.v2.NoncedTransactionMetadata
 */
export class NoncedTransactionMetadata extends Message<NoncedTransactionMetadata> {
  /**
   * The nonce account to use in the system::AdvanceNonce instruction
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 1;
   */
  nonce?: SolanaAccountId;

  /**
   * The blockhash to set in the transaction or virtual instruction
   *
   * @generated from field: code.common.v1.Blockhash blockhash = 2;
   */
  blockhash?: Blockhash;

  constructor(data?: PartialMessage<NoncedTransactionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoncedTransactionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "message", T: SolanaAccountId },
    { no: 2, name: "blockhash", kind: "message", T: Blockhash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined, b: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined): boolean {
    return proto3.util.equals(NoncedTransactionMetadata, a, b);
  }
}

/**
 * There are no transactions requiring client signatures
 *
 * @generated from message code.transaction.v2.OpenAccountServerParameter
 */
export class OpenAccountServerParameter extends Message<OpenAccountServerParameter> {
  constructor(data?: PartialMessage<OpenAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined, b: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(OpenAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferServerParameter
 */
export class NoPrivacyTransferServerParameter extends Message<NoPrivacyTransferServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyTransferServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined, b: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawServerParameter
 */
export class NoPrivacyWithdrawServerParameter extends Message<NoPrivacyWithdrawServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyWithdrawServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined, b: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.FeePaymentServerParameter
 */
export class FeePaymentServerParameter extends Message<FeePaymentServerParameter> {
  /**
   * The destination account where Code fee payments should be sent. This will
   * only be set when the corresponding FeePaymentAction Type is CODE.
   *
   * @generated from field: code.common.v1.SolanaAccountId code_destination = 1;
   */
  codeDestination?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code_destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined, b: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined): boolean {
    return proto3.util.equals(FeePaymentServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ErrorDetails
 */
export class ErrorDetails extends Message<ErrorDetails> {
  /**
   * @generated from oneof code.transaction.v2.ErrorDetails.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.ReasonStringErrorDetails reason_string = 1;
     */
    value: ReasonStringErrorDetails;
    case: "reasonString";
  } | {
    /**
     * @generated from field: code.transaction.v2.InvalidSignatureErrorDetails invalid_signature = 2;
     */
    value: InvalidSignatureErrorDetails;
    case: "invalidSignature";
  } | {
    /**
     * @generated from field: code.transaction.v2.DeniedErrorDetails denied = 3;
     */
    value: DeniedErrorDetails;
    case: "denied";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason_string", kind: "message", T: ReasonStringErrorDetails, oneof: "type" },
    { no: 2, name: "invalid_signature", kind: "message", T: InvalidSignatureErrorDetails, oneof: "type" },
    { no: 3, name: "denied", kind: "message", T: DeniedErrorDetails, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetails {
    return new ErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetails | PlainMessage<ErrorDetails> | undefined, b: ErrorDetails | PlainMessage<ErrorDetails> | undefined): boolean {
    return proto3.util.equals(ErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ReasonStringErrorDetails
 */
export class ReasonStringErrorDetails extends Message<ReasonStringErrorDetails> {
  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 1;
   */
  reason = "";

  constructor(data?: PartialMessage<ReasonStringErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReasonStringErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined, b: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined): boolean {
    return proto3.util.equals(ReasonStringErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.InvalidSignatureErrorDetails
 */
export class InvalidSignatureErrorDetails extends Message<InvalidSignatureErrorDetails> {
  /**
   * The action whose signature mismatched
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * @generated from oneof code.transaction.v2.InvalidSignatureErrorDetails.expected_blob
   */
  expectedBlob: {
    /**
     * The transaction the server expected to have signed.
     *
     * @generated from field: code.common.v1.Transaction expected_transaction = 2;
     */
    value: Transaction;
    case: "expectedTransaction";
  } | {
    /**
     * The virtual ixn hash the server expected to have signed.
     *
     * @generated from field: code.common.v1.Hash expected_vixn_hash = 4;
     */
    value: Hash;
    case: "expectedVixnHash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The signature that was provided by the client.
   *
   * @generated from field: code.common.v1.Signature provided_signature = 3;
   */
  providedSignature?: Signature;

  constructor(data?: PartialMessage<InvalidSignatureErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.InvalidSignatureErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "expected_transaction", kind: "message", T: Transaction, oneof: "expected_blob" },
    { no: 4, name: "expected_vixn_hash", kind: "message", T: Hash, oneof: "expected_blob" },
    { no: 3, name: "provided_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined, b: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined): boolean {
    return proto3.util.equals(InvalidSignatureErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.DeniedErrorDetails
 */
export class DeniedErrorDetails extends Message<DeniedErrorDetails> {
  /**
   * @generated from field: code.transaction.v2.DeniedErrorDetails.Code code = 1;
   */
  code = DeniedErrorDetails_Code.UNSPECIFIED;

  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<DeniedErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DeniedErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(DeniedErrorDetails_Code) },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined, b: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined): boolean {
    return proto3.util.equals(DeniedErrorDetails, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.DeniedErrorDetails.Code
 */
export enum DeniedErrorDetails_Code {
  /**
   * Reason code not yet defined
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(DeniedErrorDetails_Code)
proto3.util.setEnumType(DeniedErrorDetails_Code, "code.transaction.v2.DeniedErrorDetails.Code", [
  { no: 0, name: "UNSPECIFIED" },
]);

/**
 * ExchangeData defines an amount of crypto with currency exchange data
 *
 * @generated from message code.transaction.v2.ExchangeData
 */
export class ExchangeData extends Message<ExchangeData> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon exchange rate. This might not be the same as the
   * actual exchange rate at the time of intent or fund transfer.
   *
   * @generated from field: double exchange_rate = 2;
   */
  exchangeRate = 0;

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 3;
   */
  nativeAmount = 0;

  /**
   * The exact amount of quarks to send. This will be used as the source of
   * truth for validating transaction transfer amounts.
   *
   * @generated from field: uint64 quarks = 4;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<ExchangeData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exchange_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeData {
    return new ExchangeData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeData | PlainMessage<ExchangeData> | undefined, b: ExchangeData | PlainMessage<ExchangeData> | undefined): boolean {
    return proto3.util.equals(ExchangeData, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ExchangeDataWithoutRate
 */
export class ExchangeDataWithoutRate extends Message<ExchangeDataWithoutRate> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  constructor(data?: PartialMessage<ExchangeDataWithoutRate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeDataWithoutRate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined, b: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined): boolean {
    return proto3.util.equals(ExchangeDataWithoutRate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.AdditionalFeePayment
 */
export class AdditionalFeePayment extends Message<AdditionalFeePayment> {
  /**
   * Destination token account where the fee payment will be made
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * Fee percentage, in basis points, of the total quark amount of a payment.
   *
   * @generated from field: uint32 fee_bps = 2;
   */
  feeBps = 0;

  constructor(data?: PartialMessage<AdditionalFeePayment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AdditionalFeePayment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "fee_bps", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdditionalFeePayment {
    return new AdditionalFeePayment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdditionalFeePayment {
    return new AdditionalFeePayment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdditionalFeePayment {
    return new AdditionalFeePayment().fromJsonString(jsonString, options);
  }

  static equals(a: AdditionalFeePayment | PlainMessage<AdditionalFeePayment> | undefined, b: AdditionalFeePayment | PlainMessage<AdditionalFeePayment> | undefined): boolean {
    return proto3.util.equals(AdditionalFeePayment, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SendLimit
 */
export class SendLimit extends Message<SendLimit> {
  /**
   * Remaining limit to apply on the next transaction
   *
   * @generated from field: float next_transaction = 1;
   */
  nextTransaction = 0;

  /**
   * Maximum allowed on a per-transaction basis
   *
   * @generated from field: float max_per_transaction = 2;
   */
  maxPerTransaction = 0;

  /**
   * Maximum allowed on a per-day basis
   *
   * @generated from field: float max_per_day = 3;
   */
  maxPerDay = 0;

  constructor(data?: PartialMessage<SendLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "max_per_day", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendLimit {
    return new SendLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJsonString(jsonString, options);
  }

  static equals(a: SendLimit | PlainMessage<SendLimit> | undefined, b: SendLimit | PlainMessage<SendLimit> | undefined): boolean {
    return proto3.util.equals(SendLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.MicroPaymentLimit
 */
export class MicroPaymentLimit extends Message<MicroPaymentLimit> {
  /**
   * Maximum native amount that can be applied per micro payment transaction
   *
   * @generated from field: float max_per_transaction = 1;
   */
  maxPerTransaction = 0;

  /**
   * Minimum native amount that can be applied per micro payment transaction
   *
   * @generated from field: float min_per_transaction = 2;
   */
  minPerTransaction = 0;

  constructor(data?: PartialMessage<MicroPaymentLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.MicroPaymentLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "min_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MicroPaymentLimit {
    return new MicroPaymentLimit().fromJsonString(jsonString, options);
  }

  static equals(a: MicroPaymentLimit | PlainMessage<MicroPaymentLimit> | undefined, b: MicroPaymentLimit | PlainMessage<MicroPaymentLimit> | undefined): boolean {
    return proto3.util.equals(MicroPaymentLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.BuyModuleLimit
 */
export class BuyModuleLimit extends Message<BuyModuleLimit> {
  /**
   * Minimum amount that can be purchased through the buy module
   *
   * @generated from field: float min_per_transaction = 1;
   */
  minPerTransaction = 0;

  /**
   * Maximum amount that can be purchased through the buy module
   *
   * @generated from field: float max_per_transaction = 2;
   */
  maxPerTransaction = 0;

  constructor(data?: PartialMessage<BuyModuleLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.BuyModuleLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuyModuleLimit {
    return new BuyModuleLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuyModuleLimit {
    return new BuyModuleLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuyModuleLimit {
    return new BuyModuleLimit().fromJsonString(jsonString, options);
  }

  static equals(a: BuyModuleLimit | PlainMessage<BuyModuleLimit> | undefined, b: BuyModuleLimit | PlainMessage<BuyModuleLimit> | undefined): boolean {
    return proto3.util.equals(BuyModuleLimit, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

