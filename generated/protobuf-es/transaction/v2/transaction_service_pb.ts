// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file transaction/v2/transaction_service.proto (package code.transaction.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccountType, Blockhash, Hash, IntentId, Signature, SolanaAccountId, Transaction } from "../../common/v1/model_pb";

/**
 * @generated from enum code.transaction.v2.AirdropType
 */
export enum AirdropType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Reward for onboarding another user
   *
   * @generated from enum value: ONBOARDING_BONUS = 1;
   */
  ONBOARDING_BONUS = 1,

  /**
   * Airdrop for getting a user started with first crypto balance
   *
   * @generated from enum value: WELCOME_BONUS = 2;
   */
  WELCOME_BONUS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropType)
proto3.util.setEnumType(AirdropType, "code.transaction.v2.AirdropType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "ONBOARDING_BONUS" },
  { no: 2, name: "WELCOME_BONUS" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest
 */
export class SubmitIntentRequest extends Message<SubmitIntentRequest> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitActions submit_actions = 1;
     */
    value: SubmitIntentRequest_SubmitActions;
    case: "submitActions";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitSignatures submit_signatures = 2;
     */
    value: SubmitIntentRequest_SubmitSignatures;
    case: "submitSignatures";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "submit_actions", kind: "message", T: SubmitIntentRequest_SubmitActions, oneof: "request" },
    { no: 2, name: "submit_signatures", kind: "message", T: SubmitIntentRequest_SubmitSignatures, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined, b: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitActions
 */
export class SubmitIntentRequest_SubmitActions extends Message<SubmitIntentRequest_SubmitActions> {
  /**
   * The globally unique client generated intent ID. Use the original intent
   * ID when operating on actions that mutate the intent.
   *
   * @generated from field: code.common.v1.IntentId id = 1;
   */
  id?: IntentId;

  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * Additional metadata that describes the high-level intention
   *
   * @generated from field: code.transaction.v2.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * The set of all ordered actions required to fulfill the intent
   *
   * @generated from field: repeated code.transaction.v2.Action actions = 4;
   */
  actions: Action[] = [];

  /**
   * The signature is of serialize(SubmitActions) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitActions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitActions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
    { no: 4, name: "actions", kind: "message", T: Action, repeated: true },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined, b: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitActions, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitSignatures
 */
export class SubmitIntentRequest_SubmitSignatures extends Message<SubmitIntentRequest_SubmitSignatures> {
  /**
   * The set of all signatures for each transaction or virtual instruction requiring
   * signature from the authority accounts.
   *
   * The signature for a transaction is for the marshalled transaction.
   * The signature for a virtual instruction is the hash of the marshalled instruction.
   *
   * @generated from field: repeated code.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined, b: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitSignatures, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse
 */
export class SubmitIntentResponse extends Message<SubmitIntentResponse> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.ServerParameters server_parameters = 1;
     */
    value: SubmitIntentResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Success success = 2;
     */
    value: SubmitIntentResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Error error = 3;
     */
    value: SubmitIntentResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SubmitIntentResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SubmitIntentResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SubmitIntentResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined, b: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.ServerParameters
 */
export class SubmitIntentResponse_ServerParameters extends Message<SubmitIntentResponse_ServerParameters> {
  /**
   * The set of all server paremeters required to fill missing transaction
   * or virtual instruction details. Server guarantees to provide a message
   * for each client action in an order consistent with the received action
   * list. 
   *
   * @generated from field: repeated code.transaction.v2.ServerParameter server_parameters = 1;
   */
  serverParameters: ServerParameter[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: ServerParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined, b: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Success
 */
export class SubmitIntentResponse_Success extends Message<SubmitIntentResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Success.Code code = 1;
   */
  code = SubmitIntentResponse_Success_Code.OK;

  constructor(data?: PartialMessage<SubmitIntentResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined, b: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Success.Code
 */
export enum SubmitIntentResponse_Success_Code {
  /**
   * The intent was successfully created and is now scheduled.
   *
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Success_Code)
proto3.util.setEnumType(SubmitIntentResponse_Success_Code, "code.transaction.v2.SubmitIntentResponse.Success.Code", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Error
 */
export class SubmitIntentResponse_Error extends Message<SubmitIntentResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Error.Code code = 1;
   */
  code = SubmitIntentResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined, b: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Error.Code
 */
export enum SubmitIntentResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * The intent is invalid.
   *
   * @generated from enum value: INVALID_INTENT = 1;
   */
  INVALID_INTENT = 1,

  /**
   * There is an issue with provided signatures.
   *
   * @generated from enum value: SIGNATURE_ERROR = 2;
   */
  SIGNATURE_ERROR = 2,

  /**
   * Server detected client has stale state.
   *
   * @generated from enum value: STALE_STATE = 3;
   */
  STALE_STATE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Error_Code)
proto3.util.setEnumType(SubmitIntentResponse_Error_Code, "code.transaction.v2.SubmitIntentResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "INVALID_INTENT" },
  { no: 2, name: "SIGNATURE_ERROR" },
  { no: 3, name: "STALE_STATE" },
]);

/**
 * @generated from message code.transaction.v2.GetIntentMetadataRequest
 */
export class GetIntentMetadataRequest extends Message<GetIntentMetadataRequest> {
  /**
   * The intent ID to query
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The verified owner account public key when not signing with the rendezvous
   * key. Only owner accounts involved in the intent can access the metadata.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetIntentStatusRequest) without this field set
   * using the private key of the rendezvous or owner account. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetIntentMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined, b: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetIntentMetadataResponse
 */
export class GetIntentMetadataResponse extends Message<GetIntentMetadataResponse> {
  /**
   * @generated from field: code.transaction.v2.GetIntentMetadataResponse.Result result = 1;
   */
  result = GetIntentMetadataResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<GetIntentMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetIntentMetadataResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined, b: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetIntentMetadataResponse.Result
 */
export enum GetIntentMetadataResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetIntentMetadataResponse_Result)
proto3.util.setEnumType(GetIntentMetadataResponse_Result, "code.transaction.v2.GetIntentMetadataResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.GetLimitsRequest
 */
export class GetLimitsRequest extends Message<GetLimitsRequest> {
  /**
   * The owner account whose limits will be calculated. Any other owner accounts
   * linked with the same identity of the owner will also be applied.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetLimitsRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * All transactions starting at this time will be incorporated into the consumed
   * limit calculation. Clients should set this to the start of the current day in
   * the client's current time zone (because server has no knowledge of this atm).
   *
   * @generated from field: google.protobuf.Timestamp consumed_since = 3;
   */
  consumedSince?: Timestamp;

  constructor(data?: PartialMessage<GetLimitsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "consumed_since", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined, b: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined): boolean {
    return proto3.util.equals(GetLimitsRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetLimitsResponse
 */
export class GetLimitsResponse extends Message<GetLimitsResponse> {
  /**
   * @generated from field: code.transaction.v2.GetLimitsResponse.Result result = 1;
   */
  result = GetLimitsResponse_Result.OK;

  /**
   * Send limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.SendLimit> send_limits_by_currency = 2;
   */
  sendLimitsByCurrency: { [key: string]: SendLimit } = {};

  /**
   * The amount of USD transacted since the consumption timestamp
   *
   * @generated from field: double usd_transacted = 6;
   */
  usdTransacted = 0;

  constructor(data?: PartialMessage<GetLimitsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetLimitsResponse_Result) },
    { no: 2, name: "send_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SendLimit} },
    { no: 6, name: "usd_transacted", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined, b: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined): boolean {
    return proto3.util.equals(GetLimitsResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetLimitsResponse.Result
 */
export enum GetLimitsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetLimitsResponse_Result)
proto3.util.setEnumType(GetLimitsResponse_Result, "code.transaction.v2.GetLimitsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountRequest
 */
export class CanWithdrawToAccountRequest extends Message<CanWithdrawToAccountRequest> {
  /**
   * The destination account attempted to be withdrawn to. Can be an owner or
   * token account.
   *
   * @generated from field: code.common.v1.SolanaAccountId account = 1;
   */
  account?: SolanaAccountId;

  /**
   * The mint that the withdraw will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 2;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<CanWithdrawToAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: SolanaAccountId },
    { no: 2, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined, b: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountResponse
 */
export class CanWithdrawToAccountResponse extends Message<CanWithdrawToAccountResponse> {
  /**
   * Server-controlled flag to indicate if the account can be withdrawn to.
   * There are several reasons server may deny it, including:
   *  - Wrong type of Code account
   *  - Unsupported external account type (eg. token account but of the wrong mint)
   * This is guaranteed to be false when account_type = Unknown.
   *
   * @generated from field: bool is_valid_payment_destination = 1;
   */
  isValidPaymentDestination = false;

  /**
   * Metadata so the client knows how to withdraw to the account. Server cannot
   * provide precalculated addresses in this response to maintain non-custodial
   * status.
   *
   * @generated from field: code.transaction.v2.CanWithdrawToAccountResponse.AccountType account_type = 2;
   */
  accountType = CanWithdrawToAccountResponse_AccountType.Unknown;

  /**
   * ATA requires initialization before the withdrawal can occur. Server will not
   * subsidize the account creation, so a fee is required.
   *
   * @generated from field: bool requires_initialization = 3;
   */
  requiresInitialization = false;

  /**
   * The CREATE_ON_SEND_WITHDRAWAL fee, in USD, that must be paid in order to
   * submit a withdrawal to subsidize the creation of the account at time of
   * send. The user must explicitly agree to this fee amount before submitting
   * the intent.
   *
   * This will be set when requires_initialization = true
   *
   * @generated from field: code.transaction.v2.ExchangeDataWithoutRate fee_amount = 4;
   */
  feeAmount?: ExchangeDataWithoutRate;

  constructor(data?: PartialMessage<CanWithdrawToAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_valid_payment_destination", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "account_type", kind: "enum", T: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType) },
    { no: 3, name: "requires_initialization", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "fee_amount", kind: "message", T: ExchangeDataWithoutRate },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined, b: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.CanWithdrawToAccountResponse.AccountType
 */
export enum CanWithdrawToAccountResponse_AccountType {
  /**
   * Server cannot determine
   *
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * Client uses the address as is in SubmitIntent
   *
   * @generated from enum value: TokenAccount = 1;
   */
  TokenAccount = 1,

  /**
   * Client locally derives the ATA to use in SubmitIntent
   *
   * @generated from enum value: OwnerAccount = 2;
   */
  OwnerAccount = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType)
proto3.util.setEnumType(CanWithdrawToAccountResponse_AccountType, "code.transaction.v2.CanWithdrawToAccountResponse.AccountType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "TokenAccount" },
  { no: 2, name: "OwnerAccount" },
]);

/**
 * @generated from message code.transaction.v2.AirdropRequest
 */
export class AirdropRequest extends Message<AirdropRequest> {
  /**
   * The type of airdrop to claim
   *
   * @generated from field: code.transaction.v2.AirdropType airdrop_type = 1;
   */
  airdropType = AirdropType.UNKNOWN;

  /**
   * The owner account to airdrop core mint tokens to
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(AirdropRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AirdropRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "airdrop_type", kind: "enum", T: proto3.getEnumType(AirdropType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropRequest {
    return new AirdropRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropRequest | PlainMessage<AirdropRequest> | undefined, b: AirdropRequest | PlainMessage<AirdropRequest> | undefined): boolean {
    return proto3.util.equals(AirdropRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.AirdropResponse
 */
export class AirdropResponse extends Message<AirdropResponse> {
  /**
   * @generated from field: code.transaction.v2.AirdropResponse.Result result = 1;
   */
  result = AirdropResponse_Result.OK;

  /**
   * Exchange data for the amount of core mint tokens airdropped when successful
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<AirdropResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AirdropResponse_Result) },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropResponse {
    return new AirdropResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropResponse | PlainMessage<AirdropResponse> | undefined, b: AirdropResponse | PlainMessage<AirdropResponse> | undefined): boolean {
    return proto3.util.equals(AirdropResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.AirdropResponse.Result
 */
export enum AirdropResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * Airdrops are unavailable
   *
   * @generated from enum value: UNAVAILABLE = 1;
   */
  UNAVAILABLE = 1,

  /**
   * The airdrop has already been claimed by the owner
   *
   * @generated from enum value: ALREADY_CLAIMED = 2;
   */
  ALREADY_CLAIMED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropResponse_Result)
proto3.util.setEnumType(AirdropResponse_Result, "code.transaction.v2.AirdropResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "UNAVAILABLE" },
  { no: 2, name: "ALREADY_CLAIMED" },
]);

/**
 * @generated from message code.transaction.v2.VoidGiftCardRequest
 */
export class VoidGiftCardRequest extends Message<VoidGiftCardRequest> {
  /**
   * The owner account that issued the gift card account
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The vault of the gift card account to void
   *
   * @generated from field: code.common.v1.SolanaAccountId gift_card_vault = 2;
   */
  giftCardVault?: SolanaAccountId;

  /**
   * The signature is of serialize(VoidGiftCardRequest) without this field set using
   * the private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<VoidGiftCardRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "gift_card_vault", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined, b: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.VoidGiftCardResponse
 */
export class VoidGiftCardResponse extends Message<VoidGiftCardResponse> {
  /**
   * @generated from field: code.transaction.v2.VoidGiftCardResponse.Result result = 1;
   */
  result = VoidGiftCardResponse_Result.OK;

  constructor(data?: PartialMessage<VoidGiftCardResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(VoidGiftCardResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined, b: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.VoidGiftCardResponse.Result
 */
export enum VoidGiftCardResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The owner account didn't issue the gift card accoun
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * A different owner account than the issuer claimed the gift card
   *
   * @generated from enum value: CLAIMED_BY_OTHER_USER = 2;
   */
  CLAIMED_BY_OTHER_USER = 2,

  /**
   * The gift card doesn't exist
   *
   * @generated from enum value: NOT_FOUND = 3;
   */
  NOT_FOUND = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(VoidGiftCardResponse_Result)
proto3.util.setEnumType(VoidGiftCardResponse_Result, "code.transaction.v2.VoidGiftCardResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CLAIMED_BY_OTHER_USER" },
  { no: 3, name: "NOT_FOUND" },
]);

/**
 * Metadata describes the high-level details of an intent
 *
 * @generated from message code.transaction.v2.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from oneof code.transaction.v2.Metadata.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountsMetadata open_accounts = 1;
     */
    value: OpenAccountsMetadata;
    case: "openAccounts";
  } | {
    /**
     * @generated from field: code.transaction.v2.SendPublicPaymentMetadata send_public_payment = 6;
     */
    value: SendPublicPaymentMetadata;
    case: "sendPublicPayment";
  } | {
    /**
     * @generated from field: code.transaction.v2.ReceivePaymentsPubliclyMetadata receive_payments_publicly = 7;
     */
    value: ReceivePaymentsPubliclyMetadata;
    case: "receivePaymentsPublicly";
  } | {
    /**
     * @generated from field: code.transaction.v2.PublicDistributionMetadata public_distribution = 9;
     */
    value: PublicDistributionMetadata;
    case: "publicDistribution";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_accounts", kind: "message", T: OpenAccountsMetadata, oneof: "type" },
    { no: 6, name: "send_public_payment", kind: "message", T: SendPublicPaymentMetadata, oneof: "type" },
    { no: 7, name: "receive_payments_publicly", kind: "message", T: ReceivePaymentsPubliclyMetadata, oneof: "type" },
    { no: 9, name: "public_distribution", kind: "message", T: PublicDistributionMetadata, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * Open a set of accounts
 *
 * Action Spec (User):
 *
 * for account in [PRIMARY]
 *   actions.push_back(OpenAccountAction(account))
 *
 * Action Spec (Pool):
 *
 * for account in [POOL]
 *   actions.push_back(OpenAccountAction(account))
 *
 * @generated from message code.transaction.v2.OpenAccountsMetadata
 */
export class OpenAccountsMetadata extends Message<OpenAccountsMetadata> {
  /**
   * @generated from field: code.transaction.v2.OpenAccountsMetadata.AccountSet account_set = 1;
   */
  accountSet = OpenAccountsMetadata_AccountSet.USER;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 2;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<OpenAccountsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_set", kind: "enum", T: proto3.getEnumType(OpenAccountsMetadata_AccountSet) },
    { no: 2, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined, b: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined): boolean {
    return proto3.util.equals(OpenAccountsMetadata, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.OpenAccountsMetadata.AccountSet
 */
export enum OpenAccountsMetadata_AccountSet {
  /**
   * Opens a set of user accounts
   *
   * @generated from enum value: USER = 0;
   */
  USER = 0,

  /**
   * Opens a pool account
   *
   * @generated from enum value: POOL = 1;
   */
  POOL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(OpenAccountsMetadata_AccountSet)
proto3.util.setEnumType(OpenAccountsMetadata_AccountSet, "code.transaction.v2.OpenAccountsMetadata.AccountSet", [
  { no: 0, name: "USER" },
  { no: 1, name: "POOL" },
]);

/**
 * Send a payment to a destination account publicly.
 *
 * Action Spec (Payment):
 *
 * actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
 *
 * Action Spec (Withdrawal):
 *
 * actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
 * if destinationRequiresInitialization {
 *   actions[0].NoPrivacyTransferAction.ExchangeData.Quarks -= feeAmount
 *   actions.push_back(FeePaymentAction(PRIMARY, feeAccount, feeAmount))
 * }
 *
 * Action Spec (Remote Send):
 *
 * actions = [
 *   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
 *   NoPrivacyTransferAction(PRIMARY, REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
 *   NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, ExchangeData.Quarks, is_auto_return=true),
 * ]
 *
 * @generated from message code.transaction.v2.SendPublicPaymentMetadata
 */
export class SendPublicPaymentMetadata extends Message<SendPublicPaymentMetadata> {
  /**
   * The source account where funds will be sent from. Currently, this is always
   * the user's primary account.
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 4;
   */
  source?: SolanaAccountId;

  /**
   * The destination token account to send funds to.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * Destination owner account, which is required for withdrawals that intend
   * to create an ATA. Every other variation of this intent can omit this field.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination_owner = 6;
   */
  destinationOwner?: SolanaAccountId;

  /**
   * The exchange data of total funds being sent to the destination
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is the payment a withdrawal?
   *
   * @generated from field: bool is_withdrawal = 3;
   */
  isWithdrawal = false;

  /**
   * Is the payment going to a new gift card? Note is_withdrawal must be false.
   *
   * @generated from field: bool is_remote_send = 5;
   */
  isRemoteSend = false;

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<SendPublicPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendPublicPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "source", kind: "message", T: SolanaAccountId },
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 6, name: "destination_owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "is_withdrawal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined, b: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(SendPublicPaymentMetadata, a, b);
  }
}

/**
 * Receive funds into a user-owned account publicly. All use cases of this intent
 * close the account, so all funds must be moved.
 *
 * Action Spec (Remote Send):
 *
 * actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, quarks)]
 *
 * @generated from message code.transaction.v2.ReceivePaymentsPubliclyMetadata
 */
export class ReceivePaymentsPubliclyMetadata extends Message<ReceivePaymentsPubliclyMetadata> {
  /**
   * The remote send gift card to receive funds from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The exact amount of core mint quarks being received
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  /**
   * Is the receipt of funds from a remote send gift card? Currently, this is
   * the only use case for this intent and validation enforces the flag to true.
   *
   * @generated from field: bool is_remote_send = 3;
   */
  isRemoteSend = false;

  /**
   * If is_remote_send is true, the original exchange data that was provided as
   * part of creating the gift card account. This is purely a server-provided value.
   * SubmitIntent will disallow this being set.
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 5;
   */
  exchangeData?: ExchangeData;

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 6;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<ReceivePaymentsPubliclyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReceivePaymentsPubliclyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 6, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined, b: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined): boolean {
    return proto3.util.equals(ReceivePaymentsPubliclyMetadata, a, b);
  }
}

/**
 * Distribute funds from a pool account publicly to one or more user-owned accounts.
 *
 * Action Spec:
 *
 * for distribution in distributions[:len(distributions)-1]
 *   actions.push_back(NoPrivacyTransferAction(POOL, distribution.destination, distributions.quarks))
 * actions.push_back(NoPrivacyWithdrawAction(POOL, distributions[len(distributions)-1].destination, distributions[len(distributions)-1].quarks))
 *
 * Notes:
 *  - All funds must distributed. The balance of the pool must be zero at the end of the intent
 *  - The pool is closed at the end of the intent via a NoPrivacyWithdrawAction
 *
 * @generated from message code.transaction.v2.PublicDistributionMetadata
 */
export class PublicDistributionMetadata extends Message<PublicDistributionMetadata> {
  /**
   * The pool account to distribute from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The set of distributions
   *
   * @generated from field: repeated code.transaction.v2.PublicDistributionMetadata.Distribution distributions = 2;
   */
  distributions: PublicDistributionMetadata_Distribution[] = [];

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 3;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<PublicDistributionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PublicDistributionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "distributions", kind: "message", T: PublicDistributionMetadata_Distribution, repeated: true },
    { no: 3, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PublicDistributionMetadata | PlainMessage<PublicDistributionMetadata> | undefined, b: PublicDistributionMetadata | PlainMessage<PublicDistributionMetadata> | undefined): boolean {
    return proto3.util.equals(PublicDistributionMetadata, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.PublicDistributionMetadata.Distribution
 */
export class PublicDistributionMetadata_Distribution extends Message<PublicDistributionMetadata_Distribution> {
  /**
   * Destination where a portion of the pool's funds will be distributed.
   * This must always be a primary account.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * The amount of funds to distribute to the destination
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<PublicDistributionMetadata_Distribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PublicDistributionMetadata.Distribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromJsonString(jsonString, options);
  }

  static equals(a: PublicDistributionMetadata_Distribution | PlainMessage<PublicDistributionMetadata_Distribution> | undefined, b: PublicDistributionMetadata_Distribution | PlainMessage<PublicDistributionMetadata_Distribution> | undefined): boolean {
    return proto3.util.equals(PublicDistributionMetadata_Distribution, a, b);
  }
}

/**
 * Action is a well-defined, ordered and small set of transactions or virtual instructions
 * for a unit of work that the client wants to perform on the blockchain. Clients provide
 * parameters known to them in the action.
 *
 * @generated from message code.transaction.v2.Action
 */
export class Action extends Message<Action> {
  /**
   * The ID of this action, which is unique within an intent. It must match
   * the index of the action's location in the SubmitAction's actions field.
   *
   * @generated from field: uint32 id = 1;
   */
  id = 0;

  /**
   * The type of action to perform.
   *
   * @generated from oneof code.transaction.v2.Action.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountAction open_account = 2;
     */
    value: OpenAccountAction;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferAction no_privacy_transfer = 5;
     */
    value: NoPrivacyTransferAction;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawAction no_privacy_withdraw = 6;
     */
    value: NoPrivacyWithdrawAction;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentAction fee_payment = 10;
     */
    value: FeePaymentAction;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "open_account", kind: "message", T: OpenAccountAction, oneof: "type" },
    { no: 5, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferAction, oneof: "type" },
    { no: 6, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawAction, oneof: "type" },
    { no: 10, name: "fee_payment", kind: "message", T: FeePaymentAction, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * No client signature required
 *
 * @generated from message code.transaction.v2.OpenAccountAction
 */
export class OpenAccountAction extends Message<OpenAccountAction> {
  /**
   * The type of account, which will dictate its intended use
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The owner of the account. For accounts liked to a user's 12 words, this is
   * the verified parent owner account public key. All other account types should
   * set this to the authority value.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The index used to for accounts that are derived from owner
   *
   * @generated from field: uint64 index = 3;
   */
  index = protoInt64.zero;

  /**
   * The public key of the private key that has authority over the opened token account
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 4;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being opened
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 5;
   */
  token?: SolanaAccountId;

  /**
   * The signature is of serialize(OpenAccountAction) without this field set
   * using the private key of the authority account. This provides a proof
   * of authorization to link authority to owner.
   *
   * @generated from field: code.common.v1.Signature authority_signature = 6;
   */
  authoritySignature?: Signature;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<OpenAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 5, name: "token", kind: "message", T: SolanaAccountId },
    { no: 6, name: "authority_signature", kind: "message", T: Signature },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined, b: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined): boolean {
    return proto3.util.equals(OpenAccountAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferAction
 */
export class NoPrivacyTransferAction extends Message<NoPrivacyTransferAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The core mint quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<NoPrivacyTransferAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined, b: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawAction
 */
export class NoPrivacyWithdrawAction extends Message<NoPrivacyWithdrawAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The intended core mint quark amount to withdraw
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * Whether the account is closed afterwards. This is always true, since there
   * are no current se cases to leave it open.
   *
   * @generated from field: bool should_close = 5;
   */
  shouldClose = false;

  /**
   * Whether this action is for an auto-return, which client allows server to defer
   * scheduling at its own discretion to return funds back to the owner (to their primary
   * account) that funded source.
   *
   * @generated from field: bool is_auto_return = 6;
   */
  isAutoReturn = false;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<NoPrivacyWithdrawAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "should_close", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "is_auto_return", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined, b: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.FeePaymentAction
 */
export class FeePaymentAction extends Message<FeePaymentAction> {
  /**
   * The type of fee being operated on
   *
   * @generated from field: code.transaction.v2.FeePaymentAction.FeeType type = 1;
   */
  type = FeePaymentAction_FeeType.UNKNOWN;

  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 2;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 3;
   */
  source?: SolanaAccountId;

  /**
   * The core mint quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(FeePaymentAction_FeeType) },
    { no: 2, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 3, name: "source", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined, b: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined): boolean {
    return proto3.util.equals(FeePaymentAction, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.FeePaymentAction.FeeType
 */
export enum FeePaymentAction_FeeType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Server-defined fee for creating an external ATA on withdrawals on send
   *
   * @generated from enum value: CREATE_ON_SEND_WITHDRAWAL = 1;
   */
  CREATE_ON_SEND_WITHDRAWAL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(FeePaymentAction_FeeType)
proto3.util.setEnumType(FeePaymentAction_FeeType, "code.transaction.v2.FeePaymentAction.FeeType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CREATE_ON_SEND_WITHDRAWAL" },
]);

/**
 * ServerParameter are a set of parameters known and returned by server that
 * enables clients to complete transaction construction. Any necessary proofs,
 * which are required to be locally verifiable, are also provided to ensure
 * safe use in the event of a malicious server.
 *
 * @generated from message code.transaction.v2.ServerParameter
 */
export class ServerParameter extends Message<ServerParameter> {
  /**
   * The action the server parameters belong to
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * The set of nonces used for the action. Server will only provide values
   * for transactions requiring client signatures.
   *
   * @generated from field: repeated code.transaction.v2.NoncedTransactionMetadata nonces = 2;
   */
  nonces: NoncedTransactionMetadata[] = [];

  /**
   * The type of server parameter which maps to the type of action requested
   *
   * @generated from oneof code.transaction.v2.ServerParameter.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountServerParameter open_account = 3;
     */
    value: OpenAccountServerParameter;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferServerParameter no_privacy_transfer = 6;
     */
    value: NoPrivacyTransferServerParameter;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawServerParameter no_privacy_withdraw = 7;
     */
    value: NoPrivacyWithdrawServerParameter;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentServerParameter fee_payment = 11;
     */
    value: FeePaymentServerParameter;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "nonces", kind: "message", T: NoncedTransactionMetadata, repeated: true },
    { no: 3, name: "open_account", kind: "message", T: OpenAccountServerParameter, oneof: "type" },
    { no: 6, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferServerParameter, oneof: "type" },
    { no: 7, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawServerParameter, oneof: "type" },
    { no: 11, name: "fee_payment", kind: "message", T: FeePaymentServerParameter, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerParameter {
    return new ServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ServerParameter | PlainMessage<ServerParameter> | undefined, b: ServerParameter | PlainMessage<ServerParameter> | undefined): boolean {
    return proto3.util.equals(ServerParameter, a, b);
  }
}

/**
 * For transactions, the nonce is a standard nonce on Solana
 * For virtual instructions, the nonce is a virtual nonce on the Code VM
 *
 * @generated from message code.transaction.v2.NoncedTransactionMetadata
 */
export class NoncedTransactionMetadata extends Message<NoncedTransactionMetadata> {
  /**
   * The nonce account to use in the system::AdvanceNonce instruction
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 1;
   */
  nonce?: SolanaAccountId;

  /**
   * The blockhash to set in the transaction or virtual instruction
   *
   * @generated from field: code.common.v1.Blockhash blockhash = 2;
   */
  blockhash?: Blockhash;

  constructor(data?: PartialMessage<NoncedTransactionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoncedTransactionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "message", T: SolanaAccountId },
    { no: 2, name: "blockhash", kind: "message", T: Blockhash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined, b: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined): boolean {
    return proto3.util.equals(NoncedTransactionMetadata, a, b);
  }
}

/**
 * There are no transactions requiring client signatures
 *
 * @generated from message code.transaction.v2.OpenAccountServerParameter
 */
export class OpenAccountServerParameter extends Message<OpenAccountServerParameter> {
  constructor(data?: PartialMessage<OpenAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined, b: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(OpenAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferServerParameter
 */
export class NoPrivacyTransferServerParameter extends Message<NoPrivacyTransferServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyTransferServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined, b: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawServerParameter
 */
export class NoPrivacyWithdrawServerParameter extends Message<NoPrivacyWithdrawServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyWithdrawServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined, b: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.FeePaymentServerParameter
 */
export class FeePaymentServerParameter extends Message<FeePaymentServerParameter> {
  /**
   * The destination account where OCP fee payments should be sent. This will
   * only be set when the corresponding FeePaymentAction.Type:
   * - CREATE_ON_SEND_WITHDRAWAL
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined, b: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined): boolean {
    return proto3.util.equals(FeePaymentServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ErrorDetails
 */
export class ErrorDetails extends Message<ErrorDetails> {
  /**
   * @generated from oneof code.transaction.v2.ErrorDetails.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.ReasonStringErrorDetails reason_string = 1;
     */
    value: ReasonStringErrorDetails;
    case: "reasonString";
  } | {
    /**
     * @generated from field: code.transaction.v2.InvalidSignatureErrorDetails invalid_signature = 2;
     */
    value: InvalidSignatureErrorDetails;
    case: "invalidSignature";
  } | {
    /**
     * @generated from field: code.transaction.v2.DeniedErrorDetails denied = 3;
     */
    value: DeniedErrorDetails;
    case: "denied";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason_string", kind: "message", T: ReasonStringErrorDetails, oneof: "type" },
    { no: 2, name: "invalid_signature", kind: "message", T: InvalidSignatureErrorDetails, oneof: "type" },
    { no: 3, name: "denied", kind: "message", T: DeniedErrorDetails, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetails {
    return new ErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetails | PlainMessage<ErrorDetails> | undefined, b: ErrorDetails | PlainMessage<ErrorDetails> | undefined): boolean {
    return proto3.util.equals(ErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ReasonStringErrorDetails
 */
export class ReasonStringErrorDetails extends Message<ReasonStringErrorDetails> {
  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 1;
   */
  reason = "";

  constructor(data?: PartialMessage<ReasonStringErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReasonStringErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined, b: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined): boolean {
    return proto3.util.equals(ReasonStringErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.InvalidSignatureErrorDetails
 */
export class InvalidSignatureErrorDetails extends Message<InvalidSignatureErrorDetails> {
  /**
   * The action whose signature mismatched
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * @generated from oneof code.transaction.v2.InvalidSignatureErrorDetails.expected_blob
   */
  expectedBlob: {
    /**
     * The transaction the server expected to have signed.
     *
     * @generated from field: code.common.v1.Transaction expected_transaction = 2;
     */
    value: Transaction;
    case: "expectedTransaction";
  } | {
    /**
     * The virtual ixn hash the server expected to have signed.
     *
     * @generated from field: code.common.v1.Hash expected_vixn_hash = 4;
     */
    value: Hash;
    case: "expectedVixnHash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The signature that was provided by the client.
   *
   * @generated from field: code.common.v1.Signature provided_signature = 3;
   */
  providedSignature?: Signature;

  constructor(data?: PartialMessage<InvalidSignatureErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.InvalidSignatureErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "expected_transaction", kind: "message", T: Transaction, oneof: "expected_blob" },
    { no: 4, name: "expected_vixn_hash", kind: "message", T: Hash, oneof: "expected_blob" },
    { no: 3, name: "provided_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined, b: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined): boolean {
    return proto3.util.equals(InvalidSignatureErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.DeniedErrorDetails
 */
export class DeniedErrorDetails extends Message<DeniedErrorDetails> {
  /**
   * @generated from field: code.transaction.v2.DeniedErrorDetails.Code code = 1;
   */
  code = DeniedErrorDetails_Code.UNSPECIFIED;

  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<DeniedErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DeniedErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(DeniedErrorDetails_Code) },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined, b: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined): boolean {
    return proto3.util.equals(DeniedErrorDetails, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.DeniedErrorDetails.Code
 */
export enum DeniedErrorDetails_Code {
  /**
   * Reason code not yet defined
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(DeniedErrorDetails_Code)
proto3.util.setEnumType(DeniedErrorDetails_Code, "code.transaction.v2.DeniedErrorDetails.Code", [
  { no: 0, name: "UNSPECIFIED" },
]);

/**
 * ExchangeData defines an amount of crypto with currency exchange data
 *
 * @generated from message code.transaction.v2.ExchangeData
 */
export class ExchangeData extends Message<ExchangeData> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon exchange rate. This might not be the same as the
   * actual exchange rate at the time of intent or fund transfer.
   *
   * @generated from field: double exchange_rate = 2;
   */
  exchangeRate = 0;

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 3;
   */
  nativeAmount = 0;

  /**
   * The exact amount of quarks to send. This will be used as the source of
   * truth for validating transaction transfer amounts.
   *
   * @generated from field: uint64 quarks = 4;
   */
  quarks = protoInt64.zero;

  /**
   * The crypto mint that is being operated against for the exchange.
   * For backwards compatibility, if no mint is set, then it is assumed
   * to be the core mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<ExchangeData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exchange_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeData {
    return new ExchangeData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeData | PlainMessage<ExchangeData> | undefined, b: ExchangeData | PlainMessage<ExchangeData> | undefined): boolean {
    return proto3.util.equals(ExchangeData, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ExchangeDataWithoutRate
 */
export class ExchangeDataWithoutRate extends Message<ExchangeDataWithoutRate> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  constructor(data?: PartialMessage<ExchangeDataWithoutRate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeDataWithoutRate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined, b: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined): boolean {
    return proto3.util.equals(ExchangeDataWithoutRate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SendLimit
 */
export class SendLimit extends Message<SendLimit> {
  /**
   * Remaining limit to apply on the next transaction
   *
   * @generated from field: float next_transaction = 1;
   */
  nextTransaction = 0;

  /**
   * Maximum allowed on a per-transaction basis
   *
   * @generated from field: float max_per_transaction = 2;
   */
  maxPerTransaction = 0;

  /**
   * Maximum allowed on a per-day basis
   *
   * @generated from field: float max_per_day = 3;
   */
  maxPerDay = 0;

  constructor(data?: PartialMessage<SendLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "max_per_day", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendLimit {
    return new SendLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJsonString(jsonString, options);
  }

  static equals(a: SendLimit | PlainMessage<SendLimit> | undefined, b: SendLimit | PlainMessage<SendLimit> | undefined): boolean {
    return proto3.util.equals(SendLimit, a, b);
  }
}

