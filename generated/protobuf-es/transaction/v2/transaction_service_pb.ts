// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file transaction/v2/transaction_service.proto (package code.transaction.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccountType, Blockhash, Hash, IntentId, Signature, SolanaAccountId, SolanaAddressLookupTable, SwapId, Transaction } from "../../common/v1/model_pb";

/**
 * @generated from enum code.transaction.v2.AirdropType
 */
export enum AirdropType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Reward for onboarding another user
   *
   * @generated from enum value: ONBOARDING_BONUS = 1;
   */
  ONBOARDING_BONUS = 1,

  /**
   * Airdrop for getting a user started with first crypto balance
   *
   * @generated from enum value: WELCOME_BONUS = 2;
   */
  WELCOME_BONUS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropType)
proto3.util.setEnumType(AirdropType, "code.transaction.v2.AirdropType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "ONBOARDING_BONUS" },
  { no: 2, name: "WELCOME_BONUS" },
]);

/**
 * @generated from enum code.transaction.v2.FundingSource
 */
export enum FundingSource {
  /**
   * @generated from enum value: FUNDING_SOURCE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: FUNDING_SOURCE_SUBMIT_INTENT = 1;
   */
  SUBMIT_INTENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(FundingSource)
proto3.util.setEnumType(FundingSource, "code.transaction.v2.FundingSource", [
  { no: 0, name: "FUNDING_SOURCE_UNKNOWN" },
  { no: 1, name: "FUNDING_SOURCE_SUBMIT_INTENT" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest
 */
export class SubmitIntentRequest extends Message<SubmitIntentRequest> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitActions submit_actions = 1;
     */
    value: SubmitIntentRequest_SubmitActions;
    case: "submitActions";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentRequest.SubmitSignatures submit_signatures = 2;
     */
    value: SubmitIntentRequest_SubmitSignatures;
    case: "submitSignatures";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "submit_actions", kind: "message", T: SubmitIntentRequest_SubmitActions, oneof: "request" },
    { no: 2, name: "submit_signatures", kind: "message", T: SubmitIntentRequest_SubmitSignatures, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest {
    return new SubmitIntentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined, b: SubmitIntentRequest | PlainMessage<SubmitIntentRequest> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitActions
 */
export class SubmitIntentRequest_SubmitActions extends Message<SubmitIntentRequest_SubmitActions> {
  /**
   * The globally unique client generated intent ID. Use the original intent
   * ID when operating on actions that mutate the intent.
   *
   * @generated from field: code.common.v1.IntentId id = 1;
   */
  id?: IntentId;

  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * Additional metadata that describes the high-level intention
   *
   * @generated from field: code.transaction.v2.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * The set of all ordered actions required to fulfill the intent
   *
   * @generated from field: repeated code.transaction.v2.Action actions = 4;
   */
  actions: Action[] = [];

  /**
   * The signature is of serialize(SubmitActions) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 5;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitActions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitActions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
    { no: 4, name: "actions", kind: "message", T: Action, repeated: true },
    { no: 5, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitActions {
    return new SubmitIntentRequest_SubmitActions().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined, b: SubmitIntentRequest_SubmitActions | PlainMessage<SubmitIntentRequest_SubmitActions> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitActions, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentRequest.SubmitSignatures
 */
export class SubmitIntentRequest_SubmitSignatures extends Message<SubmitIntentRequest_SubmitSignatures> {
  /**
   * The set of all signatures for each transaction or virtual instruction requiring
   * signature from the authority accounts.
   *
   * The signature for a transaction is for the marshalled transaction.
   * The signature for a virtual instruction is the hash of the marshalled instruction.
   *
   * @generated from field: repeated code.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  constructor(data?: PartialMessage<SubmitIntentRequest_SubmitSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentRequest.SubmitSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentRequest_SubmitSignatures {
    return new SubmitIntentRequest_SubmitSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined, b: SubmitIntentRequest_SubmitSignatures | PlainMessage<SubmitIntentRequest_SubmitSignatures> | undefined): boolean {
    return proto3.util.equals(SubmitIntentRequest_SubmitSignatures, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse
 */
export class SubmitIntentResponse extends Message<SubmitIntentResponse> {
  /**
   * @generated from oneof code.transaction.v2.SubmitIntentResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.ServerParameters server_parameters = 1;
     */
    value: SubmitIntentResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Success success = 2;
     */
    value: SubmitIntentResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SubmitIntentResponse.Error error = 3;
     */
    value: SubmitIntentResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubmitIntentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SubmitIntentResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SubmitIntentResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SubmitIntentResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse {
    return new SubmitIntentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined, b: SubmitIntentResponse | PlainMessage<SubmitIntentResponse> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.ServerParameters
 */
export class SubmitIntentResponse_ServerParameters extends Message<SubmitIntentResponse_ServerParameters> {
  /**
   * The set of all server paremeters required to fill missing transaction
   * or virtual instruction details. Server guarantees to provide a message
   * for each client action in an order consistent with the received action
   * list. 
   *
   * @generated from field: repeated code.transaction.v2.ServerParameter server_parameters = 1;
   */
  serverParameters: ServerParameter[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: ServerParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_ServerParameters {
    return new SubmitIntentResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined, b: SubmitIntentResponse_ServerParameters | PlainMessage<SubmitIntentResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Success
 */
export class SubmitIntentResponse_Success extends Message<SubmitIntentResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Success.Code code = 1;
   */
  code = SubmitIntentResponse_Success_Code.OK;

  constructor(data?: PartialMessage<SubmitIntentResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Success {
    return new SubmitIntentResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined, b: SubmitIntentResponse_Success | PlainMessage<SubmitIntentResponse_Success> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Success.Code
 */
export enum SubmitIntentResponse_Success_Code {
  /**
   * The intent was successfully created and is now scheduled.
   *
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Success_Code)
proto3.util.setEnumType(SubmitIntentResponse_Success_Code, "code.transaction.v2.SubmitIntentResponse.Success.Code", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.SubmitIntentResponse.Error
 */
export class SubmitIntentResponse_Error extends Message<SubmitIntentResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SubmitIntentResponse.Error.Code code = 1;
   */
  code = SubmitIntentResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SubmitIntentResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SubmitIntentResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SubmitIntentResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitIntentResponse_Error {
    return new SubmitIntentResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined, b: SubmitIntentResponse_Error | PlainMessage<SubmitIntentResponse_Error> | undefined): boolean {
    return proto3.util.equals(SubmitIntentResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SubmitIntentResponse.Error.Code
 */
export enum SubmitIntentResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * The intent is invalid.
   *
   * @generated from enum value: INVALID_INTENT = 1;
   */
  INVALID_INTENT = 1,

  /**
   * There is an issue with provided signatures.
   *
   * @generated from enum value: SIGNATURE_ERROR = 2;
   */
  SIGNATURE_ERROR = 2,

  /**
   * Server detected client has stale state.
   *
   * @generated from enum value: STALE_STATE = 3;
   */
  STALE_STATE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SubmitIntentResponse_Error_Code)
proto3.util.setEnumType(SubmitIntentResponse_Error_Code, "code.transaction.v2.SubmitIntentResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "INVALID_INTENT" },
  { no: 2, name: "SIGNATURE_ERROR" },
  { no: 3, name: "STALE_STATE" },
]);

/**
 * @generated from message code.transaction.v2.GetIntentMetadataRequest
 */
export class GetIntentMetadataRequest extends Message<GetIntentMetadataRequest> {
  /**
   * The intent ID to query
   *
   * @generated from field: code.common.v1.IntentId intent_id = 1;
   */
  intentId?: IntentId;

  /**
   * The verified owner account public key when not signing with the rendezvous
   * key. Only owner accounts involved in the intent can access the metadata.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetIntentStatusRequest) without this field set
   * using the private key of the rendezvous or owner account. This provides an
   * authentication mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetIntentMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intent_id", kind: "message", T: IntentId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataRequest {
    return new GetIntentMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined, b: GetIntentMetadataRequest | PlainMessage<GetIntentMetadataRequest> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetIntentMetadataResponse
 */
export class GetIntentMetadataResponse extends Message<GetIntentMetadataResponse> {
  /**
   * @generated from field: code.transaction.v2.GetIntentMetadataResponse.Result result = 1;
   */
  result = GetIntentMetadataResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<GetIntentMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetIntentMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetIntentMetadataResponse_Result) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntentMetadataResponse {
    return new GetIntentMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined, b: GetIntentMetadataResponse | PlainMessage<GetIntentMetadataResponse> | undefined): boolean {
    return proto3.util.equals(GetIntentMetadataResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetIntentMetadataResponse.Result
 */
export enum GetIntentMetadataResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetIntentMetadataResponse_Result)
proto3.util.setEnumType(GetIntentMetadataResponse_Result, "code.transaction.v2.GetIntentMetadataResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.GetLimitsRequest
 */
export class GetLimitsRequest extends Message<GetLimitsRequest> {
  /**
   * The owner account whose limits will be calculated. Any other owner accounts
   * linked with the same identity of the owner will also be applied.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetLimitsRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * All transactions starting at this time will be incorporated into the consumed
   * limit calculation. Clients should set this to the start of the current day in
   * the client's current time zone (because server has no knowledge of this atm).
   *
   * @generated from field: google.protobuf.Timestamp consumed_since = 3;
   */
  consumedSince?: Timestamp;

  constructor(data?: PartialMessage<GetLimitsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "consumed_since", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsRequest {
    return new GetLimitsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined, b: GetLimitsRequest | PlainMessage<GetLimitsRequest> | undefined): boolean {
    return proto3.util.equals(GetLimitsRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetLimitsResponse
 */
export class GetLimitsResponse extends Message<GetLimitsResponse> {
  /**
   * @generated from field: code.transaction.v2.GetLimitsResponse.Result result = 1;
   */
  result = GetLimitsResponse_Result.OK;

  /**
   * Send limits keyed by currency
   *
   * @generated from field: map<string, code.transaction.v2.SendLimit> send_limits_by_currency = 2;
   */
  sendLimitsByCurrency: { [key: string]: SendLimit } = {};

  /**
   * The amount of USD transacted since the consumption timestamp
   *
   * @generated from field: double usd_transacted = 6;
   */
  usdTransacted = 0;

  constructor(data?: PartialMessage<GetLimitsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetLimitsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetLimitsResponse_Result) },
    { no: 2, name: "send_limits_by_currency", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SendLimit} },
    { no: 6, name: "usd_transacted", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLimitsResponse {
    return new GetLimitsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined, b: GetLimitsResponse | PlainMessage<GetLimitsResponse> | undefined): boolean {
    return proto3.util.equals(GetLimitsResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetLimitsResponse.Result
 */
export enum GetLimitsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(GetLimitsResponse_Result)
proto3.util.setEnumType(GetLimitsResponse_Result, "code.transaction.v2.GetLimitsResponse.Result", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountRequest
 */
export class CanWithdrawToAccountRequest extends Message<CanWithdrawToAccountRequest> {
  /**
   * The destination account attempted to be withdrawn to. Can be an owner or
   * token account.
   *
   * @generated from field: code.common.v1.SolanaAccountId account = 1;
   */
  account?: SolanaAccountId;

  /**
   * The mint that the withdraw will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 2;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<CanWithdrawToAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: SolanaAccountId },
    { no: 2, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountRequest {
    return new CanWithdrawToAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined, b: CanWithdrawToAccountRequest | PlainMessage<CanWithdrawToAccountRequest> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.CanWithdrawToAccountResponse
 */
export class CanWithdrawToAccountResponse extends Message<CanWithdrawToAccountResponse> {
  /**
   * Server-controlled flag to indicate if the account can be withdrawn to.
   * There are several reasons server may deny it, including:
   *  - Wrong type of Code account
   *  - Unsupported external account type (eg. token account but of the wrong mint)
   * This is guaranteed to be false when account_type = Unknown.
   *
   * @generated from field: bool is_valid_payment_destination = 1;
   */
  isValidPaymentDestination = false;

  /**
   * Metadata so the client knows how to withdraw to the account. Server cannot
   * provide precalculated addresses in this response to maintain non-custodial
   * status.
   *
   * @generated from field: code.transaction.v2.CanWithdrawToAccountResponse.AccountType account_type = 2;
   */
  accountType = CanWithdrawToAccountResponse_AccountType.Unknown;

  /**
   * ATA requires initialization before the withdrawal can occur. Server may not
   * subsidize the account creation, so a fee may be required.
   *
   * @generated from field: bool requires_initialization = 3;
   */
  requiresInitialization = false;

  /**
   * The CREATE_ON_SEND_WITHDRAWAL fee, in USD, that must be paid in order to
   * submit a withdrawal to subsidize the creation of the account at time of
   * send. The user must explicitly agree to this fee amount before submitting
   * the intent.
   *
   * This can be set when requires_initialization = true if server decides to
   * not subsidize the token account creation.
   *
   * Note: The fee is always paid in the target mint.
   *
   * @generated from field: code.transaction.v2.ExchangeDataWithoutRate fee_amount = 4;
   */
  feeAmount?: ExchangeDataWithoutRate;

  constructor(data?: PartialMessage<CanWithdrawToAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.CanWithdrawToAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_valid_payment_destination", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "account_type", kind: "enum", T: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType) },
    { no: 3, name: "requires_initialization", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "fee_amount", kind: "message", T: ExchangeDataWithoutRate },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanWithdrawToAccountResponse {
    return new CanWithdrawToAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined, b: CanWithdrawToAccountResponse | PlainMessage<CanWithdrawToAccountResponse> | undefined): boolean {
    return proto3.util.equals(CanWithdrawToAccountResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.CanWithdrawToAccountResponse.AccountType
 */
export enum CanWithdrawToAccountResponse_AccountType {
  /**
   * Server cannot determine
   *
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * Client uses the address as is in SubmitIntent
   *
   * @generated from enum value: TokenAccount = 1;
   */
  TokenAccount = 1,

  /**
   * Client locally derives the ATA to use in SubmitIntent
   *
   * @generated from enum value: OwnerAccount = 2;
   */
  OwnerAccount = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CanWithdrawToAccountResponse_AccountType)
proto3.util.setEnumType(CanWithdrawToAccountResponse_AccountType, "code.transaction.v2.CanWithdrawToAccountResponse.AccountType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "TokenAccount" },
  { no: 2, name: "OwnerAccount" },
]);

/**
 * @generated from message code.transaction.v2.AirdropRequest
 */
export class AirdropRequest extends Message<AirdropRequest> {
  /**
   * The type of airdrop to claim
   *
   * @generated from field: code.transaction.v2.AirdropType airdrop_type = 1;
   */
  airdropType = AirdropType.UNKNOWN;

  /**
   * The owner account to airdrop core mint tokens to
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(AirdropRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<AirdropRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "airdrop_type", kind: "enum", T: proto3.getEnumType(AirdropType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropRequest {
    return new AirdropRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropRequest {
    return new AirdropRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropRequest | PlainMessage<AirdropRequest> | undefined, b: AirdropRequest | PlainMessage<AirdropRequest> | undefined): boolean {
    return proto3.util.equals(AirdropRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.AirdropResponse
 */
export class AirdropResponse extends Message<AirdropResponse> {
  /**
   * @generated from field: code.transaction.v2.AirdropResponse.Result result = 1;
   */
  result = AirdropResponse_Result.OK;

  /**
   * Exchange data for the amount of core mint tokens airdropped when successful
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  constructor(data?: PartialMessage<AirdropResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.AirdropResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(AirdropResponse_Result) },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropResponse {
    return new AirdropResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropResponse {
    return new AirdropResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropResponse | PlainMessage<AirdropResponse> | undefined, b: AirdropResponse | PlainMessage<AirdropResponse> | undefined): boolean {
    return proto3.util.equals(AirdropResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.AirdropResponse.Result
 */
export enum AirdropResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * Airdrops are unavailable
   *
   * @generated from enum value: UNAVAILABLE = 1;
   */
  UNAVAILABLE = 1,

  /**
   * The airdrop has already been claimed by the owner
   *
   * @generated from enum value: ALREADY_CLAIMED = 2;
   */
  ALREADY_CLAIMED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AirdropResponse_Result)
proto3.util.setEnumType(AirdropResponse_Result, "code.transaction.v2.AirdropResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "UNAVAILABLE" },
  { no: 2, name: "ALREADY_CLAIMED" },
]);

/**
 * @generated from message code.transaction.v2.VoidGiftCardRequest
 */
export class VoidGiftCardRequest extends Message<VoidGiftCardRequest> {
  /**
   * The owner account that issued the gift card account
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The vault of the gift card account to void
   *
   * @generated from field: code.common.v1.SolanaAccountId gift_card_vault = 2;
   */
  giftCardVault?: SolanaAccountId;

  /**
   * The signature is of serialize(VoidGiftCardRequest) without this field set using
   * the private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<VoidGiftCardRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "gift_card_vault", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardRequest {
    return new VoidGiftCardRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined, b: VoidGiftCardRequest | PlainMessage<VoidGiftCardRequest> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.VoidGiftCardResponse
 */
export class VoidGiftCardResponse extends Message<VoidGiftCardResponse> {
  /**
   * @generated from field: code.transaction.v2.VoidGiftCardResponse.Result result = 1;
   */
  result = VoidGiftCardResponse_Result.OK;

  constructor(data?: PartialMessage<VoidGiftCardResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VoidGiftCardResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(VoidGiftCardResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoidGiftCardResponse {
    return new VoidGiftCardResponse().fromJsonString(jsonString, options);
  }

  static equals(a: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined, b: VoidGiftCardResponse | PlainMessage<VoidGiftCardResponse> | undefined): boolean {
    return proto3.util.equals(VoidGiftCardResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.VoidGiftCardResponse.Result
 */
export enum VoidGiftCardResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * The owner account didn't issue the gift card accoun
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * A different owner account than the issuer claimed the gift card
   *
   * @generated from enum value: CLAIMED_BY_OTHER_USER = 2;
   */
  CLAIMED_BY_OTHER_USER = 2,

  /**
   * The gift card doesn't exist
   *
   * @generated from enum value: NOT_FOUND = 3;
   */
  NOT_FOUND = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(VoidGiftCardResponse_Result)
proto3.util.setEnumType(VoidGiftCardResponse_Result, "code.transaction.v2.VoidGiftCardResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "CLAIMED_BY_OTHER_USER" },
  { no: 3, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.StartSwapRequest
 */
export class StartSwapRequest extends Message<StartSwapRequest> {
  /**
   * @generated from oneof code.transaction.v2.StartSwapRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.StartSwapRequest.Start start = 1;
     */
    value: StartSwapRequest_Start;
    case: "start";
  } | {
    /**
     * @generated from field: code.transaction.v2.StartSwapRequest.SubmitSignature submit_signature = 2;
     */
    value: StartSwapRequest_SubmitSignature;
    case: "submitSignature";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartSwapRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: StartSwapRequest_Start, oneof: "request" },
    { no: 2, name: "submit_signature", kind: "message", T: StartSwapRequest_SubmitSignature, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapRequest {
    return new StartSwapRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapRequest {
    return new StartSwapRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapRequest {
    return new StartSwapRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapRequest | PlainMessage<StartSwapRequest> | undefined, b: StartSwapRequest | PlainMessage<StartSwapRequest> | undefined): boolean {
    return proto3.util.equals(StartSwapRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapRequest.Start
 */
export class StartSwapRequest_Start extends Message<StartSwapRequest_Start> {
  /**
   * @generated from oneof code.transaction.v2.StartSwapRequest.Start.kind
   */
  kind: {
    /**
     * @generated from field: code.transaction.v2.StartSwapRequest.Start.CurrencyCreator currency_creator = 1;
     */
    value: StartSwapRequest_Start_CurrencyCreator;
    case: "currencyCreator";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The owner account starting the swap
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 9;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(StartSwapRequest.Start) without this field
   * set using the  private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 10;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<StartSwapRequest_Start>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapRequest.Start";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_creator", kind: "message", T: StartSwapRequest_Start_CurrencyCreator, oneof: "kind" },
    { no: 9, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 10, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapRequest_Start {
    return new StartSwapRequest_Start().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapRequest_Start {
    return new StartSwapRequest_Start().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapRequest_Start {
    return new StartSwapRequest_Start().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapRequest_Start | PlainMessage<StartSwapRequest_Start> | undefined, b: StartSwapRequest_Start | PlainMessage<StartSwapRequest_Start> | undefined): boolean {
    return proto3.util.equals(StartSwapRequest_Start, a, b);
  }
}

/**
 * Server parameters for starting swaps against the Currency Creator program
 *
 * @generated from message code.transaction.v2.StartSwapRequest.Start.CurrencyCreator
 */
export class StartSwapRequest_Start_CurrencyCreator extends Message<StartSwapRequest_Start_CurrencyCreator> {
  /**
   * The unique ID for this swap randomly generated on client
   *
   * @generated from field: code.common.v1.SwapId id = 1;
   */
  id?: SwapId;

  /**
   * The source mint that will be swapped from
   *
   * @generated from field: code.common.v1.SolanaAccountId from_mint = 2;
   */
  fromMint?: SolanaAccountId;

  /**
   * The destination mint that will be swapped from
   *
   * @generated from field: code.common.v1.SolanaAccountId to_mint = 3;
   */
  toMint?: SolanaAccountId;

  /**
   * The amount to swap from the source mint in quarks.
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * Where "amount" of "from_mint" will be sent from to the VM swap PDA
   *
   * @generated from field: code.transaction.v2.FundingSource funding_source = 5;
   */
  fundingSource = FundingSource.UNKNOWN;

  /**
   * The ID of the "transaction" to lookup funding state.
   *
   * For SWAP_FUNDING_SOURCE_SUBMIT_INTENT, this value is the base58 encoded intent ID.
   *
   * @generated from field: string funding_id = 6;
   */
  fundingId = "";

  constructor(data?: PartialMessage<StartSwapRequest_Start_CurrencyCreator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapRequest.Start.CurrencyCreator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: SwapId },
    { no: 2, name: "from_mint", kind: "message", T: SolanaAccountId },
    { no: 3, name: "to_mint", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "funding_source", kind: "enum", T: proto3.getEnumType(FundingSource) },
    { no: 6, name: "funding_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapRequest_Start_CurrencyCreator {
    return new StartSwapRequest_Start_CurrencyCreator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapRequest_Start_CurrencyCreator {
    return new StartSwapRequest_Start_CurrencyCreator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapRequest_Start_CurrencyCreator {
    return new StartSwapRequest_Start_CurrencyCreator().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapRequest_Start_CurrencyCreator | PlainMessage<StartSwapRequest_Start_CurrencyCreator> | undefined, b: StartSwapRequest_Start_CurrencyCreator | PlainMessage<StartSwapRequest_Start_CurrencyCreator> | undefined): boolean {
    return proto3.util.equals(StartSwapRequest_Start_CurrencyCreator, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapRequest.SubmitSignature
 */
export class StartSwapRequest_SubmitSignature extends Message<StartSwapRequest_SubmitSignature> {
  /**
   * The signature of the verified swap metadata
   *
   * @generated from field: code.common.v1.Signature signature = 1;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<StartSwapRequest_SubmitSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapRequest.SubmitSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapRequest_SubmitSignature {
    return new StartSwapRequest_SubmitSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapRequest_SubmitSignature {
    return new StartSwapRequest_SubmitSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapRequest_SubmitSignature {
    return new StartSwapRequest_SubmitSignature().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapRequest_SubmitSignature | PlainMessage<StartSwapRequest_SubmitSignature> | undefined, b: StartSwapRequest_SubmitSignature | PlainMessage<StartSwapRequest_SubmitSignature> | undefined): boolean {
    return proto3.util.equals(StartSwapRequest_SubmitSignature, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapResponse
 */
export class StartSwapResponse extends Message<StartSwapResponse> {
  /**
   * @generated from oneof code.transaction.v2.StartSwapResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.StartSwapResponse.ServerParameters server_parameters = 1;
     */
    value: StartSwapResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.StartSwapResponse.Success success = 2;
     */
    value: StartSwapResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.StartSwapResponse.Error error = 3;
     */
    value: StartSwapResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartSwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: StartSwapResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: StartSwapResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: StartSwapResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapResponse {
    return new StartSwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapResponse {
    return new StartSwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapResponse {
    return new StartSwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapResponse | PlainMessage<StartSwapResponse> | undefined, b: StartSwapResponse | PlainMessage<StartSwapResponse> | undefined): boolean {
    return proto3.util.equals(StartSwapResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapResponse.ServerParameters
 */
export class StartSwapResponse_ServerParameters extends Message<StartSwapResponse_ServerParameters> {
  /**
   * @generated from oneof code.transaction.v2.StartSwapResponse.ServerParameters.kind
   */
  kind: {
    /**
     * @generated from field: code.transaction.v2.StartSwapResponse.ServerParameters.CurrencyCreator currency_creator = 1;
     */
    value: StartSwapResponse_ServerParameters_CurrencyCreator;
    case: "currencyCreator";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartSwapResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_creator", kind: "message", T: StartSwapResponse_ServerParameters_CurrencyCreator, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapResponse_ServerParameters {
    return new StartSwapResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapResponse_ServerParameters {
    return new StartSwapResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapResponse_ServerParameters {
    return new StartSwapResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapResponse_ServerParameters | PlainMessage<StartSwapResponse_ServerParameters> | undefined, b: StartSwapResponse_ServerParameters | PlainMessage<StartSwapResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(StartSwapResponse_ServerParameters, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapResponse.ServerParameters.CurrencyCreator
 */
export class StartSwapResponse_ServerParameters_CurrencyCreator extends Message<StartSwapResponse_ServerParameters_CurrencyCreator> {
  /**
   * The nonce that is reserved for use in the swap transaction
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 1;
   */
  nonce?: SolanaAccountId;

  /**
   * The blockhash that is reserved for use in the swap transaction
   *
   * @generated from field: code.common.v1.Blockhash blockhash = 2;
   */
  blockhash?: Blockhash;

  constructor(data?: PartialMessage<StartSwapResponse_ServerParameters_CurrencyCreator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapResponse.ServerParameters.CurrencyCreator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "message", T: SolanaAccountId },
    { no: 2, name: "blockhash", kind: "message", T: Blockhash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapResponse_ServerParameters_CurrencyCreator {
    return new StartSwapResponse_ServerParameters_CurrencyCreator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapResponse_ServerParameters_CurrencyCreator {
    return new StartSwapResponse_ServerParameters_CurrencyCreator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapResponse_ServerParameters_CurrencyCreator {
    return new StartSwapResponse_ServerParameters_CurrencyCreator().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapResponse_ServerParameters_CurrencyCreator | PlainMessage<StartSwapResponse_ServerParameters_CurrencyCreator> | undefined, b: StartSwapResponse_ServerParameters_CurrencyCreator | PlainMessage<StartSwapResponse_ServerParameters_CurrencyCreator> | undefined): boolean {
    return proto3.util.equals(StartSwapResponse_ServerParameters_CurrencyCreator, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.StartSwapResponse.Success
 */
export class StartSwapResponse_Success extends Message<StartSwapResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.StartSwapResponse.Success.Code code = 1;
   */
  code = StartSwapResponse_Success_Code.OK;

  constructor(data?: PartialMessage<StartSwapResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(StartSwapResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapResponse_Success {
    return new StartSwapResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapResponse_Success {
    return new StartSwapResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapResponse_Success {
    return new StartSwapResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapResponse_Success | PlainMessage<StartSwapResponse_Success> | undefined, b: StartSwapResponse_Success | PlainMessage<StartSwapResponse_Success> | undefined): boolean {
    return proto3.util.equals(StartSwapResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.StartSwapResponse.Success.Code
 */
export enum StartSwapResponse_Success_Code {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(StartSwapResponse_Success_Code)
proto3.util.setEnumType(StartSwapResponse_Success_Code, "code.transaction.v2.StartSwapResponse.Success.Code", [
  { no: 0, name: "OK" },
]);

/**
 * @generated from message code.transaction.v2.StartSwapResponse.Error
 */
export class StartSwapResponse_Error extends Message<StartSwapResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.StartSwapResponse.Error.Code code = 1;
   */
  code = StartSwapResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<StartSwapResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.StartSwapResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(StartSwapResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartSwapResponse_Error {
    return new StartSwapResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartSwapResponse_Error {
    return new StartSwapResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartSwapResponse_Error {
    return new StartSwapResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: StartSwapResponse_Error | PlainMessage<StartSwapResponse_Error> | undefined, b: StartSwapResponse_Error | PlainMessage<StartSwapResponse_Error> | undefined): boolean {
    return proto3.util.equals(StartSwapResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.StartSwapResponse.Error.Code
 */
export enum StartSwapResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * There is an issue with the provided signature
   *
   * @generated from enum value: SIGNATURE_ERROR = 1;
   */
  SIGNATURE_ERROR = 1,

  /**
   * The swap metadata failed server-side validation
   *
   * @generated from enum value: INVALID_SWAP = 2;
   */
  INVALID_SWAP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StartSwapResponse_Error_Code)
proto3.util.setEnumType(StartSwapResponse_Error_Code, "code.transaction.v2.StartSwapResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "SIGNATURE_ERROR" },
  { no: 2, name: "INVALID_SWAP" },
]);

/**
 * @generated from message code.transaction.v2.GetSwapRequest
 */
export class GetSwapRequest extends Message<GetSwapRequest> {
  /**
   * @generated from field: code.common.v1.SwapId id = 1;
   */
  id?: SwapId;

  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetSwapRequest) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetSwapRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetSwapRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: SwapId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSwapRequest {
    return new GetSwapRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSwapRequest {
    return new GetSwapRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSwapRequest {
    return new GetSwapRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSwapRequest | PlainMessage<GetSwapRequest> | undefined, b: GetSwapRequest | PlainMessage<GetSwapRequest> | undefined): boolean {
    return proto3.util.equals(GetSwapRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetSwapResponse
 */
export class GetSwapResponse extends Message<GetSwapResponse> {
  /**
   * @generated from field: code.transaction.v2.GetSwapResponse.Result result = 1;
   */
  result = GetSwapResponse_Result.OK;

  /**
   * @generated from field: code.transaction.v2.SwapMetadata swap = 2;
   */
  swap?: SwapMetadata;

  constructor(data?: PartialMessage<GetSwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetSwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetSwapResponse_Result) },
    { no: 2, name: "swap", kind: "message", T: SwapMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSwapResponse {
    return new GetSwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSwapResponse {
    return new GetSwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSwapResponse {
    return new GetSwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSwapResponse | PlainMessage<GetSwapResponse> | undefined, b: GetSwapResponse | PlainMessage<GetSwapResponse> | undefined): boolean {
    return proto3.util.equals(GetSwapResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetSwapResponse.Result
 */
export enum GetSwapResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * @generated from enum value: DENIED = 2;
   */
  DENIED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GetSwapResponse_Result)
proto3.util.setEnumType(GetSwapResponse_Result, "code.transaction.v2.GetSwapResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
  { no: 2, name: "DENIED" },
]);

/**
 * @generated from message code.transaction.v2.GetPendingSwapsRequest
 */
export class GetPendingSwapsRequest extends Message<GetPendingSwapsRequest> {
  /**
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The signature is of serialize(GetPendingSwapsRequest) without this field set
   * using the private key of the owner account. This provides an authentication
   * mechanism to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<GetPendingSwapsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPendingSwapsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPendingSwapsRequest {
    return new GetPendingSwapsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPendingSwapsRequest {
    return new GetPendingSwapsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPendingSwapsRequest {
    return new GetPendingSwapsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPendingSwapsRequest | PlainMessage<GetPendingSwapsRequest> | undefined, b: GetPendingSwapsRequest | PlainMessage<GetPendingSwapsRequest> | undefined): boolean {
    return proto3.util.equals(GetPendingSwapsRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.GetPendingSwapsResponse
 */
export class GetPendingSwapsResponse extends Message<GetPendingSwapsResponse> {
  /**
   * @generated from field: code.transaction.v2.GetPendingSwapsResponse.Result result = 1;
   */
  result = GetPendingSwapsResponse_Result.OK;

  /**
   * @generated from field: repeated code.transaction.v2.SwapMetadata swaps = 2;
   */
  swaps: SwapMetadata[] = [];

  constructor(data?: PartialMessage<GetPendingSwapsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.GetPendingSwapsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(GetPendingSwapsResponse_Result) },
    { no: 2, name: "swaps", kind: "message", T: SwapMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPendingSwapsResponse {
    return new GetPendingSwapsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPendingSwapsResponse {
    return new GetPendingSwapsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPendingSwapsResponse {
    return new GetPendingSwapsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPendingSwapsResponse | PlainMessage<GetPendingSwapsResponse> | undefined, b: GetPendingSwapsResponse | PlainMessage<GetPendingSwapsResponse> | undefined): boolean {
    return proto3.util.equals(GetPendingSwapsResponse, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.GetPendingSwapsResponse.Result
 */
export enum GetPendingSwapsResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(GetPendingSwapsResponse_Result)
proto3.util.setEnumType(GetPendingSwapsResponse_Result, "code.transaction.v2.GetPendingSwapsResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "NOT_FOUND" },
]);

/**
 * @generated from message code.transaction.v2.SwapRequest
 */
export class SwapRequest extends Message<SwapRequest> {
  /**
   * @generated from oneof code.transaction.v2.SwapRequest.request
   */
  request: {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.Initiate initiate = 1;
     */
    value: SwapRequest_Initiate;
    case: "initiate";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.SubmitSignatures submit_signatures = 2;
     */
    value: SwapRequest_SubmitSignatures;
    case: "submitSignatures";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "initiate", kind: "message", T: SwapRequest_Initiate, oneof: "request" },
    { no: 2, name: "submit_signatures", kind: "message", T: SwapRequest_SubmitSignatures, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest {
    return new SwapRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest {
    return new SwapRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest {
    return new SwapRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest | PlainMessage<SwapRequest> | undefined, b: SwapRequest | PlainMessage<SwapRequest> | undefined): boolean {
    return proto3.util.equals(SwapRequest, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.Initiate
 */
export class SwapRequest_Initiate extends Message<SwapRequest_Initiate> {
  /**
   * @generated from oneof code.transaction.v2.SwapRequest.Initiate.kind
   */
  kind: {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.Initiate.Stateless stateless = 1;
     */
    value: SwapRequest_Initiate_Stateless;
    case: "stateless";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapRequest.Initiate.Stateful stateful = 2;
     */
    value: SwapRequest_Initiate_Stateful;
    case: "stateful";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapRequest_Initiate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.Initiate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stateless", kind: "message", T: SwapRequest_Initiate_Stateless, oneof: "kind" },
    { no: 2, name: "stateful", kind: "message", T: SwapRequest_Initiate_Stateful, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_Initiate {
    return new SwapRequest_Initiate().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_Initiate | PlainMessage<SwapRequest_Initiate> | undefined, b: SwapRequest_Initiate | PlainMessage<SwapRequest_Initiate> | undefined): boolean {
    return proto3.util.equals(SwapRequest_Initiate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.Initiate.Stateless
 */
export class SwapRequest_Initiate_Stateless extends Message<SwapRequest_Initiate_Stateless> {
  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 1;
   */
  owner?: SolanaAccountId;

  /**
   * The source mint that will be swapped from
   *
   * @generated from field: code.common.v1.SolanaAccountId from_mint = 2;
   */
  fromMint?: SolanaAccountId;

  /**
   * The destination mint that will be swapped to
   *
   * @generated from field: code.common.v1.SolanaAccountId to_mint = 3;
   */
  toMint?: SolanaAccountId;

  /**
   * The amount to swap from the source mint in quarks.
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * The user authority account that will sign to authorize the swap.
   *
   * For Currency Creator program buy/sell flows, this should be a random one-time use account.
   *
   * @generated from field: code.common.v1.SolanaAccountId swap_authority = 5;
   */
  swapAuthority?: SolanaAccountId;

  /**
   * Whether the client wants the RPC to wait for blockchain status. If false,
   * then the RPC will return Success when the swap is submitted to the blockchain.
   * Otherwise, the RPC will observe and report back the status of the transaction.
   *
   * @generated from field: bool wait_for_blockchain_status = 6;
   */
  waitForBlockchainStatus = false;

  /**
   * The signature is of serialize(Stateless) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 7;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SwapRequest_Initiate_Stateless>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.Initiate.Stateless";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "from_mint", kind: "message", T: SolanaAccountId },
    { no: 3, name: "to_mint", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "swap_authority", kind: "message", T: SolanaAccountId },
    { no: 6, name: "wait_for_blockchain_status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_Initiate_Stateless {
    return new SwapRequest_Initiate_Stateless().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_Initiate_Stateless {
    return new SwapRequest_Initiate_Stateless().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_Initiate_Stateless {
    return new SwapRequest_Initiate_Stateless().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_Initiate_Stateless | PlainMessage<SwapRequest_Initiate_Stateless> | undefined, b: SwapRequest_Initiate_Stateless | PlainMessage<SwapRequest_Initiate_Stateless> | undefined): boolean {
    return proto3.util.equals(SwapRequest_Initiate_Stateless, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.Initiate.Stateful
 */
export class SwapRequest_Initiate_Stateful extends Message<SwapRequest_Initiate_Stateful> {
  /**
   * The ID of the swap to execute
   *
   * @generated from field: code.common.v1.SwapId swap_id = 1;
   */
  swapId?: SwapId;

  /**
   * The verified owner account public key
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The user authority account that will sign to authorize the swap.
   *
   * For Currency Creator program buy/sell flows, this should be a random one-time use account.
   *
   * @generated from field: code.common.v1.SolanaAccountId swap_authority = 3;
   */
  swapAuthority?: SolanaAccountId;

  /**
   * The signature is of serialize(Stateful) without this field set using the
   * private key of the owner account. This provides an authentication mechanism
   * to the RPC.
   *
   * @generated from field: code.common.v1.Signature signature = 4;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SwapRequest_Initiate_Stateful>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.Initiate.Stateful";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_id", kind: "message", T: SwapId },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "swap_authority", kind: "message", T: SolanaAccountId },
    { no: 4, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_Initiate_Stateful {
    return new SwapRequest_Initiate_Stateful().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_Initiate_Stateful {
    return new SwapRequest_Initiate_Stateful().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_Initiate_Stateful {
    return new SwapRequest_Initiate_Stateful().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_Initiate_Stateful | PlainMessage<SwapRequest_Initiate_Stateful> | undefined, b: SwapRequest_Initiate_Stateful | PlainMessage<SwapRequest_Initiate_Stateful> | undefined): boolean {
    return proto3.util.equals(SwapRequest_Initiate_Stateful, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapRequest.SubmitSignatures
 */
export class SwapRequest_SubmitSignatures extends Message<SwapRequest_SubmitSignatures> {
  /**
   * The signatures for the locally constructed swap transaction
   *
   * @generated from field: repeated code.common.v1.Signature signatures = 1;
   */
  signatures: Signature[] = [];

  constructor(data?: PartialMessage<SwapRequest_SubmitSignatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapRequest.SubmitSignatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signatures", kind: "message", T: Signature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapRequest_SubmitSignatures {
    return new SwapRequest_SubmitSignatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapRequest_SubmitSignatures {
    return new SwapRequest_SubmitSignatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapRequest_SubmitSignatures {
    return new SwapRequest_SubmitSignatures().fromJsonString(jsonString, options);
  }

  static equals(a: SwapRequest_SubmitSignatures | PlainMessage<SwapRequest_SubmitSignatures> | undefined, b: SwapRequest_SubmitSignatures | PlainMessage<SwapRequest_SubmitSignatures> | undefined): boolean {
    return proto3.util.equals(SwapRequest_SubmitSignatures, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse
 */
export class SwapResponse extends Message<SwapResponse> {
  /**
   * @generated from oneof code.transaction.v2.SwapResponse.response
   */
  response: {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.ServerParameters server_parameters = 1;
     */
    value: SwapResponse_ServerParameters;
    case: "serverParameters";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.Success success = 2;
     */
    value: SwapResponse_Success;
    case: "success";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.Error error = 3;
     */
    value: SwapResponse_Error;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_parameters", kind: "message", T: SwapResponse_ServerParameters, oneof: "response" },
    { no: 2, name: "success", kind: "message", T: SwapResponse_Success, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: SwapResponse_Error, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse {
    return new SwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse {
    return new SwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse {
    return new SwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse | PlainMessage<SwapResponse> | undefined, b: SwapResponse | PlainMessage<SwapResponse> | undefined): boolean {
    return proto3.util.equals(SwapResponse, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse.ServerParameters
 */
export class SwapResponse_ServerParameters extends Message<SwapResponse_ServerParameters> {
  /**
   * @generated from oneof code.transaction.v2.SwapResponse.ServerParameters.kind
   */
  kind: {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateless currency_creator_stateless = 1;
     */
    value: SwapResponse_ServerParameters_CurrencyCreatorStateless;
    case: "currencyCreatorStateless";
  } | {
    /**
     * @generated from field: code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateful currency_creator_stateful = 2;
     */
    value: SwapResponse_ServerParameters_CurrencyCreatorStateful;
    case: "currencyCreatorStateful";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SwapResponse_ServerParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.ServerParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_creator_stateless", kind: "message", T: SwapResponse_ServerParameters_CurrencyCreatorStateless, oneof: "kind" },
    { no: 2, name: "currency_creator_stateful", kind: "message", T: SwapResponse_ServerParameters_CurrencyCreatorStateful, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters {
    return new SwapResponse_ServerParameters().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_ServerParameters | PlainMessage<SwapResponse_ServerParameters> | undefined, b: SwapResponse_ServerParameters | PlainMessage<SwapResponse_ServerParameters> | undefined): boolean {
    return proto3.util.equals(SwapResponse_ServerParameters, a, b);
  }
}

/**
 * Server parameters when executing stateless buy/sell flows against the
 * Currency Creator program
 *
 * Note: The transaction and instruction formats are nearly identical to
 * the stateful flow, except the system::AdvanceNonce instruction is
 * ommitted in favour of using a latest blockhash.
 *
 * Note: This will be deprecated in favour of the stateful version. For
 * PoC of swap flow only.
 *
 * @generated from message code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateless
 */
export class SwapResponse_ServerParameters_CurrencyCreatorStateless extends Message<SwapResponse_ServerParameters_CurrencyCreatorStateless> {
  /**
   * Subisdizer account that will be paying for the swap
   *
   * @generated from field: code.common.v1.SolanaAccountId payer = 1;
   */
  payer?: SolanaAccountId;

  /**
   * Recent blockhash
   *
   * @generated from field: code.common.v1.Blockhash recent_blockhash = 2;
   */
  recentBlockhash?: Blockhash;

  /**
   * ALTs that should be used when constructing the versioned transaction
   *
   * @generated from field: repeated code.common.v1.SolanaAddressLookupTable alts = 3;
   */
  alts: SolanaAddressLookupTable[] = [];

  /**
   * Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint32 compute_unit_limit = 4;
   */
  computeUnitLimit = 0;

  /**
   * Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint64 compute_unit_price = 5;
   */
  computeUnitPrice = protoInt64.zero;

  /**
   * Value provided into the Memo::Memo instruction. If the value length is 0,
   * then the instruction can be omitted.
   *
   * @generated from field: string memo_value = 6;
   */
  memoValue = "";

  /**
   * The memory account where the destination virtual Timelock account lives
   *
   * @generated from field: code.common.v1.SolanaAccountId memory_account = 7;
   */
  memoryAccount?: SolanaAccountId;

  /**
   * The memory index where the destination virtual Timelock account lives
   *
   * @generated from field: uint32 memory_index = 8;
   */
  memoryIndex = 0;

  constructor(data?: PartialMessage<SwapResponse_ServerParameters_CurrencyCreatorStateless>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateless";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payer", kind: "message", T: SolanaAccountId },
    { no: 2, name: "recent_blockhash", kind: "message", T: Blockhash },
    { no: 3, name: "alts", kind: "message", T: SolanaAddressLookupTable, repeated: true },
    { no: 4, name: "compute_unit_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "compute_unit_price", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "memo_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "memory_account", kind: "message", T: SolanaAccountId },
    { no: 8, name: "memory_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateless {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateless().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateless {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateless().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateless {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateless().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_ServerParameters_CurrencyCreatorStateless | PlainMessage<SwapResponse_ServerParameters_CurrencyCreatorStateless> | undefined, b: SwapResponse_ServerParameters_CurrencyCreatorStateless | PlainMessage<SwapResponse_ServerParameters_CurrencyCreatorStateless> | undefined): boolean {
    return proto3.util.equals(SwapResponse_ServerParameters_CurrencyCreatorStateless, a, b);
  }
}

/**
 * Server parameters when executing stateful buy/sell flows against the
 * Currency Creator program
 *
 * Supported Solana transaction version: v0
 *
 * Instruction formats:
 *
 * Buy Tokens (Core Mint -> Launchpad Currency Mint):
 *  1. System::AdvanceNonce
 *  2. [Optional] ComputeBudget::SetComputeUnitLimit
 *  3. [Optional] ComputeBudget::SetComputeUnitPrice
 *  4. [Optional] Memo::Memo
 *  5. AssociatedTokenAccount::CreateIdempotent (open Core Mint temporary account)
 *  6. VM::TransferForSwap (Core Mint VM swap ATA -> Core Mint temporary account)
 *  6. CurrencyCreator::BuyAndDepositIntoVm (bounded buy depositing to_mint tokens into the to_mint VM)
 *  8. Token::CloseAccount (closes Core Mint temporary account)
 *  9. VM::CloseSwapAccountIfEmpty (closes Core Mint VM swap ATA if empty)
 *
 * Sell Tokens (Launchpad Currency Mint -> Core Mint):
 *  1. System::AdvanceNonce
 *  2. [Optional] ComputeBudget::SetComputeUnitLimit
 *  3. [Optional] ComputeBudget::SetComputeUnitPrice
 *  4. [Optional] Memo::Memo
 *  5. AssociatedTokenAccount::CreateIdempotent (open from_mint temporary account)
 *  6. VM::TransferForSwap (from_mint VM swap ATA -> from_mint temporary account)
 *  7. CurrencyCreator::SellAndDepositIntoVm (bounded sell depositing Core Mint into the Core Mint VM)
 *  8. Token::CloseAccount (closes from_mint temporary account)
 *  9. VM::CloseSwapAccountIfEmpty (closes from_mint swap PDA/ATA if empty)
 *
 * Swap Tokens (Launchpad Currency Mint -> Launchpad Currency Mint):
 *  1.  System::AdvanceNonce
 *  2.  [Optional] ComputeBudget::SetComputeUnitLimit
 *  3.  [Optional] ComputeBudget::SetComputeUnitPrice
 *  4.  [Optional] Memo::Memo
 *  5.  AssociatedTokenAccount::CreateIdempotent (open Core Mint temporary account)
 *  6.  AssociatedTokenAccount::CreateIdempotent (open from_mint temporary account)
 *  7.  VM::TransferForSwap (from_mint VM swap ATA -> from_mint temporary account)
 *  8.  CurrencyCreator::SellTokens (bounded sell transferring Core Mint into temporary account)
 *  9.  CurrencyCreator::BuyAndDepositIntoVm (unlimited buy depositing to_mint tokens into the to_mint VM)
 *  10. Token::CloseAccount (closes Core Mint temporary account)
 *  11. Token::CloseAccount (closes from_mint temporary account)
 *  12. VM::CloseSwapAccountIfEmpty (closes from_mint VM swap ATA if empty)
 *
 * @generated from message code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateful
 */
export class SwapResponse_ServerParameters_CurrencyCreatorStateful extends Message<SwapResponse_ServerParameters_CurrencyCreatorStateful> {
  /**
   * Subisdizer account that will be paying for the swap
   *
   * @generated from field: code.common.v1.SolanaAccountId payer = 1;
   */
  payer?: SolanaAccountId;

  /**
   * ALTs that should be used when constructing the versioned transaction
   *
   * @generated from field: repeated code.common.v1.SolanaAddressLookupTable alts = 2;
   */
  alts: SolanaAddressLookupTable[] = [];

  /**
   * Compute unit limit provided to the ComputeBudget::SetComputeUnitLimit
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint32 compute_unit_limit = 3;
   */
  computeUnitLimit = 0;

  /**
   * Compute unit price provided in the ComputeBudget::SetComputeUnitPrice
   * instruction. If the value is 0, then the instruction can be omitted.
   *
   * @generated from field: uint64 compute_unit_price = 4;
   */
  computeUnitPrice = protoInt64.zero;

  /**
   * Value provided into the Memo::Memo instruction. If the value length is 0,
   * then the instruction can be omitted.
   *
   * @generated from field: string memo_value = 5;
   */
  memoValue = "";

  /**
   * The memory account where the destination virtual Timelock account lives
   *
   * @generated from field: code.common.v1.SolanaAccountId memory_account = 6;
   */
  memoryAccount?: SolanaAccountId;

  /**
   * The memory index where the destination virtual Timelock account lives
   *
   * @generated from field: uint32 memory_index = 7;
   */
  memoryIndex = 0;

  constructor(data?: PartialMessage<SwapResponse_ServerParameters_CurrencyCreatorStateful>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.ServerParameters.CurrencyCreatorStateful";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payer", kind: "message", T: SolanaAccountId },
    { no: 2, name: "alts", kind: "message", T: SolanaAddressLookupTable, repeated: true },
    { no: 3, name: "compute_unit_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "compute_unit_price", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "memo_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "memory_account", kind: "message", T: SolanaAccountId },
    { no: 7, name: "memory_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateful {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateful().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateful {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateful().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_ServerParameters_CurrencyCreatorStateful {
    return new SwapResponse_ServerParameters_CurrencyCreatorStateful().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_ServerParameters_CurrencyCreatorStateful | PlainMessage<SwapResponse_ServerParameters_CurrencyCreatorStateful> | undefined, b: SwapResponse_ServerParameters_CurrencyCreatorStateful | PlainMessage<SwapResponse_ServerParameters_CurrencyCreatorStateful> | undefined): boolean {
    return proto3.util.equals(SwapResponse_ServerParameters_CurrencyCreatorStateful, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapResponse.Success
 */
export class SwapResponse_Success extends Message<SwapResponse_Success> {
  /**
   * @generated from field: code.transaction.v2.SwapResponse.Success.Code code = 1;
   */
  code = SwapResponse_Success_Code.SWAP_SUBMITTED;

  constructor(data?: PartialMessage<SwapResponse_Success>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.Success";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SwapResponse_Success_Code) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_Success {
    return new SwapResponse_Success().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_Success | PlainMessage<SwapResponse_Success> | undefined, b: SwapResponse_Success | PlainMessage<SwapResponse_Success> | undefined): boolean {
    return proto3.util.equals(SwapResponse_Success, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SwapResponse.Success.Code
 */
export enum SwapResponse_Success_Code {
  /**
   * The swap was submitted to the blockchain.
   *
   * @generated from enum value: SWAP_SUBMITTED = 0;
   */
  SWAP_SUBMITTED = 0,

  /**
   * The swap was finalized on the blockchain.
   *
   * @generated from enum value: SWAP_FINALIZED = 1;
   */
  SWAP_FINALIZED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SwapResponse_Success_Code)
proto3.util.setEnumType(SwapResponse_Success_Code, "code.transaction.v2.SwapResponse.Success.Code", [
  { no: 0, name: "SWAP_SUBMITTED" },
  { no: 1, name: "SWAP_FINALIZED" },
]);

/**
 * @generated from message code.transaction.v2.SwapResponse.Error
 */
export class SwapResponse_Error extends Message<SwapResponse_Error> {
  /**
   * @generated from field: code.transaction.v2.SwapResponse.Error.Code code = 1;
   */
  code = SwapResponse_Error_Code.DENIED;

  /**
   * @generated from field: repeated code.transaction.v2.ErrorDetails error_details = 2;
   */
  errorDetails: ErrorDetails[] = [];

  constructor(data?: PartialMessage<SwapResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(SwapResponse_Error_Code) },
    { no: 2, name: "error_details", kind: "message", T: ErrorDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapResponse_Error {
    return new SwapResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: SwapResponse_Error | PlainMessage<SwapResponse_Error> | undefined, b: SwapResponse_Error | PlainMessage<SwapResponse_Error> | undefined): boolean {
    return proto3.util.equals(SwapResponse_Error, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SwapResponse.Error.Code
 */
export enum SwapResponse_Error_Code {
  /**
   * Denied by a guard (spam, money laundering, etc)
   *
   * @generated from enum value: DENIED = 0;
   */
  DENIED = 0,

  /**
   * There is an issue with the provided signature.
   *
   * @generated from enum value: SIGNATURE_ERROR = 1;
   */
  SIGNATURE_ERROR = 1,

  /**
   * The swap failed server-side validation
   *
   * @generated from enum value: INVALID_SWAP = 2;
   */
  INVALID_SWAP = 2,

  /**
   * The submitted swap transaction failed. Attempt the swap again.
   *
   * @generated from enum value: SWAP_FAILED = 3;
   */
  SWAP_FAILED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SwapResponse_Error_Code)
proto3.util.setEnumType(SwapResponse_Error_Code, "code.transaction.v2.SwapResponse.Error.Code", [
  { no: 0, name: "DENIED" },
  { no: 1, name: "SIGNATURE_ERROR" },
  { no: 2, name: "INVALID_SWAP" },
  { no: 3, name: "SWAP_FAILED" },
]);

/**
 * Metadata describes the high-level details of an intent
 *
 * @generated from message code.transaction.v2.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from oneof code.transaction.v2.Metadata.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountsMetadata open_accounts = 1;
     */
    value: OpenAccountsMetadata;
    case: "openAccounts";
  } | {
    /**
     * @generated from field: code.transaction.v2.SendPublicPaymentMetadata send_public_payment = 6;
     */
    value: SendPublicPaymentMetadata;
    case: "sendPublicPayment";
  } | {
    /**
     * @generated from field: code.transaction.v2.ReceivePaymentsPubliclyMetadata receive_payments_publicly = 7;
     */
    value: ReceivePaymentsPubliclyMetadata;
    case: "receivePaymentsPublicly";
  } | {
    /**
     * @generated from field: code.transaction.v2.PublicDistributionMetadata public_distribution = 9;
     */
    value: PublicDistributionMetadata;
    case: "publicDistribution";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "open_accounts", kind: "message", T: OpenAccountsMetadata, oneof: "type" },
    { no: 6, name: "send_public_payment", kind: "message", T: SendPublicPaymentMetadata, oneof: "type" },
    { no: 7, name: "receive_payments_publicly", kind: "message", T: ReceivePaymentsPubliclyMetadata, oneof: "type" },
    { no: 9, name: "public_distribution", kind: "message", T: PublicDistributionMetadata, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * Open a set of accounts
 *
 * Action Spec (User):
 *
 * for account in [PRIMARY]
 *   actions.push_back(OpenAccountAction(account))
 *
 * Action Spec (Pool):
 *
 * for account in [POOL]
 *   actions.push_back(OpenAccountAction(account))
 *
 * @generated from message code.transaction.v2.OpenAccountsMetadata
 */
export class OpenAccountsMetadata extends Message<OpenAccountsMetadata> {
  /**
   * @generated from field: code.transaction.v2.OpenAccountsMetadata.AccountSet account_set = 1;
   */
  accountSet = OpenAccountsMetadata_AccountSet.USER;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 2;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<OpenAccountsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_set", kind: "enum", T: proto3.getEnumType(OpenAccountsMetadata_AccountSet) },
    { no: 2, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountsMetadata {
    return new OpenAccountsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined, b: OpenAccountsMetadata | PlainMessage<OpenAccountsMetadata> | undefined): boolean {
    return proto3.util.equals(OpenAccountsMetadata, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.OpenAccountsMetadata.AccountSet
 */
export enum OpenAccountsMetadata_AccountSet {
  /**
   * Opens a set of user accounts
   *
   * @generated from enum value: USER = 0;
   */
  USER = 0,

  /**
   * Opens a pool account
   *
   * @generated from enum value: POOL = 1;
   */
  POOL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(OpenAccountsMetadata_AccountSet)
proto3.util.setEnumType(OpenAccountsMetadata_AccountSet, "code.transaction.v2.OpenAccountsMetadata.AccountSet", [
  { no: 0, name: "USER" },
  { no: 1, name: "POOL" },
]);

/**
 * Send a payment to a destination account publicly.
 *
 * Action Spec (Payment):
 *
 * actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
 *
 * Action Spec (Withdrawal):
 *
 * actions = [NoPrivacyTransferAction(PRIMARY, destination, ExchangeData.Quarks)]
 * if destinationRequiresInitialization {
 *   actions[0].NoPrivacyTransferAction.ExchangeData.Quarks -= feeAmount
 *   actions.push_back(FeePaymentAction(PRIMARY, feeAccount, feeAmount))
 * }
 *
 * Action Spec (Remote Send):
 *
 * actions = [
 *   OpenAccountAction(REMOTE_SEND_GIFT_CARD),
 *   NoPrivacyTransferAction(PRIMARY, REMOTE_SEND_GIFT_CARD, ExchangeData.Quarks),
 *   NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, ExchangeData.Quarks, is_auto_return=true),
 * ]
 *
 * @generated from message code.transaction.v2.SendPublicPaymentMetadata
 */
export class SendPublicPaymentMetadata extends Message<SendPublicPaymentMetadata> {
  /**
   * The source account where funds will be sent from. Currently, this is always
   * the user's primary account.
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 4;
   */
  source?: SolanaAccountId;

  /**
   * The destination token account to send funds to.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * Destination owner account, which is required for withdrawals that intend
   * to create an ATA. Every other variation of this intent can omit this field.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination_owner = 6;
   */
  destinationOwner?: SolanaAccountId;

  /**
   * The exchange data of total funds being sent to the destination
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 2;
   */
  exchangeData?: ExchangeData;

  /**
   * Is the payment a withdrawal?
   *
   * @generated from field: bool is_withdrawal = 3;
   */
  isWithdrawal = false;

  /**
   * Is the payment going to a new gift card? Note is_withdrawal must be false.
   *
   * @generated from field: bool is_remote_send = 5;
   */
  isRemoteSend = false;

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<SendPublicPaymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendPublicPaymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "source", kind: "message", T: SolanaAccountId },
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 6, name: "destination_owner", kind: "message", T: SolanaAccountId },
    { no: 2, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 3, name: "is_withdrawal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPublicPaymentMetadata {
    return new SendPublicPaymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined, b: SendPublicPaymentMetadata | PlainMessage<SendPublicPaymentMetadata> | undefined): boolean {
    return proto3.util.equals(SendPublicPaymentMetadata, a, b);
  }
}

/**
 * Receive funds into a user-owned account publicly. All use cases of this intent
 * close the account, so all funds must be moved.
 *
 * Action Spec (Remote Send):
 *
 * actions = [NoPrivacyWithdrawAction(REMOTE_SEND_GIFT_CARD, PRIMARY, quarks)]
 *
 * @generated from message code.transaction.v2.ReceivePaymentsPubliclyMetadata
 */
export class ReceivePaymentsPubliclyMetadata extends Message<ReceivePaymentsPubliclyMetadata> {
  /**
   * The remote send gift card to receive funds from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The exact amount of quarks being received
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  /**
   * Is the receipt of funds from a remote send gift card? Currently, this is
   * the only use case for this intent and validation enforces the flag to true.
   *
   * @generated from field: bool is_remote_send = 3;
   */
  isRemoteSend = false;

  /**
   * If is_remote_send is true, the original exchange data that was provided as
   * part of creating the gift card account. This is purely a server-provided value.
   * SubmitIntent will disallow this being set.
   *
   * @generated from field: code.transaction.v2.ExchangeData exchange_data = 5;
   */
  exchangeData?: ExchangeData;

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 6;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<ReceivePaymentsPubliclyMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReceivePaymentsPubliclyMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "is_remote_send", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "exchange_data", kind: "message", T: ExchangeData },
    { no: 6, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivePaymentsPubliclyMetadata {
    return new ReceivePaymentsPubliclyMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined, b: ReceivePaymentsPubliclyMetadata | PlainMessage<ReceivePaymentsPubliclyMetadata> | undefined): boolean {
    return proto3.util.equals(ReceivePaymentsPubliclyMetadata, a, b);
  }
}

/**
 * Distribute funds from a pool account publicly to one or more user-owned accounts.
 *
 * Action Spec:
 *
 * for distribution in distributions[:len(distributions)-1]
 *   actions.push_back(NoPrivacyTransferAction(POOL, distribution.destination, distributions.quarks))
 * actions.push_back(NoPrivacyWithdrawAction(POOL, distributions[len(distributions)-1].destination, distributions[len(distributions)-1].quarks))
 *
 * Notes:
 *  - All funds must distributed. The balance of the pool must be zero at the end of the intent
 *  - The pool is closed at the end of the intent via a NoPrivacyWithdrawAction
 *
 * @generated from message code.transaction.v2.PublicDistributionMetadata
 */
export class PublicDistributionMetadata extends Message<PublicDistributionMetadata> {
  /**
   * The pool account to distribute from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 1;
   */
  source?: SolanaAccountId;

  /**
   * The set of distributions
   *
   * @generated from field: repeated code.transaction.v2.PublicDistributionMetadata.Distribution distributions = 2;
   */
  distributions: PublicDistributionMetadata_Distribution[] = [];

  /**
   * The mint that this intent will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 3;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<PublicDistributionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PublicDistributionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: SolanaAccountId },
    { no: 2, name: "distributions", kind: "message", T: PublicDistributionMetadata_Distribution, repeated: true },
    { no: 3, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicDistributionMetadata {
    return new PublicDistributionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PublicDistributionMetadata | PlainMessage<PublicDistributionMetadata> | undefined, b: PublicDistributionMetadata | PlainMessage<PublicDistributionMetadata> | undefined): boolean {
    return proto3.util.equals(PublicDistributionMetadata, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.PublicDistributionMetadata.Distribution
 */
export class PublicDistributionMetadata_Distribution extends Message<PublicDistributionMetadata_Distribution> {
  /**
   * Destination where a portion of the pool's funds will be distributed.
   * This must always be a primary account.
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  /**
   * The amount of funds to distribute to the destination
   *
   * @generated from field: uint64 quarks = 2;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<PublicDistributionMetadata_Distribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.PublicDistributionMetadata.Distribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 2, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicDistributionMetadata_Distribution {
    return new PublicDistributionMetadata_Distribution().fromJsonString(jsonString, options);
  }

  static equals(a: PublicDistributionMetadata_Distribution | PlainMessage<PublicDistributionMetadata_Distribution> | undefined, b: PublicDistributionMetadata_Distribution | PlainMessage<PublicDistributionMetadata_Distribution> | undefined): boolean {
    return proto3.util.equals(PublicDistributionMetadata_Distribution, a, b);
  }
}

/**
 * Action is a well-defined, ordered and small set of transactions or virtual instructions
 * for a unit of work that the client wants to perform on the blockchain. Clients provide
 * parameters known to them in the action.
 *
 * @generated from message code.transaction.v2.Action
 */
export class Action extends Message<Action> {
  /**
   * The ID of this action, which is unique within an intent. It must match
   * the index of the action's location in the SubmitAction's actions field.
   *
   * @generated from field: uint32 id = 1;
   */
  id = 0;

  /**
   * The type of action to perform.
   *
   * @generated from oneof code.transaction.v2.Action.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountAction open_account = 2;
     */
    value: OpenAccountAction;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferAction no_privacy_transfer = 5;
     */
    value: NoPrivacyTransferAction;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawAction no_privacy_withdraw = 6;
     */
    value: NoPrivacyWithdrawAction;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentAction fee_payment = 10;
     */
    value: FeePaymentAction;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "open_account", kind: "message", T: OpenAccountAction, oneof: "type" },
    { no: 5, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferAction, oneof: "type" },
    { no: 6, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawAction, oneof: "type" },
    { no: 10, name: "fee_payment", kind: "message", T: FeePaymentAction, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * No client signature required
 *
 * @generated from message code.transaction.v2.OpenAccountAction
 */
export class OpenAccountAction extends Message<OpenAccountAction> {
  /**
   * The type of account, which will dictate its intended use
   *
   * @generated from field: code.common.v1.AccountType account_type = 1;
   */
  accountType = AccountType.UNKNOWN;

  /**
   * The owner of the account. For accounts liked to a user's 12 words, this is
   * the verified parent owner account public key. All other account types should
   * set this to the authority value.
   *
   * @generated from field: code.common.v1.SolanaAccountId owner = 2;
   */
  owner?: SolanaAccountId;

  /**
   * The index used to for accounts that are derived from owner
   *
   * @generated from field: uint64 index = 3;
   */
  index = protoInt64.zero;

  /**
   * The public key of the private key that has authority over the opened token account
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 4;
   */
  authority?: SolanaAccountId;

  /**
   * The token account being opened
   *
   * @generated from field: code.common.v1.SolanaAccountId token = 5;
   */
  token?: SolanaAccountId;

  /**
   * The signature is of serialize(OpenAccountAction) without this field set
   * using the private key of the authority account. This provides a proof
   * of authorization to link authority to owner.
   *
   * @generated from field: code.common.v1.Signature authority_signature = 6;
   */
  authoritySignature?: Signature;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<OpenAccountAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_type", kind: "enum", T: proto3.getEnumType(AccountType) },
    { no: 2, name: "owner", kind: "message", T: SolanaAccountId },
    { no: 3, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 5, name: "token", kind: "message", T: SolanaAccountId },
    { no: 6, name: "authority_signature", kind: "message", T: Signature },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountAction {
    return new OpenAccountAction().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined, b: OpenAccountAction | PlainMessage<OpenAccountAction> | undefined): boolean {
    return proto3.util.equals(OpenAccountAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferAction
 */
export class NoPrivacyTransferAction extends Message<NoPrivacyTransferAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<NoPrivacyTransferAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferAction {
    return new NoPrivacyTransferAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined, b: NoPrivacyTransferAction | PlainMessage<NoPrivacyTransferAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawAction
 */
export class NoPrivacyWithdrawAction extends Message<NoPrivacyWithdrawAction> {
  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 1;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 2;
   */
  source?: SolanaAccountId;

  /**
   * The destination account where funds are transferred to
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 3;
   */
  destination?: SolanaAccountId;

  /**
   * The quark amount to withdraw
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * Whether the account is closed afterwards. This is always true, since there
   * are no current se cases to leave it open.
   *
   * @generated from field: bool should_close = 5;
   */
  shouldClose = false;

  /**
   * Whether this action is for an auto-return, which client allows server to defer
   * scheduling at its own discretion to return funds back to the owner (to their primary
   * account) that funded source.
   *
   * @generated from field: bool is_auto_return = 6;
   */
  isAutoReturn = false;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 7;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<NoPrivacyWithdrawAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 2, name: "source", kind: "message", T: SolanaAccountId },
    { no: 3, name: "destination", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "should_close", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "is_auto_return", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawAction {
    return new NoPrivacyWithdrawAction().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined, b: NoPrivacyWithdrawAction | PlainMessage<NoPrivacyWithdrawAction> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawAction, a, b);
  }
}

/**
 * Compact message signature required
 *
 * @generated from message code.transaction.v2.FeePaymentAction
 */
export class FeePaymentAction extends Message<FeePaymentAction> {
  /**
   * The type of fee being operated on
   *
   * @generated from field: code.transaction.v2.FeePaymentAction.FeeType type = 1;
   */
  type = FeePaymentAction_FeeType.UNKNOWN;

  /**
   * The public key of the private key that has authority over source
   *
   * @generated from field: code.common.v1.SolanaAccountId authority = 2;
   */
  authority?: SolanaAccountId;

  /**
   * The source account where funds are transferred from
   *
   * @generated from field: code.common.v1.SolanaAccountId source = 3;
   */
  source?: SolanaAccountId;

  /**
   * The quark amount to transfer
   *
   * @generated from field: uint64 amount = 4;
   */
  amount = protoInt64.zero;

  /**
   * The mint that this action will be operating against. For backwards
   * compatibility, if no mint is set, then it is assumed to be the core
   * mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(FeePaymentAction_FeeType) },
    { no: 2, name: "authority", kind: "message", T: SolanaAccountId },
    { no: 3, name: "source", kind: "message", T: SolanaAccountId },
    { no: 4, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentAction {
    return new FeePaymentAction().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined, b: FeePaymentAction | PlainMessage<FeePaymentAction> | undefined): boolean {
    return proto3.util.equals(FeePaymentAction, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.FeePaymentAction.FeeType
 */
export enum FeePaymentAction_FeeType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Server-defined fee for creating an external ATA on withdrawals on send
   *
   * @generated from enum value: CREATE_ON_SEND_WITHDRAWAL = 1;
   */
  CREATE_ON_SEND_WITHDRAWAL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(FeePaymentAction_FeeType)
proto3.util.setEnumType(FeePaymentAction_FeeType, "code.transaction.v2.FeePaymentAction.FeeType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CREATE_ON_SEND_WITHDRAWAL" },
]);

/**
 * ServerParameter are a set of parameters known and returned by server that
 * enables clients to complete transaction construction. Any necessary proofs,
 * which are required to be locally verifiable, are also provided to ensure
 * safe use in the event of a malicious server.
 *
 * @generated from message code.transaction.v2.ServerParameter
 */
export class ServerParameter extends Message<ServerParameter> {
  /**
   * The action the server parameters belong to
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * The set of nonces used for the action. Server will only provide values
   * for transactions requiring client signatures.
   *
   * @generated from field: repeated code.transaction.v2.NoncedTransactionMetadata nonces = 2;
   */
  nonces: NoncedTransactionMetadata[] = [];

  /**
   * The type of server parameter which maps to the type of action requested
   *
   * @generated from oneof code.transaction.v2.ServerParameter.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.OpenAccountServerParameter open_account = 3;
     */
    value: OpenAccountServerParameter;
    case: "openAccount";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyTransferServerParameter no_privacy_transfer = 6;
     */
    value: NoPrivacyTransferServerParameter;
    case: "noPrivacyTransfer";
  } | {
    /**
     * @generated from field: code.transaction.v2.NoPrivacyWithdrawServerParameter no_privacy_withdraw = 7;
     */
    value: NoPrivacyWithdrawServerParameter;
    case: "noPrivacyWithdraw";
  } | {
    /**
     * @generated from field: code.transaction.v2.FeePaymentServerParameter fee_payment = 11;
     */
    value: FeePaymentServerParameter;
    case: "feePayment";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "nonces", kind: "message", T: NoncedTransactionMetadata, repeated: true },
    { no: 3, name: "open_account", kind: "message", T: OpenAccountServerParameter, oneof: "type" },
    { no: 6, name: "no_privacy_transfer", kind: "message", T: NoPrivacyTransferServerParameter, oneof: "type" },
    { no: 7, name: "no_privacy_withdraw", kind: "message", T: NoPrivacyWithdrawServerParameter, oneof: "type" },
    { no: 11, name: "fee_payment", kind: "message", T: FeePaymentServerParameter, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerParameter {
    return new ServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerParameter {
    return new ServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ServerParameter | PlainMessage<ServerParameter> | undefined, b: ServerParameter | PlainMessage<ServerParameter> | undefined): boolean {
    return proto3.util.equals(ServerParameter, a, b);
  }
}

/**
 * For transactions, the nonce is a standard nonce on Solana
 * For virtual instructions, the nonce is a virtual nonce on the Code VM
 *
 * @generated from message code.transaction.v2.NoncedTransactionMetadata
 */
export class NoncedTransactionMetadata extends Message<NoncedTransactionMetadata> {
  /**
   * The nonce account to use in the system::AdvanceNonce instruction
   *
   * @generated from field: code.common.v1.SolanaAccountId nonce = 1;
   */
  nonce?: SolanaAccountId;

  /**
   * The blockhash to set in the transaction or virtual instruction
   *
   * @generated from field: code.common.v1.Blockhash blockhash = 2;
   */
  blockhash?: Blockhash;

  constructor(data?: PartialMessage<NoncedTransactionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoncedTransactionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "message", T: SolanaAccountId },
    { no: 2, name: "blockhash", kind: "message", T: Blockhash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoncedTransactionMetadata {
    return new NoncedTransactionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined, b: NoncedTransactionMetadata | PlainMessage<NoncedTransactionMetadata> | undefined): boolean {
    return proto3.util.equals(NoncedTransactionMetadata, a, b);
  }
}

/**
 * There are no transactions requiring client signatures
 *
 * @generated from message code.transaction.v2.OpenAccountServerParameter
 */
export class OpenAccountServerParameter extends Message<OpenAccountServerParameter> {
  constructor(data?: PartialMessage<OpenAccountServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.OpenAccountServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAccountServerParameter {
    return new OpenAccountServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined, b: OpenAccountServerParameter | PlainMessage<OpenAccountServerParameter> | undefined): boolean {
    return proto3.util.equals(OpenAccountServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyTransferServerParameter
 */
export class NoPrivacyTransferServerParameter extends Message<NoPrivacyTransferServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyTransferServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyTransferServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyTransferServerParameter {
    return new NoPrivacyTransferServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined, b: NoPrivacyTransferServerParameter | PlainMessage<NoPrivacyTransferServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyTransferServerParameter, a, b);
  }
}

/**
 * There are no action-specific server parameters
 *
 * @generated from message code.transaction.v2.NoPrivacyWithdrawServerParameter
 */
export class NoPrivacyWithdrawServerParameter extends Message<NoPrivacyWithdrawServerParameter> {
  constructor(data?: PartialMessage<NoPrivacyWithdrawServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.NoPrivacyWithdrawServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoPrivacyWithdrawServerParameter {
    return new NoPrivacyWithdrawServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined, b: NoPrivacyWithdrawServerParameter | PlainMessage<NoPrivacyWithdrawServerParameter> | undefined): boolean {
    return proto3.util.equals(NoPrivacyWithdrawServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.FeePaymentServerParameter
 */
export class FeePaymentServerParameter extends Message<FeePaymentServerParameter> {
  /**
   * The destination account where OCP fee payments should be sent. This will
   * only be set when the corresponding FeePaymentAction.Type:
   * - CREATE_ON_SEND_WITHDRAWAL
   *
   * @generated from field: code.common.v1.SolanaAccountId destination = 1;
   */
  destination?: SolanaAccountId;

  constructor(data?: PartialMessage<FeePaymentServerParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.FeePaymentServerParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeePaymentServerParameter {
    return new FeePaymentServerParameter().fromJsonString(jsonString, options);
  }

  static equals(a: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined, b: FeePaymentServerParameter | PlainMessage<FeePaymentServerParameter> | undefined): boolean {
    return proto3.util.equals(FeePaymentServerParameter, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ErrorDetails
 */
export class ErrorDetails extends Message<ErrorDetails> {
  /**
   * @generated from oneof code.transaction.v2.ErrorDetails.type
   */
  type: {
    /**
     * @generated from field: code.transaction.v2.ReasonStringErrorDetails reason_string = 1;
     */
    value: ReasonStringErrorDetails;
    case: "reasonString";
  } | {
    /**
     * @generated from field: code.transaction.v2.InvalidSignatureErrorDetails invalid_signature = 2;
     */
    value: InvalidSignatureErrorDetails;
    case: "invalidSignature";
  } | {
    /**
     * @generated from field: code.transaction.v2.DeniedErrorDetails denied = 3;
     */
    value: DeniedErrorDetails;
    case: "denied";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason_string", kind: "message", T: ReasonStringErrorDetails, oneof: "type" },
    { no: 2, name: "invalid_signature", kind: "message", T: InvalidSignatureErrorDetails, oneof: "type" },
    { no: 3, name: "denied", kind: "message", T: DeniedErrorDetails, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorDetails {
    return new ErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorDetails {
    return new ErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorDetails | PlainMessage<ErrorDetails> | undefined, b: ErrorDetails | PlainMessage<ErrorDetails> | undefined): boolean {
    return proto3.util.equals(ErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ReasonStringErrorDetails
 */
export class ReasonStringErrorDetails extends Message<ReasonStringErrorDetails> {
  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 1;
   */
  reason = "";

  constructor(data?: PartialMessage<ReasonStringErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ReasonStringErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReasonStringErrorDetails {
    return new ReasonStringErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined, b: ReasonStringErrorDetails | PlainMessage<ReasonStringErrorDetails> | undefined): boolean {
    return proto3.util.equals(ReasonStringErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.InvalidSignatureErrorDetails
 */
export class InvalidSignatureErrorDetails extends Message<InvalidSignatureErrorDetails> {
  /**
   * The action whose signature mismatched
   *
   * @generated from field: uint32 action_id = 1;
   */
  actionId = 0;

  /**
   * @generated from oneof code.transaction.v2.InvalidSignatureErrorDetails.expected_blob
   */
  expectedBlob: {
    /**
     * The transaction the server expected to have signed.
     *
     * @generated from field: code.common.v1.Transaction expected_transaction = 2;
     */
    value: Transaction;
    case: "expectedTransaction";
  } | {
    /**
     * The virtual ixn hash the server expected to have signed.
     *
     * @generated from field: code.common.v1.Hash expected_vixn_hash = 4;
     */
    value: Hash;
    case: "expectedVixnHash";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The signature that was provided by the client.
   *
   * @generated from field: code.common.v1.Signature provided_signature = 3;
   */
  providedSignature?: Signature;

  constructor(data?: PartialMessage<InvalidSignatureErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.InvalidSignatureErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "expected_transaction", kind: "message", T: Transaction, oneof: "expected_blob" },
    { no: 4, name: "expected_vixn_hash", kind: "message", T: Hash, oneof: "expected_blob" },
    { no: 3, name: "provided_signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvalidSignatureErrorDetails {
    return new InvalidSignatureErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined, b: InvalidSignatureErrorDetails | PlainMessage<InvalidSignatureErrorDetails> | undefined): boolean {
    return proto3.util.equals(InvalidSignatureErrorDetails, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.DeniedErrorDetails
 */
export class DeniedErrorDetails extends Message<DeniedErrorDetails> {
  /**
   * @generated from field: code.transaction.v2.DeniedErrorDetails.Code code = 1;
   */
  code = DeniedErrorDetails_Code.UNSPECIFIED;

  /**
   * Human readable string indicating the failure.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<DeniedErrorDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.DeniedErrorDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(DeniedErrorDetails_Code) },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeniedErrorDetails {
    return new DeniedErrorDetails().fromJsonString(jsonString, options);
  }

  static equals(a: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined, b: DeniedErrorDetails | PlainMessage<DeniedErrorDetails> | undefined): boolean {
    return proto3.util.equals(DeniedErrorDetails, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.DeniedErrorDetails.Code
 */
export enum DeniedErrorDetails_Code {
  /**
   * Reason code not yet defined
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(DeniedErrorDetails_Code)
proto3.util.setEnumType(DeniedErrorDetails_Code, "code.transaction.v2.DeniedErrorDetails.Code", [
  { no: 0, name: "UNSPECIFIED" },
]);

/**
 * ExchangeData defines an amount of crypto with currency exchange data
 *
 * @generated from message code.transaction.v2.ExchangeData
 */
export class ExchangeData extends Message<ExchangeData> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon exchange rate. This might not be the same as the
   * actual exchange rate at the time of intent or fund transfer.
   *
   * @generated from field: double exchange_rate = 2;
   */
  exchangeRate = 0;

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 3;
   */
  nativeAmount = 0;

  /**
   * The exact amount of quarks to send. This will be used as the source of
   * truth for validating transaction transfer amounts.
   *
   * @generated from field: uint64 quarks = 4;
   */
  quarks = protoInt64.zero;

  /**
   * The crypto mint that is being operated against for the exchange.
   * For backwards compatibility, if no mint is set, then it is assumed
   * to be the core mint.
   *
   * @generated from field: code.common.v1.SolanaAccountId mint = 5;
   */
  mint?: SolanaAccountId;

  constructor(data?: PartialMessage<ExchangeData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exchange_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "mint", kind: "message", T: SolanaAccountId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeData {
    return new ExchangeData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeData {
    return new ExchangeData().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeData | PlainMessage<ExchangeData> | undefined, b: ExchangeData | PlainMessage<ExchangeData> | undefined): boolean {
    return proto3.util.equals(ExchangeData, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.ExchangeDataWithoutRate
 */
export class ExchangeDataWithoutRate extends Message<ExchangeDataWithoutRate> {
  /**
   * ISO 4217 alpha-3 currency code.
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The agreed upon transfer amount in the currency the payment was made
   * in.
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  constructor(data?: PartialMessage<ExchangeDataWithoutRate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.ExchangeDataWithoutRate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExchangeDataWithoutRate {
    return new ExchangeDataWithoutRate().fromJsonString(jsonString, options);
  }

  static equals(a: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined, b: ExchangeDataWithoutRate | PlainMessage<ExchangeDataWithoutRate> | undefined): boolean {
    return proto3.util.equals(ExchangeDataWithoutRate, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SendLimit
 */
export class SendLimit extends Message<SendLimit> {
  /**
   * Remaining limit to apply on the next transaction
   *
   * @generated from field: float next_transaction = 1;
   */
  nextTransaction = 0;

  /**
   * Maximum allowed on a per-transaction basis
   *
   * @generated from field: float max_per_transaction = 2;
   */
  maxPerTransaction = 0;

  /**
   * Maximum allowed on a per-day basis
   *
   * @generated from field: float max_per_day = 3;
   */
  maxPerDay = 0;

  constructor(data?: PartialMessage<SendLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SendLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "max_per_transaction", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "max_per_day", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendLimit {
    return new SendLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendLimit {
    return new SendLimit().fromJsonString(jsonString, options);
  }

  static equals(a: SendLimit | PlainMessage<SendLimit> | undefined, b: SendLimit | PlainMessage<SendLimit> | undefined): boolean {
    return proto3.util.equals(SendLimit, a, b);
  }
}

/**
 * VerifiedSwapMetadata defines verifiable swap metadata for non-custodial swap
 * state management using client signature verification.
 *
 * @generated from message code.transaction.v2.VerifiedSwapMetadata
 */
export class VerifiedSwapMetadata extends Message<VerifiedSwapMetadata> {
  /**
   * @generated from oneof code.transaction.v2.VerifiedSwapMetadata.kind
   */
  kind: {
    /**
     * @generated from field: code.transaction.v2.VerifiedCurrencyCreatorSwapMetadata currency_creator = 1;
     */
    value: VerifiedCurrencyCreatorSwapMetadata;
    case: "currencyCreator";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<VerifiedSwapMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VerifiedSwapMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency_creator", kind: "message", T: VerifiedCurrencyCreatorSwapMetadata, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifiedSwapMetadata {
    return new VerifiedSwapMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifiedSwapMetadata {
    return new VerifiedSwapMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifiedSwapMetadata {
    return new VerifiedSwapMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: VerifiedSwapMetadata | PlainMessage<VerifiedSwapMetadata> | undefined, b: VerifiedSwapMetadata | PlainMessage<VerifiedSwapMetadata> | undefined): boolean {
    return proto3.util.equals(VerifiedSwapMetadata, a, b);
  }
}

/**
 * VerifiedCurrencyCreatorSwapMetadata is verified metadata for swaps against the
 * Currency Creator program
 *
 * @generated from message code.transaction.v2.VerifiedCurrencyCreatorSwapMetadata
 */
export class VerifiedCurrencyCreatorSwapMetadata extends Message<VerifiedCurrencyCreatorSwapMetadata> {
  /**
   * Verifiable client-side parameters that were provided during the StartSwap RPC
   *
   * @generated from field: code.transaction.v2.StartSwapRequest.Start.CurrencyCreator client_parameters = 1;
   */
  clientParameters?: StartSwapRequest_Start_CurrencyCreator;

  /**
   * Verifiable agreed-upon server-side parameters that were provided during the StartSwap RPC
   *
   * @generated from field: code.transaction.v2.StartSwapResponse.ServerParameters.CurrencyCreator server_parameters = 2;
   */
  serverParameters?: StartSwapResponse_ServerParameters_CurrencyCreator;

  constructor(data?: PartialMessage<VerifiedCurrencyCreatorSwapMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.VerifiedCurrencyCreatorSwapMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_parameters", kind: "message", T: StartSwapRequest_Start_CurrencyCreator },
    { no: 2, name: "server_parameters", kind: "message", T: StartSwapResponse_ServerParameters_CurrencyCreator },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifiedCurrencyCreatorSwapMetadata {
    return new VerifiedCurrencyCreatorSwapMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifiedCurrencyCreatorSwapMetadata {
    return new VerifiedCurrencyCreatorSwapMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifiedCurrencyCreatorSwapMetadata {
    return new VerifiedCurrencyCreatorSwapMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: VerifiedCurrencyCreatorSwapMetadata | PlainMessage<VerifiedCurrencyCreatorSwapMetadata> | undefined, b: VerifiedCurrencyCreatorSwapMetadata | PlainMessage<VerifiedCurrencyCreatorSwapMetadata> | undefined): boolean {
    return proto3.util.equals(VerifiedCurrencyCreatorSwapMetadata, a, b);
  }
}

/**
 * @generated from message code.transaction.v2.SwapMetadata
 */
export class SwapMetadata extends Message<SwapMetadata> {
  /**
   * @generated from field: code.transaction.v2.VerifiedSwapMetadata verified_metadata = 1;
   */
  verifiedMetadata?: VerifiedSwapMetadata;

  /**
   * @generated from field: code.transaction.v2.SwapMetadata.State state = 2;
   */
  state = SwapMetadata_State.UNKNOWN;

  /**
   * The signature is of serialize(VerifiedSwapMetadata) using the private
   * key of the owner account. Use this to guarantee that VerifiedSwapMetadata
   * has not been tampered with.
   *
   * @generated from field: code.common.v1.Signature signature = 3;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<SwapMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "code.transaction.v2.SwapMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verified_metadata", kind: "message", T: VerifiedSwapMetadata },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(SwapMetadata_State) },
    { no: 3, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapMetadata {
    return new SwapMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapMetadata {
    return new SwapMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapMetadata {
    return new SwapMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SwapMetadata | PlainMessage<SwapMetadata> | undefined, b: SwapMetadata | PlainMessage<SwapMetadata> | undefined): boolean {
    return proto3.util.equals(SwapMetadata, a, b);
  }
}

/**
 * @generated from enum code.transaction.v2.SwapMetadata.State
 */
export enum SwapMetadata_State {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Swap state has been created and is pending funding
   *
   * @generated from enum value: CREATED = 1;
   */
  CREATED = 1,

  /**
   * The VM swap PDA is in the process of being funded
   *
   * @generated from enum value: FUNDING = 2;
   */
  FUNDING = 2,

  /**
   * The VM swap PDA has been funded
   *
   * @generated from enum value: FUNDED = 3;
   */
  FUNDED = 3,

  /**
   * The swap transaction is being submitted to the blockchain
   *
   * @generated from enum value: SUBMITTING = 4;
   */
  SUBMITTING = 4,

  /**
   * The swap transaction has been finalized on the blockchain
   *
   * @generated from enum value: FINALIZED = 5;
   */
  FINALIZED = 5,

  /**
   * The swap transaction failed
   *
   * @generated from enum value: FAILED = 6;
   */
  FAILED = 6,

  /**
   * The swap is in the process of being cancelled.
   *
   * @generated from enum value: CANCELLING = 7;
   */
  CANCELLING = 7,

  /**
   * The swap transaction is cancelled. Funds have been deposited back into the VM
   *
   * @generated from enum value: CANCELLED = 8;
   */
  CANCELLED = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(SwapMetadata_State)
proto3.util.setEnumType(SwapMetadata_State, "code.transaction.v2.SwapMetadata.State", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CREATED" },
  { no: 2, name: "FUNDING" },
  { no: 3, name: "FUNDED" },
  { no: 4, name: "SUBMITTING" },
  { no: 5, name: "FINALIZED" },
  { no: 6, name: "FAILED" },
  { no: 7, name: "CANCELLING" },
  { no: 8, name: "CANCELLED" },
]);

