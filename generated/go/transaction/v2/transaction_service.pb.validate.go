// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: transaction/v2/transaction_service.proto

package transaction

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common "github.com/code-payments/code-protobuf-api/generated/go/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common.AccountType(0)
)

// Validate checks the field values on SubmitIntentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitIntentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitIntentRequestMultiError, or nil if none found.
func (m *SubmitIntentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRequestPresent := false
	switch v := m.Request.(type) {
	case *SubmitIntentRequest_SubmitActions_:
		if v == nil {
			err := SubmitIntentRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetSubmitActions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentRequestValidationError{
						field:  "SubmitActions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentRequestValidationError{
						field:  "SubmitActions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubmitActions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentRequestValidationError{
					field:  "SubmitActions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SubmitIntentRequest_SubmitSignatures_:
		if v == nil {
			err := SubmitIntentRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetSubmitSignatures()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentRequestValidationError{
						field:  "SubmitSignatures",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentRequestValidationError{
						field:  "SubmitSignatures",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubmitSignatures()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentRequestValidationError{
					field:  "SubmitSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRequestPresent {
		err := SubmitIntentRequestValidationError{
			field:  "Request",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubmitIntentRequestMultiError(errors)
	}

	return nil
}

// SubmitIntentRequestMultiError is an error wrapping multiple validation
// errors returned by SubmitIntentRequest.ValidateAll() if the designated
// constraints aren't met.
type SubmitIntentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentRequestMultiError) AllErrors() []error { return m }

// SubmitIntentRequestValidationError is the validation error returned by
// SubmitIntentRequest.Validate if the designated constraints aren't met.
type SubmitIntentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentRequestValidationError) ErrorName() string {
	return "SubmitIntentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentRequestValidationError{}

// Validate checks the field values on SubmitIntentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitIntentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitIntentResponseMultiError, or nil if none found.
func (m *SubmitIntentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofResponsePresent := false
	switch v := m.Response.(type) {
	case *SubmitIntentResponse_ServerParameters_:
		if v == nil {
			err := SubmitIntentResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetServerParameters()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "ServerParameters",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "ServerParameters",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServerParameters()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentResponseValidationError{
					field:  "ServerParameters",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SubmitIntentResponse_Success_:
		if v == nil {
			err := SubmitIntentResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetSuccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentResponseValidationError{
					field:  "Success",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SubmitIntentResponse_Error_:
		if v == nil {
			err := SubmitIntentResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponsePresent {
		err := SubmitIntentResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubmitIntentResponseMultiError(errors)
	}

	return nil
}

// SubmitIntentResponseMultiError is an error wrapping multiple validation
// errors returned by SubmitIntentResponse.ValidateAll() if the designated
// constraints aren't met.
type SubmitIntentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentResponseMultiError) AllErrors() []error { return m }

// SubmitIntentResponseValidationError is the validation error returned by
// SubmitIntentResponse.Validate if the designated constraints aren't met.
type SubmitIntentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentResponseValidationError) ErrorName() string {
	return "SubmitIntentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentResponseValidationError{}

// Validate checks the field values on GetIntentMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntentMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntentMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntentMetadataRequestMultiError, or nil if none found.
func (m *GetIntentMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntentMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetIntentId() == nil {
		err := GetIntentMetadataRequestValidationError{
			field:  "IntentId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIntentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntentMetadataRequestValidationError{
				field:  "IntentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntentMetadataRequestValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := GetIntentMetadataRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntentMetadataRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntentMetadataRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIntentMetadataRequestMultiError(errors)
	}

	return nil
}

// GetIntentMetadataRequestMultiError is an error wrapping multiple validation
// errors returned by GetIntentMetadataRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIntentMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntentMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntentMetadataRequestMultiError) AllErrors() []error { return m }

// GetIntentMetadataRequestValidationError is the validation error returned by
// GetIntentMetadataRequest.Validate if the designated constraints aren't met.
type GetIntentMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntentMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntentMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntentMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntentMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntentMetadataRequestValidationError) ErrorName() string {
	return "GetIntentMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntentMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntentMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntentMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntentMetadataRequestValidationError{}

// Validate checks the field values on GetIntentMetadataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIntentMetadataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIntentMetadataResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIntentMetadataResponseMultiError, or nil if none found.
func (m *GetIntentMetadataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIntentMetadataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIntentMetadataResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIntentMetadataResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIntentMetadataResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIntentMetadataResponseMultiError(errors)
	}

	return nil
}

// GetIntentMetadataResponseMultiError is an error wrapping multiple validation
// errors returned by GetIntentMetadataResponse.ValidateAll() if the
// designated constraints aren't met.
type GetIntentMetadataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIntentMetadataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIntentMetadataResponseMultiError) AllErrors() []error { return m }

// GetIntentMetadataResponseValidationError is the validation error returned by
// GetIntentMetadataResponse.Validate if the designated constraints aren't met.
type GetIntentMetadataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIntentMetadataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIntentMetadataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIntentMetadataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIntentMetadataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIntentMetadataResponseValidationError) ErrorName() string {
	return "GetIntentMetadataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIntentMetadataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIntentMetadataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIntentMetadataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIntentMetadataResponseValidationError{}

// Validate checks the field values on GetLimitsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLimitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLimitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLimitsRequestMultiError, or nil if none found.
func (m *GetLimitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLimitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOwner() == nil {
		err := GetLimitsRequestValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLimitsRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLimitsRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLimitsRequestValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := GetLimitsRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLimitsRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLimitsRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLimitsRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetConsumedSince() == nil {
		err := GetLimitsRequestValidationError{
			field:  "ConsumedSince",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetLimitsRequestMultiError(errors)
	}

	return nil
}

// GetLimitsRequestMultiError is an error wrapping multiple validation errors
// returned by GetLimitsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLimitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLimitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLimitsRequestMultiError) AllErrors() []error { return m }

// GetLimitsRequestValidationError is the validation error returned by
// GetLimitsRequest.Validate if the designated constraints aren't met.
type GetLimitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLimitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLimitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLimitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLimitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLimitsRequestValidationError) ErrorName() string { return "GetLimitsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLimitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLimitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLimitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLimitsRequestValidationError{}

// Validate checks the field values on GetLimitsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLimitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLimitsResponseMultiError, or nil if none found.
func (m *GetLimitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLimitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	{
		sorted_keys := make([]string, len(m.GetSendLimitsByCurrency()))
		i := 0
		for key := range m.GetSendLimitsByCurrency() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSendLimitsByCurrency()[key]
			_ = val

			// no validation rules for SendLimitsByCurrency[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("SendLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("SendLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetLimitsResponseValidationError{
						field:  fmt.Sprintf("SendLimitsByCurrency[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetDepositLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLimitsResponseValidationError{
					field:  "DepositLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLimitsResponseValidationError{
					field:  "DepositLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLimitsResponseValidationError{
				field:  "DepositLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetMicroPaymentLimitsByCurrency()))
		i := 0
		for key := range m.GetMicroPaymentLimitsByCurrency() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMicroPaymentLimitsByCurrency()[key]
			_ = val

			// no validation rules for MicroPaymentLimitsByCurrency[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("MicroPaymentLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("MicroPaymentLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetLimitsResponseValidationError{
						field:  fmt.Sprintf("MicroPaymentLimitsByCurrency[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetBuyModuleLimitsByCurrency()))
		i := 0
		for key := range m.GetBuyModuleLimitsByCurrency() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBuyModuleLimitsByCurrency()[key]
			_ = val

			// no validation rules for BuyModuleLimitsByCurrency[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("BuyModuleLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetLimitsResponseValidationError{
							field:  fmt.Sprintf("BuyModuleLimitsByCurrency[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetLimitsResponseValidationError{
						field:  fmt.Sprintf("BuyModuleLimitsByCurrency[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetLimitsResponseMultiError(errors)
	}

	return nil
}

// GetLimitsResponseMultiError is an error wrapping multiple validation errors
// returned by GetLimitsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLimitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLimitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLimitsResponseMultiError) AllErrors() []error { return m }

// GetLimitsResponseValidationError is the validation error returned by
// GetLimitsResponse.Validate if the designated constraints aren't met.
type GetLimitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLimitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLimitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLimitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLimitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLimitsResponseValidationError) ErrorName() string {
	return "GetLimitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLimitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLimitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLimitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLimitsResponseValidationError{}

// Validate checks the field values on CanWithdrawToAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CanWithdrawToAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanWithdrawToAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanWithdrawToAccountRequestMultiError, or nil if none found.
func (m *CanWithdrawToAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CanWithdrawToAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccount() == nil {
		err := CanWithdrawToAccountRequestValidationError{
			field:  "Account",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanWithdrawToAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanWithdrawToAccountRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanWithdrawToAccountRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanWithdrawToAccountRequestMultiError(errors)
	}

	return nil
}

// CanWithdrawToAccountRequestMultiError is an error wrapping multiple
// validation errors returned by CanWithdrawToAccountRequest.ValidateAll() if
// the designated constraints aren't met.
type CanWithdrawToAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanWithdrawToAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanWithdrawToAccountRequestMultiError) AllErrors() []error { return m }

// CanWithdrawToAccountRequestValidationError is the validation error returned
// by CanWithdrawToAccountRequest.Validate if the designated constraints
// aren't met.
type CanWithdrawToAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanWithdrawToAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanWithdrawToAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanWithdrawToAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanWithdrawToAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanWithdrawToAccountRequestValidationError) ErrorName() string {
	return "CanWithdrawToAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CanWithdrawToAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanWithdrawToAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanWithdrawToAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanWithdrawToAccountRequestValidationError{}

// Validate checks the field values on CanWithdrawToAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CanWithdrawToAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanWithdrawToAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanWithdrawToAccountResponseMultiError, or nil if none found.
func (m *CanWithdrawToAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CanWithdrawToAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountType

	// no validation rules for IsValidPaymentDestination

	// no validation rules for RequiresInitialization

	if len(errors) > 0 {
		return CanWithdrawToAccountResponseMultiError(errors)
	}

	return nil
}

// CanWithdrawToAccountResponseMultiError is an error wrapping multiple
// validation errors returned by CanWithdrawToAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type CanWithdrawToAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanWithdrawToAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanWithdrawToAccountResponseMultiError) AllErrors() []error { return m }

// CanWithdrawToAccountResponseValidationError is the validation error returned
// by CanWithdrawToAccountResponse.Validate if the designated constraints
// aren't met.
type CanWithdrawToAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanWithdrawToAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanWithdrawToAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanWithdrawToAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanWithdrawToAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanWithdrawToAccountResponseValidationError) ErrorName() string {
	return "CanWithdrawToAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CanWithdrawToAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanWithdrawToAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanWithdrawToAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanWithdrawToAccountResponseValidationError{}

// Validate checks the field values on AirdropRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AirdropRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AirdropRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AirdropRequestMultiError,
// or nil if none found.
func (m *AirdropRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AirdropRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _AirdropRequest_AirdropType_NotInLookup[m.GetAirdropType()]; ok {
		err := AirdropRequestValidationError{
			field:  "AirdropType",
			reason: "value must not be in list [UNKNOWN GIVE_FIRST_KIN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOwner() == nil {
		err := AirdropRequestValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AirdropRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AirdropRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AirdropRequestValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := AirdropRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AirdropRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AirdropRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AirdropRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AirdropRequestMultiError(errors)
	}

	return nil
}

// AirdropRequestMultiError is an error wrapping multiple validation errors
// returned by AirdropRequest.ValidateAll() if the designated constraints
// aren't met.
type AirdropRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AirdropRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AirdropRequestMultiError) AllErrors() []error { return m }

// AirdropRequestValidationError is the validation error returned by
// AirdropRequest.Validate if the designated constraints aren't met.
type AirdropRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AirdropRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AirdropRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AirdropRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AirdropRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AirdropRequestValidationError) ErrorName() string { return "AirdropRequestValidationError" }

// Error satisfies the builtin error interface
func (e AirdropRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAirdropRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AirdropRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AirdropRequestValidationError{}

var _AirdropRequest_AirdropType_NotInLookup = map[AirdropType]struct{}{
	0: {},
	1: {},
}

// Validate checks the field values on AirdropResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AirdropResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AirdropResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AirdropResponseMultiError, or nil if none found.
func (m *AirdropResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AirdropResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetExchangeData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AirdropResponseValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AirdropResponseValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AirdropResponseValidationError{
				field:  "ExchangeData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AirdropResponseMultiError(errors)
	}

	return nil
}

// AirdropResponseMultiError is an error wrapping multiple validation errors
// returned by AirdropResponse.ValidateAll() if the designated constraints
// aren't met.
type AirdropResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AirdropResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AirdropResponseMultiError) AllErrors() []error { return m }

// AirdropResponseValidationError is the validation error returned by
// AirdropResponse.Validate if the designated constraints aren't met.
type AirdropResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AirdropResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AirdropResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AirdropResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AirdropResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AirdropResponseValidationError) ErrorName() string { return "AirdropResponseValidationError" }

// Error satisfies the builtin error interface
func (e AirdropResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAirdropResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AirdropResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AirdropResponseValidationError{}

// Validate checks the field values on SwapRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SwapRequestMultiError, or
// nil if none found.
func (m *SwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRequestPresent := false
	switch v := m.Request.(type) {
	case *SwapRequest_Initiate_:
		if v == nil {
			err := SwapRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetInitiate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapRequestValidationError{
						field:  "Initiate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapRequestValidationError{
						field:  "Initiate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInitiate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapRequestValidationError{
					field:  "Initiate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SwapRequest_SubmitSignature_:
		if v == nil {
			err := SwapRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetSubmitSignature()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapRequestValidationError{
						field:  "SubmitSignature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapRequestValidationError{
						field:  "SubmitSignature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubmitSignature()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapRequestValidationError{
					field:  "SubmitSignature",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRequestPresent {
		err := SwapRequestValidationError{
			field:  "Request",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SwapRequestMultiError(errors)
	}

	return nil
}

// SwapRequestMultiError is an error wrapping multiple validation errors
// returned by SwapRequest.ValidateAll() if the designated constraints aren't met.
type SwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapRequestMultiError) AllErrors() []error { return m }

// SwapRequestValidationError is the validation error returned by
// SwapRequest.Validate if the designated constraints aren't met.
type SwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapRequestValidationError) ErrorName() string { return "SwapRequestValidationError" }

// Error satisfies the builtin error interface
func (e SwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapRequestValidationError{}

// Validate checks the field values on SwapResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SwapResponseMultiError, or
// nil if none found.
func (m *SwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofResponsePresent := false
	switch v := m.Response.(type) {
	case *SwapResponse_ServerParameters_:
		if v == nil {
			err := SwapResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetServerParameters()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "ServerParameters",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "ServerParameters",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServerParameters()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapResponseValidationError{
					field:  "ServerParameters",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SwapResponse_Success_:
		if v == nil {
			err := SwapResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetSuccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapResponseValidationError{
					field:  "Success",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SwapResponse_Error_:
		if v == nil {
			err := SwapResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponsePresent {
		err := SwapResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SwapResponseMultiError(errors)
	}

	return nil
}

// SwapResponseMultiError is an error wrapping multiple validation errors
// returned by SwapResponse.ValidateAll() if the designated constraints aren't met.
type SwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapResponseMultiError) AllErrors() []error { return m }

// SwapResponseValidationError is the validation error returned by
// SwapResponse.Validate if the designated constraints aren't met.
type SwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapResponseValidationError) ErrorName() string { return "SwapResponseValidationError" }

// Error satisfies the builtin error interface
func (e SwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapResponseValidationError{}

// Validate checks the field values on DeclareFiatOnrampPurchaseAttemptRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeclareFiatOnrampPurchaseAttemptRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeclareFiatOnrampPurchaseAttemptRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// DeclareFiatOnrampPurchaseAttemptRequestMultiError, or nil if none found.
func (m *DeclareFiatOnrampPurchaseAttemptRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeclareFiatOnrampPurchaseAttemptRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOwner() == nil {
		err := DeclareFiatOnrampPurchaseAttemptRequestValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeclareFiatOnrampPurchaseAttemptRequestValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPurchaseAmount() == nil {
		err := DeclareFiatOnrampPurchaseAttemptRequestValidationError{
			field:  "PurchaseAmount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPurchaseAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "PurchaseAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "PurchaseAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPurchaseAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeclareFiatOnrampPurchaseAttemptRequestValidationError{
				field:  "PurchaseAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNonce() == nil {
		err := DeclareFiatOnrampPurchaseAttemptRequestValidationError{
			field:  "Nonce",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNonce()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNonce()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeclareFiatOnrampPurchaseAttemptRequestValidationError{
				field:  "Nonce",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := DeclareFiatOnrampPurchaseAttemptRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeclareFiatOnrampPurchaseAttemptRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeclareFiatOnrampPurchaseAttemptRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeclareFiatOnrampPurchaseAttemptRequestMultiError(errors)
	}

	return nil
}

// DeclareFiatOnrampPurchaseAttemptRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeclareFiatOnrampPurchaseAttemptRequest.ValidateAll() if the designated
// constraints aren't met.
type DeclareFiatOnrampPurchaseAttemptRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeclareFiatOnrampPurchaseAttemptRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeclareFiatOnrampPurchaseAttemptRequestMultiError) AllErrors() []error { return m }

// DeclareFiatOnrampPurchaseAttemptRequestValidationError is the validation
// error returned by DeclareFiatOnrampPurchaseAttemptRequest.Validate if the
// designated constraints aren't met.
type DeclareFiatOnrampPurchaseAttemptRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) ErrorName() string {
	return "DeclareFiatOnrampPurchaseAttemptRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeclareFiatOnrampPurchaseAttemptRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeclareFiatOnrampPurchaseAttemptRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeclareFiatOnrampPurchaseAttemptRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeclareFiatOnrampPurchaseAttemptRequestValidationError{}

// Validate checks the field values on DeclareFiatOnrampPurchaseAttemptResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeclareFiatOnrampPurchaseAttemptResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeclareFiatOnrampPurchaseAttemptResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeclareFiatOnrampPurchaseAttemptResponseMultiError, or nil if none found.
func (m *DeclareFiatOnrampPurchaseAttemptResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeclareFiatOnrampPurchaseAttemptResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return DeclareFiatOnrampPurchaseAttemptResponseMultiError(errors)
	}

	return nil
}

// DeclareFiatOnrampPurchaseAttemptResponseMultiError is an error wrapping
// multiple validation errors returned by
// DeclareFiatOnrampPurchaseAttemptResponse.ValidateAll() if the designated
// constraints aren't met.
type DeclareFiatOnrampPurchaseAttemptResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeclareFiatOnrampPurchaseAttemptResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeclareFiatOnrampPurchaseAttemptResponseMultiError) AllErrors() []error { return m }

// DeclareFiatOnrampPurchaseAttemptResponseValidationError is the validation
// error returned by DeclareFiatOnrampPurchaseAttemptResponse.Validate if the
// designated constraints aren't met.
type DeclareFiatOnrampPurchaseAttemptResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) ErrorName() string {
	return "DeclareFiatOnrampPurchaseAttemptResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeclareFiatOnrampPurchaseAttemptResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeclareFiatOnrampPurchaseAttemptResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeclareFiatOnrampPurchaseAttemptResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeclareFiatOnrampPurchaseAttemptResponseValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *Metadata_OpenAccounts:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetOpenAccounts()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "OpenAccounts",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "OpenAccounts",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenAccounts()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "OpenAccounts",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_SendPrivatePayment:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetSendPrivatePayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "SendPrivatePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "SendPrivatePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendPrivatePayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "SendPrivatePayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_ReceivePaymentsPrivately:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetReceivePaymentsPrivately()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "ReceivePaymentsPrivately",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "ReceivePaymentsPrivately",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReceivePaymentsPrivately()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "ReceivePaymentsPrivately",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_UpgradePrivacy:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetUpgradePrivacy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "UpgradePrivacy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "UpgradePrivacy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpgradePrivacy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "UpgradePrivacy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_SendPublicPayment:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetSendPublicPayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "SendPublicPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "SendPublicPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendPublicPayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "SendPublicPayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_ReceivePaymentsPublicly:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetReceivePaymentsPublicly()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "ReceivePaymentsPublicly",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "ReceivePaymentsPublicly",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReceivePaymentsPublicly()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "ReceivePaymentsPublicly",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Metadata_EstablishRelationship:
		if v == nil {
			err := MetadataValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetEstablishRelationship()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "EstablishRelationship",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataValidationError{
						field:  "EstablishRelationship",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEstablishRelationship()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataValidationError{
					field:  "EstablishRelationship",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := MetadataValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on OpenAccountsMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OpenAccountsMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAccountsMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenAccountsMetadataMultiError, or nil if none found.
func (m *OpenAccountsMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAccountsMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OpenAccountsMetadataMultiError(errors)
	}

	return nil
}

// OpenAccountsMetadataMultiError is an error wrapping multiple validation
// errors returned by OpenAccountsMetadata.ValidateAll() if the designated
// constraints aren't met.
type OpenAccountsMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAccountsMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAccountsMetadataMultiError) AllErrors() []error { return m }

// OpenAccountsMetadataValidationError is the validation error returned by
// OpenAccountsMetadata.Validate if the designated constraints aren't met.
type OpenAccountsMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAccountsMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAccountsMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAccountsMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAccountsMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAccountsMetadataValidationError) ErrorName() string {
	return "OpenAccountsMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e OpenAccountsMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAccountsMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAccountsMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAccountsMetadataValidationError{}

// Validate checks the field values on SendPrivatePaymentMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendPrivatePaymentMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendPrivatePaymentMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendPrivatePaymentMetadataMultiError, or nil if none found.
func (m *SendPrivatePaymentMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SendPrivatePaymentMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDestination() == nil {
		err := SendPrivatePaymentMetadataValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPrivatePaymentMetadataValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetExchangeData() == nil {
		err := SendPrivatePaymentMetadataValidationError{
			field:  "ExchangeData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetExchangeData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPrivatePaymentMetadataValidationError{
				field:  "ExchangeData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsWithdrawal

	// no validation rules for IsRemoteSend

	// no validation rules for IsTip

	if all {
		switch v := interface{}(m.GetTippedUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "TippedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPrivatePaymentMetadataValidationError{
					field:  "TippedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTippedUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPrivatePaymentMetadataValidationError{
				field:  "TippedUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendPrivatePaymentMetadataMultiError(errors)
	}

	return nil
}

// SendPrivatePaymentMetadataMultiError is an error wrapping multiple
// validation errors returned by SendPrivatePaymentMetadata.ValidateAll() if
// the designated constraints aren't met.
type SendPrivatePaymentMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendPrivatePaymentMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendPrivatePaymentMetadataMultiError) AllErrors() []error { return m }

// SendPrivatePaymentMetadataValidationError is the validation error returned
// by SendPrivatePaymentMetadata.Validate if the designated constraints aren't met.
type SendPrivatePaymentMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendPrivatePaymentMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendPrivatePaymentMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendPrivatePaymentMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendPrivatePaymentMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendPrivatePaymentMetadataValidationError) ErrorName() string {
	return "SendPrivatePaymentMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e SendPrivatePaymentMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendPrivatePaymentMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendPrivatePaymentMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendPrivatePaymentMetadataValidationError{}

// Validate checks the field values on SendPublicPaymentMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendPublicPaymentMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendPublicPaymentMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendPublicPaymentMetadataMultiError, or nil if none found.
func (m *SendPublicPaymentMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SendPublicPaymentMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPublicPaymentMetadataValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		err := SendPublicPaymentMetadataValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPublicPaymentMetadataValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetExchangeData() == nil {
		err := SendPublicPaymentMetadataValidationError{
			field:  "ExchangeData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetExchangeData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendPublicPaymentMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendPublicPaymentMetadataValidationError{
				field:  "ExchangeData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetIsWithdrawal() != true {
		err := SendPublicPaymentMetadataValidationError{
			field:  "IsWithdrawal",
			reason: "value must equal true",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SendPublicPaymentMetadataMultiError(errors)
	}

	return nil
}

// SendPublicPaymentMetadataMultiError is an error wrapping multiple validation
// errors returned by SendPublicPaymentMetadata.ValidateAll() if the
// designated constraints aren't met.
type SendPublicPaymentMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendPublicPaymentMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendPublicPaymentMetadataMultiError) AllErrors() []error { return m }

// SendPublicPaymentMetadataValidationError is the validation error returned by
// SendPublicPaymentMetadata.Validate if the designated constraints aren't met.
type SendPublicPaymentMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendPublicPaymentMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendPublicPaymentMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendPublicPaymentMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendPublicPaymentMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendPublicPaymentMetadataValidationError) ErrorName() string {
	return "SendPublicPaymentMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e SendPublicPaymentMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendPublicPaymentMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendPublicPaymentMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendPublicPaymentMetadataValidationError{}

// Validate checks the field values on ReceivePaymentsPrivatelyMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReceivePaymentsPrivatelyMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceivePaymentsPrivatelyMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReceivePaymentsPrivatelyMetadataMultiError, or nil if none found.
func (m *ReceivePaymentsPrivatelyMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceivePaymentsPrivatelyMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSource() == nil {
		err := ReceivePaymentsPrivatelyMetadataValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceivePaymentsPrivatelyMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceivePaymentsPrivatelyMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceivePaymentsPrivatelyMetadataValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetQuarks() <= 0 {
		err := ReceivePaymentsPrivatelyMetadataValidationError{
			field:  "Quarks",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsDeposit

	if len(errors) > 0 {
		return ReceivePaymentsPrivatelyMetadataMultiError(errors)
	}

	return nil
}

// ReceivePaymentsPrivatelyMetadataMultiError is an error wrapping multiple
// validation errors returned by
// ReceivePaymentsPrivatelyMetadata.ValidateAll() if the designated
// constraints aren't met.
type ReceivePaymentsPrivatelyMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceivePaymentsPrivatelyMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceivePaymentsPrivatelyMetadataMultiError) AllErrors() []error { return m }

// ReceivePaymentsPrivatelyMetadataValidationError is the validation error
// returned by ReceivePaymentsPrivatelyMetadata.Validate if the designated
// constraints aren't met.
type ReceivePaymentsPrivatelyMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceivePaymentsPrivatelyMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceivePaymentsPrivatelyMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceivePaymentsPrivatelyMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceivePaymentsPrivatelyMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceivePaymentsPrivatelyMetadataValidationError) ErrorName() string {
	return "ReceivePaymentsPrivatelyMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ReceivePaymentsPrivatelyMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceivePaymentsPrivatelyMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceivePaymentsPrivatelyMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceivePaymentsPrivatelyMetadataValidationError{}

// Validate checks the field values on ReceivePaymentsPubliclyMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceivePaymentsPubliclyMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceivePaymentsPubliclyMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReceivePaymentsPubliclyMetadataMultiError, or nil if none found.
func (m *ReceivePaymentsPubliclyMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceivePaymentsPubliclyMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSource() == nil {
		err := ReceivePaymentsPubliclyMetadataValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceivePaymentsPubliclyMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceivePaymentsPubliclyMetadataValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceivePaymentsPubliclyMetadataValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetQuarks() <= 0 {
		err := ReceivePaymentsPubliclyMetadataValidationError{
			field:  "Quarks",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIsRemoteSend() != true {
		err := ReceivePaymentsPubliclyMetadataValidationError{
			field:  "IsRemoteSend",
			reason: "value must equal true",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsIssuerVoidingGiftCard

	if all {
		switch v := interface{}(m.GetExchangeData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceivePaymentsPubliclyMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceivePaymentsPubliclyMetadataValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceivePaymentsPubliclyMetadataValidationError{
				field:  "ExchangeData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceivePaymentsPubliclyMetadataMultiError(errors)
	}

	return nil
}

// ReceivePaymentsPubliclyMetadataMultiError is an error wrapping multiple
// validation errors returned by ReceivePaymentsPubliclyMetadata.ValidateAll()
// if the designated constraints aren't met.
type ReceivePaymentsPubliclyMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceivePaymentsPubliclyMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceivePaymentsPubliclyMetadataMultiError) AllErrors() []error { return m }

// ReceivePaymentsPubliclyMetadataValidationError is the validation error
// returned by ReceivePaymentsPubliclyMetadata.Validate if the designated
// constraints aren't met.
type ReceivePaymentsPubliclyMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceivePaymentsPubliclyMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceivePaymentsPubliclyMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceivePaymentsPubliclyMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceivePaymentsPubliclyMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceivePaymentsPubliclyMetadataValidationError) ErrorName() string {
	return "ReceivePaymentsPubliclyMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ReceivePaymentsPubliclyMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceivePaymentsPubliclyMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceivePaymentsPubliclyMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceivePaymentsPubliclyMetadataValidationError{}

// Validate checks the field values on UpgradePrivacyMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradePrivacyMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradePrivacyMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradePrivacyMetadataMultiError, or nil if none found.
func (m *UpgradePrivacyMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradePrivacyMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpgradePrivacyMetadataMultiError(errors)
	}

	return nil
}

// UpgradePrivacyMetadataMultiError is an error wrapping multiple validation
// errors returned by UpgradePrivacyMetadata.ValidateAll() if the designated
// constraints aren't met.
type UpgradePrivacyMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradePrivacyMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradePrivacyMetadataMultiError) AllErrors() []error { return m }

// UpgradePrivacyMetadataValidationError is the validation error returned by
// UpgradePrivacyMetadata.Validate if the designated constraints aren't met.
type UpgradePrivacyMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradePrivacyMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradePrivacyMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradePrivacyMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradePrivacyMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradePrivacyMetadataValidationError) ErrorName() string {
	return "UpgradePrivacyMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradePrivacyMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradePrivacyMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradePrivacyMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradePrivacyMetadataValidationError{}

// Validate checks the field values on EstablishRelationshipMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EstablishRelationshipMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EstablishRelationshipMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EstablishRelationshipMetadataMultiError, or nil if none found.
func (m *EstablishRelationshipMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *EstablishRelationshipMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRelationship() == nil {
		err := EstablishRelationshipMetadataValidationError{
			field:  "Relationship",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRelationship()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EstablishRelationshipMetadataValidationError{
					field:  "Relationship",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EstablishRelationshipMetadataValidationError{
					field:  "Relationship",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationship()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EstablishRelationshipMetadataValidationError{
				field:  "Relationship",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EstablishRelationshipMetadataMultiError(errors)
	}

	return nil
}

// EstablishRelationshipMetadataMultiError is an error wrapping multiple
// validation errors returned by EstablishRelationshipMetadata.ValidateAll()
// if the designated constraints aren't met.
type EstablishRelationshipMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EstablishRelationshipMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EstablishRelationshipMetadataMultiError) AllErrors() []error { return m }

// EstablishRelationshipMetadataValidationError is the validation error
// returned by EstablishRelationshipMetadata.Validate if the designated
// constraints aren't met.
type EstablishRelationshipMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EstablishRelationshipMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EstablishRelationshipMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EstablishRelationshipMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EstablishRelationshipMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EstablishRelationshipMetadataValidationError) ErrorName() string {
	return "EstablishRelationshipMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e EstablishRelationshipMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEstablishRelationshipMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EstablishRelationshipMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EstablishRelationshipMetadataValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *Action_OpenAccount:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetOpenAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "OpenAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "OpenAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "OpenAccount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_NoPrivacyTransfer:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetNoPrivacyTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "NoPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "NoPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoPrivacyTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "NoPrivacyTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_NoPrivacyWithdraw:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetNoPrivacyWithdraw()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "NoPrivacyWithdraw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "NoPrivacyWithdraw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoPrivacyWithdraw()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "NoPrivacyWithdraw",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_TemporaryPrivacyTransfer:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTemporaryPrivacyTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "TemporaryPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "TemporaryPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemporaryPrivacyTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "TemporaryPrivacyTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_TemporaryPrivacyExchange:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTemporaryPrivacyExchange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "TemporaryPrivacyExchange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "TemporaryPrivacyExchange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemporaryPrivacyExchange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "TemporaryPrivacyExchange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_PermanentPrivacyUpgrade:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetPermanentPrivacyUpgrade()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "PermanentPrivacyUpgrade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "PermanentPrivacyUpgrade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermanentPrivacyUpgrade()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "PermanentPrivacyUpgrade",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Action_FeePayment:
		if v == nil {
			err := ActionValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetFeePayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "FeePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionValidationError{
						field:  "FeePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFeePayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionValidationError{
					field:  "FeePayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := ActionValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on OpenAccountAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OpenAccountAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAccountAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenAccountActionMultiError, or nil if none found.
func (m *OpenAccountAction) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAccountAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _OpenAccountAction_AccountType_NotInLookup[m.GetAccountType()]; ok {
		err := OpenAccountActionValidationError{
			field:  "AccountType",
			reason: "value must not be in list [UNKNOWN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOwner() == nil {
		err := OpenAccountActionValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAccountActionValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Index

	if m.GetAuthority() == nil {
		err := OpenAccountActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAccountActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetToken() == nil {
		err := OpenAccountActionValidationError{
			field:  "Token",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAccountActionValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAuthoritySignature() == nil {
		err := OpenAccountActionValidationError{
			field:  "AuthoritySignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthoritySignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "AuthoritySignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenAccountActionValidationError{
					field:  "AuthoritySignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthoritySignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenAccountActionValidationError{
				field:  "AuthoritySignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OpenAccountActionMultiError(errors)
	}

	return nil
}

// OpenAccountActionMultiError is an error wrapping multiple validation errors
// returned by OpenAccountAction.ValidateAll() if the designated constraints
// aren't met.
type OpenAccountActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAccountActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAccountActionMultiError) AllErrors() []error { return m }

// OpenAccountActionValidationError is the validation error returned by
// OpenAccountAction.Validate if the designated constraints aren't met.
type OpenAccountActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAccountActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAccountActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAccountActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAccountActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAccountActionValidationError) ErrorName() string {
	return "OpenAccountActionValidationError"
}

// Error satisfies the builtin error interface
func (e OpenAccountActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAccountAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAccountActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAccountActionValidationError{}

var _OpenAccountAction_AccountType_NotInLookup = map[common.AccountType]struct{}{
	0: {},
}

// Validate checks the field values on NoPrivacyTransferAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NoPrivacyTransferAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoPrivacyTransferAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NoPrivacyTransferActionMultiError, or nil if none found.
func (m *NoPrivacyTransferAction) ValidateAll() error {
	return m.validate(true)
}

func (m *NoPrivacyTransferAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuthority() == nil {
		err := NoPrivacyTransferActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyTransferActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSource() == nil {
		err := NoPrivacyTransferActionValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyTransferActionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		err := NoPrivacyTransferActionValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyTransferActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyTransferActionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAmount() <= 0 {
		err := NoPrivacyTransferActionValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NoPrivacyTransferActionMultiError(errors)
	}

	return nil
}

// NoPrivacyTransferActionMultiError is an error wrapping multiple validation
// errors returned by NoPrivacyTransferAction.ValidateAll() if the designated
// constraints aren't met.
type NoPrivacyTransferActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoPrivacyTransferActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoPrivacyTransferActionMultiError) AllErrors() []error { return m }

// NoPrivacyTransferActionValidationError is the validation error returned by
// NoPrivacyTransferAction.Validate if the designated constraints aren't met.
type NoPrivacyTransferActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoPrivacyTransferActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoPrivacyTransferActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoPrivacyTransferActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoPrivacyTransferActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoPrivacyTransferActionValidationError) ErrorName() string {
	return "NoPrivacyTransferActionValidationError"
}

// Error satisfies the builtin error interface
func (e NoPrivacyTransferActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoPrivacyTransferAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoPrivacyTransferActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoPrivacyTransferActionValidationError{}

// Validate checks the field values on NoPrivacyWithdrawAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NoPrivacyWithdrawAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoPrivacyWithdrawAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NoPrivacyWithdrawActionMultiError, or nil if none found.
func (m *NoPrivacyWithdrawAction) ValidateAll() error {
	return m.validate(true)
}

func (m *NoPrivacyWithdrawAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuthority() == nil {
		err := NoPrivacyWithdrawActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyWithdrawActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSource() == nil {
		err := NoPrivacyWithdrawActionValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyWithdrawActionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		err := NoPrivacyWithdrawActionValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoPrivacyWithdrawActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoPrivacyWithdrawActionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAmount() <= 0 {
		err := NoPrivacyWithdrawActionValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetShouldClose() != true {
		err := NoPrivacyWithdrawActionValidationError{
			field:  "ShouldClose",
			reason: "value must equal true",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NoPrivacyWithdrawActionMultiError(errors)
	}

	return nil
}

// NoPrivacyWithdrawActionMultiError is an error wrapping multiple validation
// errors returned by NoPrivacyWithdrawAction.ValidateAll() if the designated
// constraints aren't met.
type NoPrivacyWithdrawActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoPrivacyWithdrawActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoPrivacyWithdrawActionMultiError) AllErrors() []error { return m }

// NoPrivacyWithdrawActionValidationError is the validation error returned by
// NoPrivacyWithdrawAction.Validate if the designated constraints aren't met.
type NoPrivacyWithdrawActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoPrivacyWithdrawActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoPrivacyWithdrawActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoPrivacyWithdrawActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoPrivacyWithdrawActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoPrivacyWithdrawActionValidationError) ErrorName() string {
	return "NoPrivacyWithdrawActionValidationError"
}

// Error satisfies the builtin error interface
func (e NoPrivacyWithdrawActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoPrivacyWithdrawAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoPrivacyWithdrawActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoPrivacyWithdrawActionValidationError{}

// Validate checks the field values on TemporaryPrivacyTransferAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemporaryPrivacyTransferAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemporaryPrivacyTransferAction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TemporaryPrivacyTransferActionMultiError, or nil if none found.
func (m *TemporaryPrivacyTransferAction) ValidateAll() error {
	return m.validate(true)
}

func (m *TemporaryPrivacyTransferAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuthority() == nil {
		err := TemporaryPrivacyTransferActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyTransferActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSource() == nil {
		err := TemporaryPrivacyTransferActionValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyTransferActionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		err := TemporaryPrivacyTransferActionValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyTransferActionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAmount() <= 0 {
		err := TemporaryPrivacyTransferActionValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TemporaryPrivacyTransferActionMultiError(errors)
	}

	return nil
}

// TemporaryPrivacyTransferActionMultiError is an error wrapping multiple
// validation errors returned by TemporaryPrivacyTransferAction.ValidateAll()
// if the designated constraints aren't met.
type TemporaryPrivacyTransferActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemporaryPrivacyTransferActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemporaryPrivacyTransferActionMultiError) AllErrors() []error { return m }

// TemporaryPrivacyTransferActionValidationError is the validation error
// returned by TemporaryPrivacyTransferAction.Validate if the designated
// constraints aren't met.
type TemporaryPrivacyTransferActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemporaryPrivacyTransferActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemporaryPrivacyTransferActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemporaryPrivacyTransferActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemporaryPrivacyTransferActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemporaryPrivacyTransferActionValidationError) ErrorName() string {
	return "TemporaryPrivacyTransferActionValidationError"
}

// Error satisfies the builtin error interface
func (e TemporaryPrivacyTransferActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemporaryPrivacyTransferAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemporaryPrivacyTransferActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemporaryPrivacyTransferActionValidationError{}

// Validate checks the field values on TemporaryPrivacyExchangeAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemporaryPrivacyExchangeAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemporaryPrivacyExchangeAction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TemporaryPrivacyExchangeActionMultiError, or nil if none found.
func (m *TemporaryPrivacyExchangeAction) ValidateAll() error {
	return m.validate(true)
}

func (m *TemporaryPrivacyExchangeAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAuthority() == nil {
		err := TemporaryPrivacyExchangeActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyExchangeActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSource() == nil {
		err := TemporaryPrivacyExchangeActionValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyExchangeActionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		err := TemporaryPrivacyExchangeActionValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyExchangeActionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAmount() <= 0 {
		err := TemporaryPrivacyExchangeActionValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TemporaryPrivacyExchangeActionMultiError(errors)
	}

	return nil
}

// TemporaryPrivacyExchangeActionMultiError is an error wrapping multiple
// validation errors returned by TemporaryPrivacyExchangeAction.ValidateAll()
// if the designated constraints aren't met.
type TemporaryPrivacyExchangeActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemporaryPrivacyExchangeActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemporaryPrivacyExchangeActionMultiError) AllErrors() []error { return m }

// TemporaryPrivacyExchangeActionValidationError is the validation error
// returned by TemporaryPrivacyExchangeAction.Validate if the designated
// constraints aren't met.
type TemporaryPrivacyExchangeActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemporaryPrivacyExchangeActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemporaryPrivacyExchangeActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemporaryPrivacyExchangeActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemporaryPrivacyExchangeActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemporaryPrivacyExchangeActionValidationError) ErrorName() string {
	return "TemporaryPrivacyExchangeActionValidationError"
}

// Error satisfies the builtin error interface
func (e TemporaryPrivacyExchangeActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemporaryPrivacyExchangeAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemporaryPrivacyExchangeActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemporaryPrivacyExchangeActionValidationError{}

// Validate checks the field values on PermanentPrivacyUpgradeAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PermanentPrivacyUpgradeAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermanentPrivacyUpgradeAction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PermanentPrivacyUpgradeActionMultiError, or nil if none found.
func (m *PermanentPrivacyUpgradeAction) ValidateAll() error {
	return m.validate(true)
}

func (m *PermanentPrivacyUpgradeAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionId

	if len(errors) > 0 {
		return PermanentPrivacyUpgradeActionMultiError(errors)
	}

	return nil
}

// PermanentPrivacyUpgradeActionMultiError is an error wrapping multiple
// validation errors returned by PermanentPrivacyUpgradeAction.ValidateAll()
// if the designated constraints aren't met.
type PermanentPrivacyUpgradeActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermanentPrivacyUpgradeActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermanentPrivacyUpgradeActionMultiError) AllErrors() []error { return m }

// PermanentPrivacyUpgradeActionValidationError is the validation error
// returned by PermanentPrivacyUpgradeAction.Validate if the designated
// constraints aren't met.
type PermanentPrivacyUpgradeActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermanentPrivacyUpgradeActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermanentPrivacyUpgradeActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermanentPrivacyUpgradeActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermanentPrivacyUpgradeActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermanentPrivacyUpgradeActionValidationError) ErrorName() string {
	return "PermanentPrivacyUpgradeActionValidationError"
}

// Error satisfies the builtin error interface
func (e PermanentPrivacyUpgradeActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermanentPrivacyUpgradeAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermanentPrivacyUpgradeActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermanentPrivacyUpgradeActionValidationError{}

// Validate checks the field values on FeePaymentAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FeePaymentAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeePaymentAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeePaymentActionMultiError, or nil if none found.
func (m *FeePaymentAction) ValidateAll() error {
	return m.validate(true)
}

func (m *FeePaymentAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if m.GetAuthority() == nil {
		err := FeePaymentActionValidationError{
			field:  "Authority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Authority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FeePaymentActionValidationError{
				field:  "Authority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSource() == nil {
		err := FeePaymentActionValidationError{
			field:  "Source",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FeePaymentActionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAmount() <= 0 {
		err := FeePaymentActionValidationError{
			field:  "Amount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FeePaymentActionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FeePaymentActionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FeePaymentActionMultiError(errors)
	}

	return nil
}

// FeePaymentActionMultiError is an error wrapping multiple validation errors
// returned by FeePaymentAction.ValidateAll() if the designated constraints
// aren't met.
type FeePaymentActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeePaymentActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeePaymentActionMultiError) AllErrors() []error { return m }

// FeePaymentActionValidationError is the validation error returned by
// FeePaymentAction.Validate if the designated constraints aren't met.
type FeePaymentActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeePaymentActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeePaymentActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeePaymentActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeePaymentActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeePaymentActionValidationError) ErrorName() string { return "FeePaymentActionValidationError" }

// Error satisfies the builtin error interface
func (e FeePaymentActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeePaymentAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeePaymentActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeePaymentActionValidationError{}

// Validate checks the field values on ServerParameter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerParameterMultiError, or nil if none found.
func (m *ServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionId

	if len(m.GetNonces()) > 1 {
		err := ServerParameterValidationError{
			field:  "Nonces",
			reason: "value must contain no more than 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNonces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  fmt.Sprintf("Nonces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  fmt.Sprintf("Nonces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  fmt.Sprintf("Nonces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *ServerParameter_OpenAccount:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetOpenAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "OpenAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "OpenAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "OpenAccount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_NoPrivacyTransfer:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetNoPrivacyTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "NoPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "NoPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoPrivacyTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "NoPrivacyTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_NoPrivacyWithdraw:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetNoPrivacyWithdraw()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "NoPrivacyWithdraw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "NoPrivacyWithdraw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNoPrivacyWithdraw()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "NoPrivacyWithdraw",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_TemporaryPrivacyTransfer:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTemporaryPrivacyTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "TemporaryPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "TemporaryPrivacyTransfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemporaryPrivacyTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "TemporaryPrivacyTransfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_TemporaryPrivacyExchange:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTemporaryPrivacyExchange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "TemporaryPrivacyExchange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "TemporaryPrivacyExchange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemporaryPrivacyExchange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "TemporaryPrivacyExchange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_PermanentPrivacyUpgrade:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetPermanentPrivacyUpgrade()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "PermanentPrivacyUpgrade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "PermanentPrivacyUpgrade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermanentPrivacyUpgrade()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "PermanentPrivacyUpgrade",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerParameter_FeePayment:
		if v == nil {
			err := ServerParameterValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetFeePayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "FeePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerParameterValidationError{
						field:  "FeePayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFeePayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerParameterValidationError{
					field:  "FeePayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := ServerParameterValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServerParameterMultiError(errors)
	}

	return nil
}

// ServerParameterMultiError is an error wrapping multiple validation errors
// returned by ServerParameter.ValidateAll() if the designated constraints
// aren't met.
type ServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerParameterMultiError) AllErrors() []error { return m }

// ServerParameterValidationError is the validation error returned by
// ServerParameter.Validate if the designated constraints aren't met.
type ServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerParameterValidationError) ErrorName() string { return "ServerParameterValidationError" }

// Error satisfies the builtin error interface
func (e ServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerParameterValidationError{}

// Validate checks the field values on NoncedTransactionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NoncedTransactionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoncedTransactionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NoncedTransactionMetadataMultiError, or nil if none found.
func (m *NoncedTransactionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *NoncedTransactionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNonce() == nil {
		err := NoncedTransactionMetadataValidationError{
			field:  "Nonce",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNonce()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoncedTransactionMetadataValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoncedTransactionMetadataValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNonce()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoncedTransactionMetadataValidationError{
				field:  "Nonce",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetBlockhash() == nil {
		err := NoncedTransactionMetadataValidationError{
			field:  "Blockhash",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBlockhash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoncedTransactionMetadataValidationError{
					field:  "Blockhash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoncedTransactionMetadataValidationError{
					field:  "Blockhash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockhash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoncedTransactionMetadataValidationError{
				field:  "Blockhash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NoncedTransactionMetadataMultiError(errors)
	}

	return nil
}

// NoncedTransactionMetadataMultiError is an error wrapping multiple validation
// errors returned by NoncedTransactionMetadata.ValidateAll() if the
// designated constraints aren't met.
type NoncedTransactionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoncedTransactionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoncedTransactionMetadataMultiError) AllErrors() []error { return m }

// NoncedTransactionMetadataValidationError is the validation error returned by
// NoncedTransactionMetadata.Validate if the designated constraints aren't met.
type NoncedTransactionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoncedTransactionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoncedTransactionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoncedTransactionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoncedTransactionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoncedTransactionMetadataValidationError) ErrorName() string {
	return "NoncedTransactionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e NoncedTransactionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoncedTransactionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoncedTransactionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoncedTransactionMetadataValidationError{}

// Validate checks the field values on OpenAccountServerParameter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OpenAccountServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAccountServerParameter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenAccountServerParameterMultiError, or nil if none found.
func (m *OpenAccountServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAccountServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OpenAccountServerParameterMultiError(errors)
	}

	return nil
}

// OpenAccountServerParameterMultiError is an error wrapping multiple
// validation errors returned by OpenAccountServerParameter.ValidateAll() if
// the designated constraints aren't met.
type OpenAccountServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAccountServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAccountServerParameterMultiError) AllErrors() []error { return m }

// OpenAccountServerParameterValidationError is the validation error returned
// by OpenAccountServerParameter.Validate if the designated constraints aren't met.
type OpenAccountServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAccountServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAccountServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAccountServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAccountServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAccountServerParameterValidationError) ErrorName() string {
	return "OpenAccountServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e OpenAccountServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAccountServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAccountServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAccountServerParameterValidationError{}

// Validate checks the field values on NoPrivacyTransferServerParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *NoPrivacyTransferServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoPrivacyTransferServerParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// NoPrivacyTransferServerParameterMultiError, or nil if none found.
func (m *NoPrivacyTransferServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *NoPrivacyTransferServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NoPrivacyTransferServerParameterMultiError(errors)
	}

	return nil
}

// NoPrivacyTransferServerParameterMultiError is an error wrapping multiple
// validation errors returned by
// NoPrivacyTransferServerParameter.ValidateAll() if the designated
// constraints aren't met.
type NoPrivacyTransferServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoPrivacyTransferServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoPrivacyTransferServerParameterMultiError) AllErrors() []error { return m }

// NoPrivacyTransferServerParameterValidationError is the validation error
// returned by NoPrivacyTransferServerParameter.Validate if the designated
// constraints aren't met.
type NoPrivacyTransferServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoPrivacyTransferServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoPrivacyTransferServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoPrivacyTransferServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoPrivacyTransferServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoPrivacyTransferServerParameterValidationError) ErrorName() string {
	return "NoPrivacyTransferServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e NoPrivacyTransferServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoPrivacyTransferServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoPrivacyTransferServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoPrivacyTransferServerParameterValidationError{}

// Validate checks the field values on NoPrivacyWithdrawServerParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *NoPrivacyWithdrawServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoPrivacyWithdrawServerParameter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// NoPrivacyWithdrawServerParameterMultiError, or nil if none found.
func (m *NoPrivacyWithdrawServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *NoPrivacyWithdrawServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NoPrivacyWithdrawServerParameterMultiError(errors)
	}

	return nil
}

// NoPrivacyWithdrawServerParameterMultiError is an error wrapping multiple
// validation errors returned by
// NoPrivacyWithdrawServerParameter.ValidateAll() if the designated
// constraints aren't met.
type NoPrivacyWithdrawServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoPrivacyWithdrawServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoPrivacyWithdrawServerParameterMultiError) AllErrors() []error { return m }

// NoPrivacyWithdrawServerParameterValidationError is the validation error
// returned by NoPrivacyWithdrawServerParameter.Validate if the designated
// constraints aren't met.
type NoPrivacyWithdrawServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoPrivacyWithdrawServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoPrivacyWithdrawServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoPrivacyWithdrawServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoPrivacyWithdrawServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoPrivacyWithdrawServerParameterValidationError) ErrorName() string {
	return "NoPrivacyWithdrawServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e NoPrivacyWithdrawServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoPrivacyWithdrawServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoPrivacyWithdrawServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoPrivacyWithdrawServerParameterValidationError{}

// Validate checks the field values on TemporaryPrivacyTransferServerParameter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TemporaryPrivacyTransferServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TemporaryPrivacyTransferServerParameter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// TemporaryPrivacyTransferServerParameterMultiError, or nil if none found.
func (m *TemporaryPrivacyTransferServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *TemporaryPrivacyTransferServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTreasury() == nil {
		err := TemporaryPrivacyTransferServerParameterValidationError{
			field:  "Treasury",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTreasury()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferServerParameterValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferServerParameterValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreasury()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyTransferServerParameterValidationError{
				field:  "Treasury",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRecentRoot() == nil {
		err := TemporaryPrivacyTransferServerParameterValidationError{
			field:  "RecentRoot",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecentRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferServerParameterValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyTransferServerParameterValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecentRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyTransferServerParameterValidationError{
				field:  "RecentRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TemporaryPrivacyTransferServerParameterMultiError(errors)
	}

	return nil
}

// TemporaryPrivacyTransferServerParameterMultiError is an error wrapping
// multiple validation errors returned by
// TemporaryPrivacyTransferServerParameter.ValidateAll() if the designated
// constraints aren't met.
type TemporaryPrivacyTransferServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemporaryPrivacyTransferServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemporaryPrivacyTransferServerParameterMultiError) AllErrors() []error { return m }

// TemporaryPrivacyTransferServerParameterValidationError is the validation
// error returned by TemporaryPrivacyTransferServerParameter.Validate if the
// designated constraints aren't met.
type TemporaryPrivacyTransferServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemporaryPrivacyTransferServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemporaryPrivacyTransferServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemporaryPrivacyTransferServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemporaryPrivacyTransferServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemporaryPrivacyTransferServerParameterValidationError) ErrorName() string {
	return "TemporaryPrivacyTransferServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e TemporaryPrivacyTransferServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemporaryPrivacyTransferServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemporaryPrivacyTransferServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemporaryPrivacyTransferServerParameterValidationError{}

// Validate checks the field values on TemporaryPrivacyExchangeServerParameter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TemporaryPrivacyExchangeServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TemporaryPrivacyExchangeServerParameter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// TemporaryPrivacyExchangeServerParameterMultiError, or nil if none found.
func (m *TemporaryPrivacyExchangeServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *TemporaryPrivacyExchangeServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTreasury() == nil {
		err := TemporaryPrivacyExchangeServerParameterValidationError{
			field:  "Treasury",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTreasury()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeServerParameterValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeServerParameterValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreasury()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyExchangeServerParameterValidationError{
				field:  "Treasury",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRecentRoot() == nil {
		err := TemporaryPrivacyExchangeServerParameterValidationError{
			field:  "RecentRoot",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecentRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeServerParameterValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemporaryPrivacyExchangeServerParameterValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecentRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemporaryPrivacyExchangeServerParameterValidationError{
				field:  "RecentRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TemporaryPrivacyExchangeServerParameterMultiError(errors)
	}

	return nil
}

// TemporaryPrivacyExchangeServerParameterMultiError is an error wrapping
// multiple validation errors returned by
// TemporaryPrivacyExchangeServerParameter.ValidateAll() if the designated
// constraints aren't met.
type TemporaryPrivacyExchangeServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemporaryPrivacyExchangeServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemporaryPrivacyExchangeServerParameterMultiError) AllErrors() []error { return m }

// TemporaryPrivacyExchangeServerParameterValidationError is the validation
// error returned by TemporaryPrivacyExchangeServerParameter.Validate if the
// designated constraints aren't met.
type TemporaryPrivacyExchangeServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemporaryPrivacyExchangeServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemporaryPrivacyExchangeServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemporaryPrivacyExchangeServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemporaryPrivacyExchangeServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemporaryPrivacyExchangeServerParameterValidationError) ErrorName() string {
	return "TemporaryPrivacyExchangeServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e TemporaryPrivacyExchangeServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemporaryPrivacyExchangeServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemporaryPrivacyExchangeServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemporaryPrivacyExchangeServerParameterValidationError{}

// Validate checks the field values on PermanentPrivacyUpgradeServerParameter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PermanentPrivacyUpgradeServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PermanentPrivacyUpgradeServerParameter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// PermanentPrivacyUpgradeServerParameterMultiError, or nil if none found.
func (m *PermanentPrivacyUpgradeServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *PermanentPrivacyUpgradeServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNewCommitment() == nil {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "NewCommitment",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNewCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermanentPrivacyUpgradeServerParameterValidationError{
				field:  "NewCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNewCommitmentTranscript() == nil {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "NewCommitmentTranscript",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNewCommitmentTranscript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitmentTranscript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitmentTranscript",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewCommitmentTranscript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermanentPrivacyUpgradeServerParameterValidationError{
				field:  "NewCommitmentTranscript",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNewCommitmentDestination() == nil {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "NewCommitmentDestination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNewCommitmentDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitmentDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "NewCommitmentDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewCommitmentDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermanentPrivacyUpgradeServerParameterValidationError{
				field:  "NewCommitmentDestination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNewCommitmentAmount() <= 0 {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "NewCommitmentAmount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMerkleRoot() == nil {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "MerkleRoot",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMerkleRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "MerkleRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
					field:  "MerkleRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMerkleRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermanentPrivacyUpgradeServerParameterValidationError{
				field:  "MerkleRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetMerkleProof()); l < 1 || l > 64 {
		err := PermanentPrivacyUpgradeServerParameterValidationError{
			field:  "MerkleProof",
			reason: "value must contain between 1 and 64 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMerkleProof() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
						field:  fmt.Sprintf("MerkleProof[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermanentPrivacyUpgradeServerParameterValidationError{
						field:  fmt.Sprintf("MerkleProof[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermanentPrivacyUpgradeServerParameterValidationError{
					field:  fmt.Sprintf("MerkleProof[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PermanentPrivacyUpgradeServerParameterMultiError(errors)
	}

	return nil
}

// PermanentPrivacyUpgradeServerParameterMultiError is an error wrapping
// multiple validation errors returned by
// PermanentPrivacyUpgradeServerParameter.ValidateAll() if the designated
// constraints aren't met.
type PermanentPrivacyUpgradeServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermanentPrivacyUpgradeServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermanentPrivacyUpgradeServerParameterMultiError) AllErrors() []error { return m }

// PermanentPrivacyUpgradeServerParameterValidationError is the validation
// error returned by PermanentPrivacyUpgradeServerParameter.Validate if the
// designated constraints aren't met.
type PermanentPrivacyUpgradeServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermanentPrivacyUpgradeServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermanentPrivacyUpgradeServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermanentPrivacyUpgradeServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermanentPrivacyUpgradeServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermanentPrivacyUpgradeServerParameterValidationError) ErrorName() string {
	return "PermanentPrivacyUpgradeServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e PermanentPrivacyUpgradeServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermanentPrivacyUpgradeServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermanentPrivacyUpgradeServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermanentPrivacyUpgradeServerParameterValidationError{}

// Validate checks the field values on FeePaymentServerParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FeePaymentServerParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeePaymentServerParameter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeePaymentServerParameterMultiError, or nil if none found.
func (m *FeePaymentServerParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *FeePaymentServerParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCodeDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FeePaymentServerParameterValidationError{
					field:  "CodeDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FeePaymentServerParameterValidationError{
					field:  "CodeDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCodeDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FeePaymentServerParameterValidationError{
				field:  "CodeDestination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FeePaymentServerParameterMultiError(errors)
	}

	return nil
}

// FeePaymentServerParameterMultiError is an error wrapping multiple validation
// errors returned by FeePaymentServerParameter.ValidateAll() if the
// designated constraints aren't met.
type FeePaymentServerParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeePaymentServerParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeePaymentServerParameterMultiError) AllErrors() []error { return m }

// FeePaymentServerParameterValidationError is the validation error returned by
// FeePaymentServerParameter.Validate if the designated constraints aren't met.
type FeePaymentServerParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeePaymentServerParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeePaymentServerParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeePaymentServerParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeePaymentServerParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeePaymentServerParameterValidationError) ErrorName() string {
	return "FeePaymentServerParameterValidationError"
}

// Error satisfies the builtin error interface
func (e FeePaymentServerParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeePaymentServerParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeePaymentServerParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeePaymentServerParameterValidationError{}

// Validate checks the field values on ErrorDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorDetailsMultiError, or
// nil if none found.
func (m *ErrorDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *ErrorDetails_ReasonString:
		if v == nil {
			err := ErrorDetailsValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetReasonString()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "ReasonString",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "ReasonString",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReasonString()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErrorDetailsValidationError{
					field:  "ReasonString",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ErrorDetails_InvalidSignature:
		if v == nil {
			err := ErrorDetailsValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetInvalidSignature()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "InvalidSignature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "InvalidSignature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInvalidSignature()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErrorDetailsValidationError{
					field:  "InvalidSignature",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ErrorDetails_Denied:
		if v == nil {
			err := ErrorDetailsValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDenied()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "Denied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErrorDetailsValidationError{
						field:  "Denied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDenied()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErrorDetailsValidationError{
					field:  "Denied",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := ErrorDetailsValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ErrorDetailsMultiError(errors)
	}

	return nil
}

// ErrorDetailsMultiError is an error wrapping multiple validation errors
// returned by ErrorDetails.ValidateAll() if the designated constraints aren't met.
type ErrorDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorDetailsMultiError) AllErrors() []error { return m }

// ErrorDetailsValidationError is the validation error returned by
// ErrorDetails.Validate if the designated constraints aren't met.
type ErrorDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorDetailsValidationError) ErrorName() string { return "ErrorDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ErrorDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorDetailsValidationError{}

// Validate checks the field values on ReasonStringErrorDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReasonStringErrorDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReasonStringErrorDetails with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReasonStringErrorDetailsMultiError, or nil if none found.
func (m *ReasonStringErrorDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ReasonStringErrorDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetReason()); l < 1 || l > 2048 {
		err := ReasonStringErrorDetailsValidationError{
			field:  "Reason",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReasonStringErrorDetailsMultiError(errors)
	}

	return nil
}

// ReasonStringErrorDetailsMultiError is an error wrapping multiple validation
// errors returned by ReasonStringErrorDetails.ValidateAll() if the designated
// constraints aren't met.
type ReasonStringErrorDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReasonStringErrorDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReasonStringErrorDetailsMultiError) AllErrors() []error { return m }

// ReasonStringErrorDetailsValidationError is the validation error returned by
// ReasonStringErrorDetails.Validate if the designated constraints aren't met.
type ReasonStringErrorDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReasonStringErrorDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReasonStringErrorDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReasonStringErrorDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReasonStringErrorDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReasonStringErrorDetailsValidationError) ErrorName() string {
	return "ReasonStringErrorDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e ReasonStringErrorDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReasonStringErrorDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReasonStringErrorDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReasonStringErrorDetailsValidationError{}

// Validate checks the field values on InvalidSignatureErrorDetails with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvalidSignatureErrorDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvalidSignatureErrorDetails with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvalidSignatureErrorDetailsMultiError, or nil if none found.
func (m *InvalidSignatureErrorDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *InvalidSignatureErrorDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionId

	if m.GetProvidedSignature() == nil {
		err := InvalidSignatureErrorDetailsValidationError{
			field:  "ProvidedSignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProvidedSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvalidSignatureErrorDetailsValidationError{
					field:  "ProvidedSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvalidSignatureErrorDetailsValidationError{
					field:  "ProvidedSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvidedSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvalidSignatureErrorDetailsValidationError{
				field:  "ProvidedSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	oneofExpectedBlobPresent := false
	switch v := m.ExpectedBlob.(type) {
	case *InvalidSignatureErrorDetails_ExpectedTransaction:
		if v == nil {
			err := InvalidSignatureErrorDetailsValidationError{
				field:  "ExpectedBlob",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExpectedBlobPresent = true

		if all {
			switch v := interface{}(m.GetExpectedTransaction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidSignatureErrorDetailsValidationError{
						field:  "ExpectedTransaction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidSignatureErrorDetailsValidationError{
						field:  "ExpectedTransaction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpectedTransaction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidSignatureErrorDetailsValidationError{
					field:  "ExpectedTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *InvalidSignatureErrorDetails_ExpectedVixnHash:
		if v == nil {
			err := InvalidSignatureErrorDetailsValidationError{
				field:  "ExpectedBlob",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExpectedBlobPresent = true

		if all {
			switch v := interface{}(m.GetExpectedVixnHash()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidSignatureErrorDetailsValidationError{
						field:  "ExpectedVixnHash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidSignatureErrorDetailsValidationError{
						field:  "ExpectedVixnHash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpectedVixnHash()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidSignatureErrorDetailsValidationError{
					field:  "ExpectedVixnHash",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofExpectedBlobPresent {
		err := InvalidSignatureErrorDetailsValidationError{
			field:  "ExpectedBlob",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InvalidSignatureErrorDetailsMultiError(errors)
	}

	return nil
}

// InvalidSignatureErrorDetailsMultiError is an error wrapping multiple
// validation errors returned by InvalidSignatureErrorDetails.ValidateAll() if
// the designated constraints aren't met.
type InvalidSignatureErrorDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvalidSignatureErrorDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvalidSignatureErrorDetailsMultiError) AllErrors() []error { return m }

// InvalidSignatureErrorDetailsValidationError is the validation error returned
// by InvalidSignatureErrorDetails.Validate if the designated constraints
// aren't met.
type InvalidSignatureErrorDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvalidSignatureErrorDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvalidSignatureErrorDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvalidSignatureErrorDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvalidSignatureErrorDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvalidSignatureErrorDetailsValidationError) ErrorName() string {
	return "InvalidSignatureErrorDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e InvalidSignatureErrorDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvalidSignatureErrorDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvalidSignatureErrorDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvalidSignatureErrorDetailsValidationError{}

// Validate checks the field values on DeniedErrorDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeniedErrorDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeniedErrorDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeniedErrorDetailsMultiError, or nil if none found.
func (m *DeniedErrorDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *DeniedErrorDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if l := utf8.RuneCountInString(m.GetReason()); l < 1 || l > 2048 {
		err := DeniedErrorDetailsValidationError{
			field:  "Reason",
			reason: "value length must be between 1 and 2048 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeniedErrorDetailsMultiError(errors)
	}

	return nil
}

// DeniedErrorDetailsMultiError is an error wrapping multiple validation errors
// returned by DeniedErrorDetails.ValidateAll() if the designated constraints
// aren't met.
type DeniedErrorDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeniedErrorDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeniedErrorDetailsMultiError) AllErrors() []error { return m }

// DeniedErrorDetailsValidationError is the validation error returned by
// DeniedErrorDetails.Validate if the designated constraints aren't met.
type DeniedErrorDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeniedErrorDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeniedErrorDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeniedErrorDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeniedErrorDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeniedErrorDetailsValidationError) ErrorName() string {
	return "DeniedErrorDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e DeniedErrorDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeniedErrorDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeniedErrorDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeniedErrorDetailsValidationError{}

// Validate checks the field values on UpgradeableIntent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeableIntent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeableIntent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeableIntentMultiError, or nil if none found.
func (m *UpgradeableIntent) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeableIntent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := UpgradeableIntentValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntentValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntentValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntentValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetActions()); l < 1 || l > 256 {
		err := UpgradeableIntentValidationError{
			field:  "Actions",
			reason: "value must contain between 1 and 256 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpgradeableIntentValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpgradeableIntentValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpgradeableIntentValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpgradeableIntentMultiError(errors)
	}

	return nil
}

// UpgradeableIntentMultiError is an error wrapping multiple validation errors
// returned by UpgradeableIntent.ValidateAll() if the designated constraints
// aren't met.
type UpgradeableIntentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeableIntentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeableIntentMultiError) AllErrors() []error { return m }

// UpgradeableIntentValidationError is the validation error returned by
// UpgradeableIntent.Validate if the designated constraints aren't met.
type UpgradeableIntentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeableIntentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeableIntentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeableIntentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeableIntentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeableIntentValidationError) ErrorName() string {
	return "UpgradeableIntentValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeableIntentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeableIntent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeableIntentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeableIntentValidationError{}

// Validate checks the field values on ExchangeData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExchangeData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExchangeDataMultiError, or
// nil if none found.
func (m *ExchangeData) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ExchangeData_Currency_Pattern.MatchString(m.GetCurrency()) {
		err := ExchangeDataValidationError{
			field:  "Currency",
			reason: "value does not match regex pattern \"^[a-z]{3,4}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExchangeRate() <= 0 {
		err := ExchangeDataValidationError{
			field:  "ExchangeRate",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNativeAmount() <= 0 {
		err := ExchangeDataValidationError{
			field:  "NativeAmount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetQuarks() <= 0 {
		err := ExchangeDataValidationError{
			field:  "Quarks",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExchangeDataMultiError(errors)
	}

	return nil
}

// ExchangeDataMultiError is an error wrapping multiple validation errors
// returned by ExchangeData.ValidateAll() if the designated constraints aren't met.
type ExchangeDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeDataMultiError) AllErrors() []error { return m }

// ExchangeDataValidationError is the validation error returned by
// ExchangeData.Validate if the designated constraints aren't met.
type ExchangeDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeDataValidationError) ErrorName() string { return "ExchangeDataValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeDataValidationError{}

var _ExchangeData_Currency_Pattern = regexp.MustCompile("^[a-z]{3,4}$")

// Validate checks the field values on ExchangeDataWithoutRate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeDataWithoutRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeDataWithoutRate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeDataWithoutRateMultiError, or nil if none found.
func (m *ExchangeDataWithoutRate) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeDataWithoutRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ExchangeDataWithoutRate_Currency_Pattern.MatchString(m.GetCurrency()) {
		err := ExchangeDataWithoutRateValidationError{
			field:  "Currency",
			reason: "value does not match regex pattern \"^[a-z]{3,4}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNativeAmount() <= 0 {
		err := ExchangeDataWithoutRateValidationError{
			field:  "NativeAmount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExchangeDataWithoutRateMultiError(errors)
	}

	return nil
}

// ExchangeDataWithoutRateMultiError is an error wrapping multiple validation
// errors returned by ExchangeDataWithoutRate.ValidateAll() if the designated
// constraints aren't met.
type ExchangeDataWithoutRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeDataWithoutRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeDataWithoutRateMultiError) AllErrors() []error { return m }

// ExchangeDataWithoutRateValidationError is the validation error returned by
// ExchangeDataWithoutRate.Validate if the designated constraints aren't met.
type ExchangeDataWithoutRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeDataWithoutRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeDataWithoutRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeDataWithoutRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeDataWithoutRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeDataWithoutRateValidationError) ErrorName() string {
	return "ExchangeDataWithoutRateValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeDataWithoutRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeDataWithoutRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeDataWithoutRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeDataWithoutRateValidationError{}

var _ExchangeDataWithoutRate_Currency_Pattern = regexp.MustCompile("^[a-z]{3,4}$")

// Validate checks the field values on AdditionalFeePayment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdditionalFeePayment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdditionalFeePayment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdditionalFeePaymentMultiError, or nil if none found.
func (m *AdditionalFeePayment) ValidateAll() error {
	return m.validate(true)
}

func (m *AdditionalFeePayment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDestination() == nil {
		err := AdditionalFeePaymentValidationError{
			field:  "Destination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdditionalFeePaymentValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdditionalFeePaymentValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdditionalFeePaymentValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetFeeBps(); val <= 0 || val > 10000 {
		err := AdditionalFeePaymentValidationError{
			field:  "FeeBps",
			reason: "value must be inside range (0, 10000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AdditionalFeePaymentMultiError(errors)
	}

	return nil
}

// AdditionalFeePaymentMultiError is an error wrapping multiple validation
// errors returned by AdditionalFeePayment.ValidateAll() if the designated
// constraints aren't met.
type AdditionalFeePaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdditionalFeePaymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdditionalFeePaymentMultiError) AllErrors() []error { return m }

// AdditionalFeePaymentValidationError is the validation error returned by
// AdditionalFeePayment.Validate if the designated constraints aren't met.
type AdditionalFeePaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdditionalFeePaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdditionalFeePaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdditionalFeePaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdditionalFeePaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdditionalFeePaymentValidationError) ErrorName() string {
	return "AdditionalFeePaymentValidationError"
}

// Error satisfies the builtin error interface
func (e AdditionalFeePaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdditionalFeePayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdditionalFeePaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdditionalFeePaymentValidationError{}

// Validate checks the field values on SendLimit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendLimitMultiError, or nil
// if none found.
func (m *SendLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *SendLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextTransaction

	// no validation rules for MaxPerTransaction

	// no validation rules for MaxPerDay

	if len(errors) > 0 {
		return SendLimitMultiError(errors)
	}

	return nil
}

// SendLimitMultiError is an error wrapping multiple validation errors returned
// by SendLimit.ValidateAll() if the designated constraints aren't met.
type SendLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendLimitMultiError) AllErrors() []error { return m }

// SendLimitValidationError is the validation error returned by
// SendLimit.Validate if the designated constraints aren't met.
type SendLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendLimitValidationError) ErrorName() string { return "SendLimitValidationError" }

// Error satisfies the builtin error interface
func (e SendLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendLimitValidationError{}

// Validate checks the field values on DepositLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DepositLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DepositLimitMultiError, or
// nil if none found.
func (m *DepositLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxQuarks

	if len(errors) > 0 {
		return DepositLimitMultiError(errors)
	}

	return nil
}

// DepositLimitMultiError is an error wrapping multiple validation errors
// returned by DepositLimit.ValidateAll() if the designated constraints aren't met.
type DepositLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositLimitMultiError) AllErrors() []error { return m }

// DepositLimitValidationError is the validation error returned by
// DepositLimit.Validate if the designated constraints aren't met.
type DepositLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositLimitValidationError) ErrorName() string { return "DepositLimitValidationError" }

// Error satisfies the builtin error interface
func (e DepositLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositLimitValidationError{}

// Validate checks the field values on MicroPaymentLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MicroPaymentLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MicroPaymentLimit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MicroPaymentLimitMultiError, or nil if none found.
func (m *MicroPaymentLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *MicroPaymentLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxPerTransaction

	// no validation rules for MinPerTransaction

	if len(errors) > 0 {
		return MicroPaymentLimitMultiError(errors)
	}

	return nil
}

// MicroPaymentLimitMultiError is an error wrapping multiple validation errors
// returned by MicroPaymentLimit.ValidateAll() if the designated constraints
// aren't met.
type MicroPaymentLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MicroPaymentLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MicroPaymentLimitMultiError) AllErrors() []error { return m }

// MicroPaymentLimitValidationError is the validation error returned by
// MicroPaymentLimit.Validate if the designated constraints aren't met.
type MicroPaymentLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MicroPaymentLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MicroPaymentLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MicroPaymentLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MicroPaymentLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MicroPaymentLimitValidationError) ErrorName() string {
	return "MicroPaymentLimitValidationError"
}

// Error satisfies the builtin error interface
func (e MicroPaymentLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMicroPaymentLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MicroPaymentLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MicroPaymentLimitValidationError{}

// Validate checks the field values on BuyModuleLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BuyModuleLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BuyModuleLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BuyModuleLimitMultiError,
// or nil if none found.
func (m *BuyModuleLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *BuyModuleLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinPerTransaction

	// no validation rules for MaxPerTransaction

	if len(errors) > 0 {
		return BuyModuleLimitMultiError(errors)
	}

	return nil
}

// BuyModuleLimitMultiError is an error wrapping multiple validation errors
// returned by BuyModuleLimit.ValidateAll() if the designated constraints
// aren't met.
type BuyModuleLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BuyModuleLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BuyModuleLimitMultiError) AllErrors() []error { return m }

// BuyModuleLimitValidationError is the validation error returned by
// BuyModuleLimit.Validate if the designated constraints aren't met.
type BuyModuleLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BuyModuleLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BuyModuleLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BuyModuleLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BuyModuleLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BuyModuleLimitValidationError) ErrorName() string { return "BuyModuleLimitValidationError" }

// Error satisfies the builtin error interface
func (e BuyModuleLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBuyModuleLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BuyModuleLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BuyModuleLimitValidationError{}

// Validate checks the field values on TippedUser with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TippedUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TippedUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TippedUserMultiError, or
// nil if none found.
func (m *TippedUser) ValidateAll() error {
	return m.validate(true)
}

func (m *TippedUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _TippedUser_Platform_InLookup[m.GetPlatform()]; !ok {
		err := TippedUserValidationError{
			field:  "Platform",
			reason: "value must be in list [TWITTER]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 15 {
		err := TippedUserValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 15 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TippedUserMultiError(errors)
	}

	return nil
}

// TippedUserMultiError is an error wrapping multiple validation errors
// returned by TippedUser.ValidateAll() if the designated constraints aren't met.
type TippedUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TippedUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TippedUserMultiError) AllErrors() []error { return m }

// TippedUserValidationError is the validation error returned by
// TippedUser.Validate if the designated constraints aren't met.
type TippedUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TippedUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TippedUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TippedUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TippedUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TippedUserValidationError) ErrorName() string { return "TippedUserValidationError" }

// Error satisfies the builtin error interface
func (e TippedUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTippedUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TippedUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TippedUserValidationError{}

var _TippedUser_Platform_InLookup = map[TippedUser_Platform]struct{}{
	1: {},
}

// Validate checks the field values on Cursor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cursor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cursor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CursorMultiError, or nil if none found.
func (m *Cursor) ValidateAll() error {
	return m.validate(true)
}

func (m *Cursor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 8 {
		err := CursorValidationError{
			field:  "Value",
			reason: "value length must be 8 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CursorMultiError(errors)
	}

	return nil
}

// CursorMultiError is an error wrapping multiple validation errors returned by
// Cursor.ValidateAll() if the designated constraints aren't met.
type CursorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CursorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CursorMultiError) AllErrors() []error { return m }

// CursorValidationError is the validation error returned by Cursor.Validate if
// the designated constraints aren't met.
type CursorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CursorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CursorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CursorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CursorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CursorValidationError) ErrorName() string { return "CursorValidationError" }

// Error satisfies the builtin error interface
func (e CursorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCursor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CursorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CursorValidationError{}

// Validate checks the field values on SubmitIntentRequest_SubmitActions with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SubmitIntentRequest_SubmitActions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentRequest_SubmitActions
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SubmitIntentRequest_SubmitActionsMultiError, or nil if none found.
func (m *SubmitIntentRequest_SubmitActions) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentRequest_SubmitActions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := SubmitIntentRequest_SubmitActionsValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitIntentRequest_SubmitActionsValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOwner() == nil {
		err := SubmitIntentRequest_SubmitActionsValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitIntentRequest_SubmitActionsValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetMetadata() == nil {
		err := SubmitIntentRequest_SubmitActionsValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitIntentRequest_SubmitActionsValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetActions()); l < 1 || l > 256 {
		err := SubmitIntentRequest_SubmitActionsValidationError{
			field:  "Actions",
			reason: "value must contain between 1 and 256 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentRequest_SubmitActionsValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSignature() == nil {
		err := SubmitIntentRequest_SubmitActionsValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitIntentRequest_SubmitActionsValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeviceToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "DeviceToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitIntentRequest_SubmitActionsValidationError{
					field:  "DeviceToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeviceToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitIntentRequest_SubmitActionsValidationError{
				field:  "DeviceToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubmitIntentRequest_SubmitActionsMultiError(errors)
	}

	return nil
}

// SubmitIntentRequest_SubmitActionsMultiError is an error wrapping multiple
// validation errors returned by
// SubmitIntentRequest_SubmitActions.ValidateAll() if the designated
// constraints aren't met.
type SubmitIntentRequest_SubmitActionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentRequest_SubmitActionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentRequest_SubmitActionsMultiError) AllErrors() []error { return m }

// SubmitIntentRequest_SubmitActionsValidationError is the validation error
// returned by SubmitIntentRequest_SubmitActions.Validate if the designated
// constraints aren't met.
type SubmitIntentRequest_SubmitActionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentRequest_SubmitActionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentRequest_SubmitActionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentRequest_SubmitActionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentRequest_SubmitActionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentRequest_SubmitActionsValidationError) ErrorName() string {
	return "SubmitIntentRequest_SubmitActionsValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentRequest_SubmitActionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentRequest_SubmitActions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentRequest_SubmitActionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentRequest_SubmitActionsValidationError{}

// Validate checks the field values on SubmitIntentRequest_SubmitSignatures
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *SubmitIntentRequest_SubmitSignatures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentRequest_SubmitSignatures
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SubmitIntentRequest_SubmitSignaturesMultiError, or nil if none found.
func (m *SubmitIntentRequest_SubmitSignatures) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentRequest_SubmitSignatures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSignatures()); l < 1 || l > 256 {
		err := SubmitIntentRequest_SubmitSignaturesValidationError{
			field:  "Signatures",
			reason: "value must contain between 1 and 256 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentRequest_SubmitSignaturesValidationError{
						field:  fmt.Sprintf("Signatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentRequest_SubmitSignaturesValidationError{
						field:  fmt.Sprintf("Signatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentRequest_SubmitSignaturesValidationError{
					field:  fmt.Sprintf("Signatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmitIntentRequest_SubmitSignaturesMultiError(errors)
	}

	return nil
}

// SubmitIntentRequest_SubmitSignaturesMultiError is an error wrapping multiple
// validation errors returned by
// SubmitIntentRequest_SubmitSignatures.ValidateAll() if the designated
// constraints aren't met.
type SubmitIntentRequest_SubmitSignaturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentRequest_SubmitSignaturesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentRequest_SubmitSignaturesMultiError) AllErrors() []error { return m }

// SubmitIntentRequest_SubmitSignaturesValidationError is the validation error
// returned by SubmitIntentRequest_SubmitSignatures.Validate if the designated
// constraints aren't met.
type SubmitIntentRequest_SubmitSignaturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentRequest_SubmitSignaturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentRequest_SubmitSignaturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentRequest_SubmitSignaturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentRequest_SubmitSignaturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentRequest_SubmitSignaturesValidationError) ErrorName() string {
	return "SubmitIntentRequest_SubmitSignaturesValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentRequest_SubmitSignaturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentRequest_SubmitSignatures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentRequest_SubmitSignaturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentRequest_SubmitSignaturesValidationError{}

// Validate checks the field values on SubmitIntentResponse_ServerParameters
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *SubmitIntentResponse_ServerParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentResponse_ServerParameters
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SubmitIntentResponse_ServerParametersMultiError, or nil if none found.
func (m *SubmitIntentResponse_ServerParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentResponse_ServerParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetServerParameters()); l < 1 || l > 256 {
		err := SubmitIntentResponse_ServerParametersValidationError{
			field:  "ServerParameters",
			reason: "value must contain between 1 and 256 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetServerParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentResponse_ServerParametersValidationError{
						field:  fmt.Sprintf("ServerParameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentResponse_ServerParametersValidationError{
						field:  fmt.Sprintf("ServerParameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentResponse_ServerParametersValidationError{
					field:  fmt.Sprintf("ServerParameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmitIntentResponse_ServerParametersMultiError(errors)
	}

	return nil
}

// SubmitIntentResponse_ServerParametersMultiError is an error wrapping
// multiple validation errors returned by
// SubmitIntentResponse_ServerParameters.ValidateAll() if the designated
// constraints aren't met.
type SubmitIntentResponse_ServerParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentResponse_ServerParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentResponse_ServerParametersMultiError) AllErrors() []error { return m }

// SubmitIntentResponse_ServerParametersValidationError is the validation error
// returned by SubmitIntentResponse_ServerParameters.Validate if the
// designated constraints aren't met.
type SubmitIntentResponse_ServerParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentResponse_ServerParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentResponse_ServerParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentResponse_ServerParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentResponse_ServerParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentResponse_ServerParametersValidationError) ErrorName() string {
	return "SubmitIntentResponse_ServerParametersValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentResponse_ServerParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentResponse_ServerParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentResponse_ServerParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentResponse_ServerParametersValidationError{}

// Validate checks the field values on SubmitIntentResponse_Success with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitIntentResponse_Success) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentResponse_Success with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitIntentResponse_SuccessMultiError, or nil if none found.
func (m *SubmitIntentResponse_Success) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentResponse_Success) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if len(errors) > 0 {
		return SubmitIntentResponse_SuccessMultiError(errors)
	}

	return nil
}

// SubmitIntentResponse_SuccessMultiError is an error wrapping multiple
// validation errors returned by SubmitIntentResponse_Success.ValidateAll() if
// the designated constraints aren't met.
type SubmitIntentResponse_SuccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentResponse_SuccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentResponse_SuccessMultiError) AllErrors() []error { return m }

// SubmitIntentResponse_SuccessValidationError is the validation error returned
// by SubmitIntentResponse_Success.Validate if the designated constraints
// aren't met.
type SubmitIntentResponse_SuccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentResponse_SuccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentResponse_SuccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentResponse_SuccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentResponse_SuccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentResponse_SuccessValidationError) ErrorName() string {
	return "SubmitIntentResponse_SuccessValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentResponse_SuccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentResponse_Success.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentResponse_SuccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentResponse_SuccessValidationError{}

// Validate checks the field values on SubmitIntentResponse_Error with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitIntentResponse_Error) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitIntentResponse_Error with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitIntentResponse_ErrorMultiError, or nil if none found.
func (m *SubmitIntentResponse_Error) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitIntentResponse_Error) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	for idx, item := range m.GetErrorDetails() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmitIntentResponse_ErrorValidationError{
						field:  fmt.Sprintf("ErrorDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmitIntentResponse_ErrorValidationError{
						field:  fmt.Sprintf("ErrorDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitIntentResponse_ErrorValidationError{
					field:  fmt.Sprintf("ErrorDetails[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmitIntentResponse_ErrorMultiError(errors)
	}

	return nil
}

// SubmitIntentResponse_ErrorMultiError is an error wrapping multiple
// validation errors returned by SubmitIntentResponse_Error.ValidateAll() if
// the designated constraints aren't met.
type SubmitIntentResponse_ErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitIntentResponse_ErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitIntentResponse_ErrorMultiError) AllErrors() []error { return m }

// SubmitIntentResponse_ErrorValidationError is the validation error returned
// by SubmitIntentResponse_Error.Validate if the designated constraints aren't met.
type SubmitIntentResponse_ErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitIntentResponse_ErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitIntentResponse_ErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitIntentResponse_ErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitIntentResponse_ErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitIntentResponse_ErrorValidationError) ErrorName() string {
	return "SubmitIntentResponse_ErrorValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitIntentResponse_ErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitIntentResponse_Error.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitIntentResponse_ErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitIntentResponse_ErrorValidationError{}

// Validate checks the field values on SwapRequest_Initiate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SwapRequest_Initiate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapRequest_Initiate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SwapRequest_InitiateMultiError, or nil if none found.
func (m *SwapRequest_Initiate) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapRequest_Initiate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOwner() == nil {
		err := SwapRequest_InitiateValidationError{
			field:  "Owner",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapRequest_InitiateValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSwapAuthority() == nil {
		err := SwapRequest_InitiateValidationError{
			field:  "SwapAuthority",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSwapAuthority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "SwapAuthority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "SwapAuthority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSwapAuthority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapRequest_InitiateValidationError{
				field:  "SwapAuthority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Limit

	// no validation rules for WaitForBlockchainStatus

	if m.GetSignature() == nil {
		err := SwapRequest_InitiateValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapRequest_InitiateValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapRequest_InitiateValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SwapRequest_InitiateMultiError(errors)
	}

	return nil
}

// SwapRequest_InitiateMultiError is an error wrapping multiple validation
// errors returned by SwapRequest_Initiate.ValidateAll() if the designated
// constraints aren't met.
type SwapRequest_InitiateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapRequest_InitiateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapRequest_InitiateMultiError) AllErrors() []error { return m }

// SwapRequest_InitiateValidationError is the validation error returned by
// SwapRequest_Initiate.Validate if the designated constraints aren't met.
type SwapRequest_InitiateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapRequest_InitiateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapRequest_InitiateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapRequest_InitiateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapRequest_InitiateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapRequest_InitiateValidationError) ErrorName() string {
	return "SwapRequest_InitiateValidationError"
}

// Error satisfies the builtin error interface
func (e SwapRequest_InitiateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapRequest_Initiate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapRequest_InitiateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapRequest_InitiateValidationError{}

// Validate checks the field values on SwapRequest_SubmitSignature with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SwapRequest_SubmitSignature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapRequest_SubmitSignature with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SwapRequest_SubmitSignatureMultiError, or nil if none found.
func (m *SwapRequest_SubmitSignature) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapRequest_SubmitSignature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSignature() == nil {
		err := SwapRequest_SubmitSignatureValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapRequest_SubmitSignatureValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapRequest_SubmitSignatureValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapRequest_SubmitSignatureValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SwapRequest_SubmitSignatureMultiError(errors)
	}

	return nil
}

// SwapRequest_SubmitSignatureMultiError is an error wrapping multiple
// validation errors returned by SwapRequest_SubmitSignature.ValidateAll() if
// the designated constraints aren't met.
type SwapRequest_SubmitSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapRequest_SubmitSignatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapRequest_SubmitSignatureMultiError) AllErrors() []error { return m }

// SwapRequest_SubmitSignatureValidationError is the validation error returned
// by SwapRequest_SubmitSignature.Validate if the designated constraints
// aren't met.
type SwapRequest_SubmitSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapRequest_SubmitSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapRequest_SubmitSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapRequest_SubmitSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapRequest_SubmitSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapRequest_SubmitSignatureValidationError) ErrorName() string {
	return "SwapRequest_SubmitSignatureValidationError"
}

// Error satisfies the builtin error interface
func (e SwapRequest_SubmitSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapRequest_SubmitSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapRequest_SubmitSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapRequest_SubmitSignatureValidationError{}

// Validate checks the field values on SwapResponse_ServerParameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SwapResponse_ServerParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapResponse_ServerParameters with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SwapResponse_ServerParametersMultiError, or nil if none found.
func (m *SwapResponse_ServerParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapResponse_ServerParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPayer() == nil {
		err := SwapResponse_ServerParametersValidationError{
			field:  "Payer",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "Payer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "Payer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapResponse_ServerParametersValidationError{
				field:  "Payer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRecentBlockhash() == nil {
		err := SwapResponse_ServerParametersValidationError{
			field:  "RecentBlockhash",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecentBlockhash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "RecentBlockhash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "RecentBlockhash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecentBlockhash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapResponse_ServerParametersValidationError{
				field:  "RecentBlockhash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ComputeUnitLimit

	// no validation rules for ComputeUnitPrice

	if m.GetSwapProgram() == nil {
		err := SwapResponse_ServerParametersValidationError{
			field:  "SwapProgram",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSwapProgram()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "SwapProgram",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "SwapProgram",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSwapProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapResponse_ServerParametersValidationError{
				field:  "SwapProgram",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetSwapIxnAccounts()); l < 1 || l > 64 {
		err := SwapResponse_ServerParametersValidationError{
			field:  "SwapIxnAccounts",
			reason: "value must contain between 1 and 64 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSwapIxnAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapResponse_ServerParametersValidationError{
						field:  fmt.Sprintf("SwapIxnAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapResponse_ServerParametersValidationError{
						field:  fmt.Sprintf("SwapIxnAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapResponse_ServerParametersValidationError{
					field:  fmt.Sprintf("SwapIxnAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := len(m.GetSwapIxnData()); l < 1 || l > 256 {
		err := SwapResponse_ServerParametersValidationError{
			field:  "SwapIxnData",
			reason: "value length must be between 1 and 256 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMaxToSend() <= 0 {
		err := SwapResponse_ServerParametersValidationError{
			field:  "MaxToSend",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMinToReceive() <= 0 {
		err := SwapResponse_ServerParametersValidationError{
			field:  "MinToReceive",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNonce() == nil {
		err := SwapResponse_ServerParametersValidationError{
			field:  "Nonce",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNonce()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SwapResponse_ServerParametersValidationError{
					field:  "Nonce",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNonce()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SwapResponse_ServerParametersValidationError{
				field:  "Nonce",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SwapResponse_ServerParametersMultiError(errors)
	}

	return nil
}

// SwapResponse_ServerParametersMultiError is an error wrapping multiple
// validation errors returned by SwapResponse_ServerParameters.ValidateAll()
// if the designated constraints aren't met.
type SwapResponse_ServerParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapResponse_ServerParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapResponse_ServerParametersMultiError) AllErrors() []error { return m }

// SwapResponse_ServerParametersValidationError is the validation error
// returned by SwapResponse_ServerParameters.Validate if the designated
// constraints aren't met.
type SwapResponse_ServerParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapResponse_ServerParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapResponse_ServerParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapResponse_ServerParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapResponse_ServerParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapResponse_ServerParametersValidationError) ErrorName() string {
	return "SwapResponse_ServerParametersValidationError"
}

// Error satisfies the builtin error interface
func (e SwapResponse_ServerParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapResponse_ServerParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapResponse_ServerParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapResponse_ServerParametersValidationError{}

// Validate checks the field values on SwapResponse_Success with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SwapResponse_Success) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapResponse_Success with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SwapResponse_SuccessMultiError, or nil if none found.
func (m *SwapResponse_Success) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapResponse_Success) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if len(errors) > 0 {
		return SwapResponse_SuccessMultiError(errors)
	}

	return nil
}

// SwapResponse_SuccessMultiError is an error wrapping multiple validation
// errors returned by SwapResponse_Success.ValidateAll() if the designated
// constraints aren't met.
type SwapResponse_SuccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapResponse_SuccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapResponse_SuccessMultiError) AllErrors() []error { return m }

// SwapResponse_SuccessValidationError is the validation error returned by
// SwapResponse_Success.Validate if the designated constraints aren't met.
type SwapResponse_SuccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapResponse_SuccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapResponse_SuccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapResponse_SuccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapResponse_SuccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapResponse_SuccessValidationError) ErrorName() string {
	return "SwapResponse_SuccessValidationError"
}

// Error satisfies the builtin error interface
func (e SwapResponse_SuccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapResponse_Success.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapResponse_SuccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapResponse_SuccessValidationError{}

// Validate checks the field values on SwapResponse_Error with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SwapResponse_Error) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SwapResponse_Error with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SwapResponse_ErrorMultiError, or nil if none found.
func (m *SwapResponse_Error) ValidateAll() error {
	return m.validate(true)
}

func (m *SwapResponse_Error) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	for idx, item := range m.GetErrorDetails() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SwapResponse_ErrorValidationError{
						field:  fmt.Sprintf("ErrorDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SwapResponse_ErrorValidationError{
						field:  fmt.Sprintf("ErrorDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SwapResponse_ErrorValidationError{
					field:  fmt.Sprintf("ErrorDetails[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SwapResponse_ErrorMultiError(errors)
	}

	return nil
}

// SwapResponse_ErrorMultiError is an error wrapping multiple validation errors
// returned by SwapResponse_Error.ValidateAll() if the designated constraints
// aren't met.
type SwapResponse_ErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SwapResponse_ErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SwapResponse_ErrorMultiError) AllErrors() []error { return m }

// SwapResponse_ErrorValidationError is the validation error returned by
// SwapResponse_Error.Validate if the designated constraints aren't met.
type SwapResponse_ErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SwapResponse_ErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SwapResponse_ErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SwapResponse_ErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SwapResponse_ErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SwapResponse_ErrorValidationError) ErrorName() string {
	return "SwapResponse_ErrorValidationError"
}

// Error satisfies the builtin error interface
func (e SwapResponse_ErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSwapResponse_Error.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SwapResponse_ErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SwapResponse_ErrorValidationError{}

// Validate checks the field values on
// UpgradeableIntent_UpgradeablePrivateAction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpgradeableIntent_UpgradeablePrivateAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpgradeableIntent_UpgradeablePrivateAction with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpgradeableIntent_UpgradeablePrivateActionMultiError, or nil if none found.
func (m *UpgradeableIntent_UpgradeablePrivateAction) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeableIntent_UpgradeablePrivateAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionBlob() == nil {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "TransactionBlob",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransactionBlob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "TransactionBlob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "TransactionBlob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionBlob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntent_UpgradeablePrivateActionValidationError{
				field:  "TransactionBlob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetClientSignature() == nil {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "ClientSignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetClientSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "ClientSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "ClientSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntent_UpgradeablePrivateActionValidationError{
				field:  "ClientSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ActionId

	if _, ok := _UpgradeableIntent_UpgradeablePrivateAction_SourceAccountType_NotInLookup[m.GetSourceAccountType()]; ok {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "SourceAccountType",
			reason: "value must not be in list [UNKNOWN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SourceDerivationIndex

	if m.GetOriginalDestination() == nil {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "OriginalDestination",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOriginalDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "OriginalDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "OriginalDestination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOriginalDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntent_UpgradeablePrivateActionValidationError{
				field:  "OriginalDestination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOriginalAmount() <= 0 {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "OriginalAmount",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTreasury() == nil {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "Treasury",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTreasury()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "Treasury",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreasury()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntent_UpgradeablePrivateActionValidationError{
				field:  "Treasury",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRecentRoot() == nil {
		err := UpgradeableIntent_UpgradeablePrivateActionValidationError{
			field:  "RecentRoot",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecentRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpgradeableIntent_UpgradeablePrivateActionValidationError{
					field:  "RecentRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecentRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpgradeableIntent_UpgradeablePrivateActionValidationError{
				field:  "RecentRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpgradeableIntent_UpgradeablePrivateActionMultiError(errors)
	}

	return nil
}

// UpgradeableIntent_UpgradeablePrivateActionMultiError is an error wrapping
// multiple validation errors returned by
// UpgradeableIntent_UpgradeablePrivateAction.ValidateAll() if the designated
// constraints aren't met.
type UpgradeableIntent_UpgradeablePrivateActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeableIntent_UpgradeablePrivateActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeableIntent_UpgradeablePrivateActionMultiError) AllErrors() []error { return m }

// UpgradeableIntent_UpgradeablePrivateActionValidationError is the validation
// error returned by UpgradeableIntent_UpgradeablePrivateAction.Validate if
// the designated constraints aren't met.
type UpgradeableIntent_UpgradeablePrivateActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) ErrorName() string {
	return "UpgradeableIntent_UpgradeablePrivateActionValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeableIntent_UpgradeablePrivateActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeableIntent_UpgradeablePrivateAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeableIntent_UpgradeablePrivateActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeableIntent_UpgradeablePrivateActionValidationError{}

var _UpgradeableIntent_UpgradeablePrivateAction_SourceAccountType_NotInLookup = map[common.AccountType]struct{}{
	0: {},
}
