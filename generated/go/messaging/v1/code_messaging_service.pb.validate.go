// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: messaging/v1/code_messaging_service.proto

package messaging

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	transaction "github.com/code-payments/code-protobuf-api/generated/go/transaction/v2"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = transaction.AirdropType(0)
)

// Validate checks the field values on OpenMessageStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OpenMessageStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenMessageStreamRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenMessageStreamRequestMultiError, or nil if none found.
func (m *OpenMessageStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenMessageStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRendezvousKey() == nil {
		err := OpenMessageStreamRequestValidationError{
			field:  "RendezvousKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenMessageStreamRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenMessageStreamRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenMessageStreamRequestValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OpenMessageStreamRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OpenMessageStreamRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OpenMessageStreamRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OpenMessageStreamRequestMultiError(errors)
	}

	return nil
}

// OpenMessageStreamRequestMultiError is an error wrapping multiple validation
// errors returned by OpenMessageStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type OpenMessageStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenMessageStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenMessageStreamRequestMultiError) AllErrors() []error { return m }

// OpenMessageStreamRequestValidationError is the validation error returned by
// OpenMessageStreamRequest.Validate if the designated constraints aren't met.
type OpenMessageStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenMessageStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenMessageStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenMessageStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenMessageStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenMessageStreamRequestValidationError) ErrorName() string {
	return "OpenMessageStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OpenMessageStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenMessageStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenMessageStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenMessageStreamRequestValidationError{}

// Validate checks the field values on OpenMessageStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OpenMessageStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenMessageStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenMessageStreamResponseMultiError, or nil if none found.
func (m *OpenMessageStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenMessageStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetMessages()); l < 1 || l > 1024 {
		err := OpenMessageStreamResponseValidationError{
			field:  "Messages",
			reason: "value must contain between 1 and 1024 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenMessageStreamResponseValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenMessageStreamResponseValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenMessageStreamResponseValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OpenMessageStreamResponseMultiError(errors)
	}

	return nil
}

// OpenMessageStreamResponseMultiError is an error wrapping multiple validation
// errors returned by OpenMessageStreamResponse.ValidateAll() if the
// designated constraints aren't met.
type OpenMessageStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenMessageStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenMessageStreamResponseMultiError) AllErrors() []error { return m }

// OpenMessageStreamResponseValidationError is the validation error returned by
// OpenMessageStreamResponse.Validate if the designated constraints aren't met.
type OpenMessageStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenMessageStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenMessageStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenMessageStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenMessageStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenMessageStreamResponseValidationError) ErrorName() string {
	return "OpenMessageStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OpenMessageStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenMessageStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenMessageStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenMessageStreamResponseValidationError{}

// Validate checks the field values on OpenMessageStreamWithKeepAliveRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *OpenMessageStreamWithKeepAliveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenMessageStreamWithKeepAliveRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OpenMessageStreamWithKeepAliveRequestMultiError, or nil if none found.
func (m *OpenMessageStreamWithKeepAliveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenMessageStreamWithKeepAliveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRequestOrPongPresent := false
	switch v := m.RequestOrPong.(type) {
	case *OpenMessageStreamWithKeepAliveRequest_Request:
		if v == nil {
			err := OpenMessageStreamWithKeepAliveRequestValidationError{
				field:  "RequestOrPong",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestOrPongPresent = true

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveRequestValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveRequestValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenMessageStreamWithKeepAliveRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OpenMessageStreamWithKeepAliveRequest_Pong:
		if v == nil {
			err := OpenMessageStreamWithKeepAliveRequestValidationError{
				field:  "RequestOrPong",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestOrPongPresent = true

		if all {
			switch v := interface{}(m.GetPong()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveRequestValidationError{
						field:  "Pong",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveRequestValidationError{
						field:  "Pong",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPong()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenMessageStreamWithKeepAliveRequestValidationError{
					field:  "Pong",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRequestOrPongPresent {
		err := OpenMessageStreamWithKeepAliveRequestValidationError{
			field:  "RequestOrPong",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OpenMessageStreamWithKeepAliveRequestMultiError(errors)
	}

	return nil
}

// OpenMessageStreamWithKeepAliveRequestMultiError is an error wrapping
// multiple validation errors returned by
// OpenMessageStreamWithKeepAliveRequest.ValidateAll() if the designated
// constraints aren't met.
type OpenMessageStreamWithKeepAliveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenMessageStreamWithKeepAliveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenMessageStreamWithKeepAliveRequestMultiError) AllErrors() []error { return m }

// OpenMessageStreamWithKeepAliveRequestValidationError is the validation error
// returned by OpenMessageStreamWithKeepAliveRequest.Validate if the
// designated constraints aren't met.
type OpenMessageStreamWithKeepAliveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenMessageStreamWithKeepAliveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenMessageStreamWithKeepAliveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenMessageStreamWithKeepAliveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenMessageStreamWithKeepAliveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenMessageStreamWithKeepAliveRequestValidationError) ErrorName() string {
	return "OpenMessageStreamWithKeepAliveRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OpenMessageStreamWithKeepAliveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenMessageStreamWithKeepAliveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenMessageStreamWithKeepAliveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenMessageStreamWithKeepAliveRequestValidationError{}

// Validate checks the field values on OpenMessageStreamWithKeepAliveResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *OpenMessageStreamWithKeepAliveResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// OpenMessageStreamWithKeepAliveResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// OpenMessageStreamWithKeepAliveResponseMultiError, or nil if none found.
func (m *OpenMessageStreamWithKeepAliveResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenMessageStreamWithKeepAliveResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofResponseOrPingPresent := false
	switch v := m.ResponseOrPing.(type) {
	case *OpenMessageStreamWithKeepAliveResponse_Response:
		if v == nil {
			err := OpenMessageStreamWithKeepAliveResponseValidationError{
				field:  "ResponseOrPing",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponseOrPingPresent = true

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveResponseValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveResponseValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenMessageStreamWithKeepAliveResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OpenMessageStreamWithKeepAliveResponse_Ping:
		if v == nil {
			err := OpenMessageStreamWithKeepAliveResponseValidationError{
				field:  "ResponseOrPing",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponseOrPingPresent = true

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpenMessageStreamWithKeepAliveResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpenMessageStreamWithKeepAliveResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponseOrPingPresent {
		err := OpenMessageStreamWithKeepAliveResponseValidationError{
			field:  "ResponseOrPing",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OpenMessageStreamWithKeepAliveResponseMultiError(errors)
	}

	return nil
}

// OpenMessageStreamWithKeepAliveResponseMultiError is an error wrapping
// multiple validation errors returned by
// OpenMessageStreamWithKeepAliveResponse.ValidateAll() if the designated
// constraints aren't met.
type OpenMessageStreamWithKeepAliveResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenMessageStreamWithKeepAliveResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenMessageStreamWithKeepAliveResponseMultiError) AllErrors() []error { return m }

// OpenMessageStreamWithKeepAliveResponseValidationError is the validation
// error returned by OpenMessageStreamWithKeepAliveResponse.Validate if the
// designated constraints aren't met.
type OpenMessageStreamWithKeepAliveResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenMessageStreamWithKeepAliveResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenMessageStreamWithKeepAliveResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenMessageStreamWithKeepAliveResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenMessageStreamWithKeepAliveResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenMessageStreamWithKeepAliveResponseValidationError) ErrorName() string {
	return "OpenMessageStreamWithKeepAliveResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OpenMessageStreamWithKeepAliveResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenMessageStreamWithKeepAliveResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenMessageStreamWithKeepAliveResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenMessageStreamWithKeepAliveResponseValidationError{}

// Validate checks the field values on PollMessagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PollMessagesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PollMessagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PollMessagesRequestMultiError, or nil if none found.
func (m *PollMessagesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PollMessagesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRendezvousKey() == nil {
		err := PollMessagesRequestValidationError{
			field:  "RendezvousKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PollMessagesRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PollMessagesRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PollMessagesRequestValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := PollMessagesRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PollMessagesRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PollMessagesRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PollMessagesRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PollMessagesRequestMultiError(errors)
	}

	return nil
}

// PollMessagesRequestMultiError is an error wrapping multiple validation
// errors returned by PollMessagesRequest.ValidateAll() if the designated
// constraints aren't met.
type PollMessagesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PollMessagesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PollMessagesRequestMultiError) AllErrors() []error { return m }

// PollMessagesRequestValidationError is the validation error returned by
// PollMessagesRequest.Validate if the designated constraints aren't met.
type PollMessagesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PollMessagesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PollMessagesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PollMessagesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PollMessagesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PollMessagesRequestValidationError) ErrorName() string {
	return "PollMessagesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PollMessagesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPollMessagesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PollMessagesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PollMessagesRequestValidationError{}

// Validate checks the field values on PollMessagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PollMessagesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PollMessagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PollMessagesResponseMultiError, or nil if none found.
func (m *PollMessagesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PollMessagesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetMessages()) > 1024 {
		err := PollMessagesResponseValidationError{
			field:  "Messages",
			reason: "value must contain no more than 1024 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PollMessagesResponseValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PollMessagesResponseValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PollMessagesResponseValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PollMessagesResponseMultiError(errors)
	}

	return nil
}

// PollMessagesResponseMultiError is an error wrapping multiple validation
// errors returned by PollMessagesResponse.ValidateAll() if the designated
// constraints aren't met.
type PollMessagesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PollMessagesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PollMessagesResponseMultiError) AllErrors() []error { return m }

// PollMessagesResponseValidationError is the validation error returned by
// PollMessagesResponse.Validate if the designated constraints aren't met.
type PollMessagesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PollMessagesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PollMessagesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PollMessagesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PollMessagesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PollMessagesResponseValidationError) ErrorName() string {
	return "PollMessagesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PollMessagesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPollMessagesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PollMessagesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PollMessagesResponseValidationError{}

// Validate checks the field values on AckMessagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AckMessagesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AckMessagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AckMessagesRequestMultiError, or nil if none found.
func (m *AckMessagesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AckMessagesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRendezvousKey() == nil {
		err := AckMessagesRequestValidationError{
			field:  "RendezvousKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AckMessagesRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AckMessagesRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AckMessagesRequestValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetMessageIds()); l < 1 || l > 1024 {
		err := AckMessagesRequestValidationError{
			field:  "MessageIds",
			reason: "value must contain between 1 and 1024 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMessageIds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AckMessagesRequestValidationError{
						field:  fmt.Sprintf("MessageIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AckMessagesRequestValidationError{
						field:  fmt.Sprintf("MessageIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AckMessagesRequestValidationError{
					field:  fmt.Sprintf("MessageIds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AckMessagesRequestMultiError(errors)
	}

	return nil
}

// AckMessagesRequestMultiError is an error wrapping multiple validation errors
// returned by AckMessagesRequest.ValidateAll() if the designated constraints
// aren't met.
type AckMessagesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AckMessagesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AckMessagesRequestMultiError) AllErrors() []error { return m }

// AckMessagesRequestValidationError is the validation error returned by
// AckMessagesRequest.Validate if the designated constraints aren't met.
type AckMessagesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AckMessagesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AckMessagesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AckMessagesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AckMessagesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AckMessagesRequestValidationError) ErrorName() string {
	return "AckMessagesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AckMessagesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAckMessagesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AckMessagesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AckMessagesRequestValidationError{}

// Validate checks the field values on AckMesssagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AckMesssagesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AckMesssagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AckMesssagesResponseMultiError, or nil if none found.
func (m *AckMesssagesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AckMesssagesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return AckMesssagesResponseMultiError(errors)
	}

	return nil
}

// AckMesssagesResponseMultiError is an error wrapping multiple validation
// errors returned by AckMesssagesResponse.ValidateAll() if the designated
// constraints aren't met.
type AckMesssagesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AckMesssagesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AckMesssagesResponseMultiError) AllErrors() []error { return m }

// AckMesssagesResponseValidationError is the validation error returned by
// AckMesssagesResponse.Validate if the designated constraints aren't met.
type AckMesssagesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AckMesssagesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AckMesssagesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AckMesssagesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AckMesssagesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AckMesssagesResponseValidationError) ErrorName() string {
	return "AckMesssagesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AckMesssagesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAckMesssagesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AckMesssagesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AckMesssagesResponseValidationError{}

// Validate checks the field values on SendMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendMessageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendMessageRequestMultiError, or nil if none found.
func (m *SendMessageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMessageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMessage() == nil {
		err := SendMessageRequestValidationError{
			field:  "Message",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMessageRequestValidationError{
				field:  "Message",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRendezvousKey() == nil {
		err := SendMessageRequestValidationError{
			field:  "RendezvousKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMessageRequestValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := SendMessageRequestValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMessageRequestValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMessageRequestValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendMessageRequestMultiError(errors)
	}

	return nil
}

// SendMessageRequestMultiError is an error wrapping multiple validation errors
// returned by SendMessageRequest.ValidateAll() if the designated constraints
// aren't met.
type SendMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMessageRequestMultiError) AllErrors() []error { return m }

// SendMessageRequestValidationError is the validation error returned by
// SendMessageRequest.Validate if the designated constraints aren't met.
type SendMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMessageRequestValidationError) ErrorName() string {
	return "SendMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMessageRequestValidationError{}

// Validate checks the field values on SendMessageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendMessageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMessageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendMessageResponseMultiError, or nil if none found.
func (m *SendMessageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMessageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetMessageId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMessageResponseValidationError{
					field:  "MessageId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMessageResponseValidationError{
					field:  "MessageId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMessageResponseValidationError{
				field:  "MessageId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendMessageResponseMultiError(errors)
	}

	return nil
}

// SendMessageResponseMultiError is an error wrapping multiple validation
// errors returned by SendMessageResponse.ValidateAll() if the designated
// constraints aren't met.
type SendMessageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMessageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMessageResponseMultiError) AllErrors() []error { return m }

// SendMessageResponseValidationError is the validation error returned by
// SendMessageResponse.Validate if the designated constraints aren't met.
type SendMessageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMessageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMessageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMessageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMessageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMessageResponseValidationError) ErrorName() string {
	return "SendMessageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SendMessageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMessageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMessageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMessageResponseValidationError{}

// Validate checks the field values on RendezvousKey with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RendezvousKey) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RendezvousKey with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RendezvousKeyMultiError, or
// nil if none found.
func (m *RendezvousKey) ValidateAll() error {
	return m.validate(true)
}

func (m *RendezvousKey) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 32 {
		err := RendezvousKeyValidationError{
			field:  "Value",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RendezvousKeyMultiError(errors)
	}

	return nil
}

// RendezvousKeyMultiError is an error wrapping multiple validation errors
// returned by RendezvousKey.ValidateAll() if the designated constraints
// aren't met.
type RendezvousKeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RendezvousKeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RendezvousKeyMultiError) AllErrors() []error { return m }

// RendezvousKeyValidationError is the validation error returned by
// RendezvousKey.Validate if the designated constraints aren't met.
type RendezvousKeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RendezvousKeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RendezvousKeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RendezvousKeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RendezvousKeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RendezvousKeyValidationError) ErrorName() string { return "RendezvousKeyValidationError" }

// Error satisfies the builtin error interface
func (e RendezvousKeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRendezvousKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RendezvousKeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RendezvousKeyValidationError{}

// Validate checks the field values on MessageId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessageId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessageIdMultiError, or nil
// if none found.
func (m *MessageId) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 16 {
		err := MessageIdValidationError{
			field:  "Value",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MessageIdMultiError(errors)
	}

	return nil
}

// MessageIdMultiError is an error wrapping multiple validation errors returned
// by MessageId.ValidateAll() if the designated constraints aren't met.
type MessageIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageIdMultiError) AllErrors() []error { return m }

// MessageIdValidationError is the validation error returned by
// MessageId.Validate if the designated constraints aren't met.
type MessageIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageIdValidationError) ErrorName() string { return "MessageIdValidationError" }

// Error satisfies the builtin error interface
func (e MessageIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageIdValidationError{}

// Validate checks the field values on RequestToGrabBill with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestToGrabBill) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestToGrabBill with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestToGrabBillMultiError, or nil if none found.
func (m *RequestToGrabBill) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestToGrabBill) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRequestorAccount() == nil {
		err := RequestToGrabBillValidationError{
			field:  "RequestorAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRequestorAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToGrabBillValidationError{
					field:  "RequestorAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToGrabBillValidationError{
					field:  "RequestorAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestorAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToGrabBillValidationError{
				field:  "RequestorAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RequestToGrabBillMultiError(errors)
	}

	return nil
}

// RequestToGrabBillMultiError is an error wrapping multiple validation errors
// returned by RequestToGrabBill.ValidateAll() if the designated constraints
// aren't met.
type RequestToGrabBillMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestToGrabBillMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestToGrabBillMultiError) AllErrors() []error { return m }

// RequestToGrabBillValidationError is the validation error returned by
// RequestToGrabBill.Validate if the designated constraints aren't met.
type RequestToGrabBillValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestToGrabBillValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestToGrabBillValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestToGrabBillValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestToGrabBillValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestToGrabBillValidationError) ErrorName() string {
	return "RequestToGrabBillValidationError"
}

// Error satisfies the builtin error interface
func (e RequestToGrabBillValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestToGrabBill.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestToGrabBillValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestToGrabBillValidationError{}

// Validate checks the field values on RequestToReceiveBill with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestToReceiveBill) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestToReceiveBill with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestToReceiveBillMultiError, or nil if none found.
func (m *RequestToReceiveBill) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestToReceiveBill) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRequestorAccount() == nil {
		err := RequestToReceiveBillValidationError{
			field:  "RequestorAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRequestorAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "RequestorAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "RequestorAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestorAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToReceiveBillValidationError{
				field:  "RequestorAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDomain()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Domain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Domain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDomain()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToReceiveBillValidationError{
				field:  "Domain",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerifier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerifier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToReceiveBillValidationError{
				field:  "Verifier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToReceiveBillValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToReceiveBillValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToReceiveBillValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetAdditionalFees()) > 3 {
		err := RequestToReceiveBillValidationError{
			field:  "AdditionalFees",
			reason: "value must contain no more than 3 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAdditionalFees() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  fmt.Sprintf("AdditionalFees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  fmt.Sprintf("AdditionalFees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestToReceiveBillValidationError{
					field:  fmt.Sprintf("AdditionalFees[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	oneofExchangeDataPresent := false
	switch v := m.ExchangeData.(type) {
	case *RequestToReceiveBill_Exact:
		if v == nil {
			err := RequestToReceiveBillValidationError{
				field:  "ExchangeData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExchangeDataPresent = true

		if all {
			switch v := interface{}(m.GetExact()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  "Exact",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  "Exact",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExact()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestToReceiveBillValidationError{
					field:  "Exact",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestToReceiveBill_Partial:
		if v == nil {
			err := RequestToReceiveBillValidationError{
				field:  "ExchangeData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofExchangeDataPresent = true

		if all {
			switch v := interface{}(m.GetPartial()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  "Partial",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestToReceiveBillValidationError{
						field:  "Partial",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPartial()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestToReceiveBillValidationError{
					field:  "Partial",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofExchangeDataPresent {
		err := RequestToReceiveBillValidationError{
			field:  "ExchangeData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestToReceiveBillMultiError(errors)
	}

	return nil
}

// RequestToReceiveBillMultiError is an error wrapping multiple validation
// errors returned by RequestToReceiveBill.ValidateAll() if the designated
// constraints aren't met.
type RequestToReceiveBillMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestToReceiveBillMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestToReceiveBillMultiError) AllErrors() []error { return m }

// RequestToReceiveBillValidationError is the validation error returned by
// RequestToReceiveBill.Validate if the designated constraints aren't met.
type RequestToReceiveBillValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestToReceiveBillValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestToReceiveBillValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestToReceiveBillValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestToReceiveBillValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestToReceiveBillValidationError) ErrorName() string {
	return "RequestToReceiveBillValidationError"
}

// Error satisfies the builtin error interface
func (e RequestToReceiveBillValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestToReceiveBill.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestToReceiveBillValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestToReceiveBillValidationError{}

// Validate checks the field values on CodeScanned with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CodeScanned) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodeScanned with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CodeScannedMultiError, or
// nil if none found.
func (m *CodeScanned) ValidateAll() error {
	return m.validate(true)
}

func (m *CodeScanned) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimestamp() == nil {
		err := CodeScannedValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CodeScannedMultiError(errors)
	}

	return nil
}

// CodeScannedMultiError is an error wrapping multiple validation errors
// returned by CodeScanned.ValidateAll() if the designated constraints aren't met.
type CodeScannedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodeScannedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodeScannedMultiError) AllErrors() []error { return m }

// CodeScannedValidationError is the validation error returned by
// CodeScanned.Validate if the designated constraints aren't met.
type CodeScannedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodeScannedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodeScannedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodeScannedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodeScannedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodeScannedValidationError) ErrorName() string { return "CodeScannedValidationError" }

// Error satisfies the builtin error interface
func (e CodeScannedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodeScanned.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodeScannedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodeScannedValidationError{}

// Validate checks the field values on ClientRejectedPayment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientRejectedPayment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientRejectedPayment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientRejectedPaymentMultiError, or nil if none found.
func (m *ClientRejectedPayment) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientRejectedPayment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetIntentId() == nil {
		err := ClientRejectedPaymentValidationError{
			field:  "IntentId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIntentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClientRejectedPaymentValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClientRejectedPaymentValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClientRejectedPaymentValidationError{
				field:  "IntentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClientRejectedPaymentMultiError(errors)
	}

	return nil
}

// ClientRejectedPaymentMultiError is an error wrapping multiple validation
// errors returned by ClientRejectedPayment.ValidateAll() if the designated
// constraints aren't met.
type ClientRejectedPaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientRejectedPaymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientRejectedPaymentMultiError) AllErrors() []error { return m }

// ClientRejectedPaymentValidationError is the validation error returned by
// ClientRejectedPayment.Validate if the designated constraints aren't met.
type ClientRejectedPaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientRejectedPaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientRejectedPaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientRejectedPaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientRejectedPaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientRejectedPaymentValidationError) ErrorName() string {
	return "ClientRejectedPaymentValidationError"
}

// Error satisfies the builtin error interface
func (e ClientRejectedPaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientRejectedPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientRejectedPaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientRejectedPaymentValidationError{}

// Validate checks the field values on IntentSubmitted with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IntentSubmitted) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IntentSubmitted with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IntentSubmittedMultiError, or nil if none found.
func (m *IntentSubmitted) ValidateAll() error {
	return m.validate(true)
}

func (m *IntentSubmitted) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetIntentId() == nil {
		err := IntentSubmittedValidationError{
			field:  "IntentId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIntentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntentSubmittedValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntentSubmittedValidationError{
					field:  "IntentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIntentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntentSubmittedValidationError{
				field:  "IntentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntentSubmittedValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntentSubmittedValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntentSubmittedValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IntentSubmittedMultiError(errors)
	}

	return nil
}

// IntentSubmittedMultiError is an error wrapping multiple validation errors
// returned by IntentSubmitted.ValidateAll() if the designated constraints
// aren't met.
type IntentSubmittedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntentSubmittedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntentSubmittedMultiError) AllErrors() []error { return m }

// IntentSubmittedValidationError is the validation error returned by
// IntentSubmitted.Validate if the designated constraints aren't met.
type IntentSubmittedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntentSubmittedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntentSubmittedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntentSubmittedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntentSubmittedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntentSubmittedValidationError) ErrorName() string { return "IntentSubmittedValidationError" }

// Error satisfies the builtin error interface
func (e IntentSubmittedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntentSubmitted.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntentSubmittedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntentSubmittedValidationError{}

// Validate checks the field values on WebhookCalled with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebhookCalled) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebhookCalled with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebhookCalledMultiError, or
// nil if none found.
func (m *WebhookCalled) ValidateAll() error {
	return m.validate(true)
}

func (m *WebhookCalled) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimestamp() == nil {
		err := WebhookCalledValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return WebhookCalledMultiError(errors)
	}

	return nil
}

// WebhookCalledMultiError is an error wrapping multiple validation errors
// returned by WebhookCalled.ValidateAll() if the designated constraints
// aren't met.
type WebhookCalledMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookCalledMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookCalledMultiError) AllErrors() []error { return m }

// WebhookCalledValidationError is the validation error returned by
// WebhookCalled.Validate if the designated constraints aren't met.
type WebhookCalledValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookCalledValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookCalledValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookCalledValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookCalledValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookCalledValidationError) ErrorName() string { return "WebhookCalledValidationError" }

// Error satisfies the builtin error interface
func (e WebhookCalledValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhookCalled.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookCalledValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookCalledValidationError{}

// Validate checks the field values on RequestToLogin with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestToLogin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestToLogin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestToLoginMultiError,
// or nil if none found.
func (m *RequestToLogin) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestToLogin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDomain() == nil {
		err := RequestToLoginValidationError{
			field:  "Domain",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDomain()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Domain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Domain",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDomain()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToLoginValidationError{
				field:  "Domain",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetVerifier() == nil {
		err := RequestToLoginValidationError{
			field:  "Verifier",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetVerifier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerifier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToLoginValidationError{
				field:  "Verifier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSignature() == nil {
		err := RequestToLoginValidationError{
			field:  "Signature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToLoginValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRendezvousKey() == nil {
		err := RequestToLoginValidationError{
			field:  "RendezvousKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestToLoginValidationError{
					field:  "RendezvousKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestToLoginValidationError{
				field:  "RendezvousKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RequestToLoginMultiError(errors)
	}

	return nil
}

// RequestToLoginMultiError is an error wrapping multiple validation errors
// returned by RequestToLogin.ValidateAll() if the designated constraints
// aren't met.
type RequestToLoginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestToLoginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestToLoginMultiError) AllErrors() []error { return m }

// RequestToLoginValidationError is the validation error returned by
// RequestToLogin.Validate if the designated constraints aren't met.
type RequestToLoginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestToLoginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestToLoginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestToLoginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestToLoginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestToLoginValidationError) ErrorName() string { return "RequestToLoginValidationError" }

// Error satisfies the builtin error interface
func (e RequestToLoginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestToLogin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestToLoginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestToLoginValidationError{}

// Validate checks the field values on ClientRejectedLogin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientRejectedLogin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientRejectedLogin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientRejectedLoginMultiError, or nil if none found.
func (m *ClientRejectedLogin) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientRejectedLogin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimestamp() == nil {
		err := ClientRejectedLoginValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ClientRejectedLoginMultiError(errors)
	}

	return nil
}

// ClientRejectedLoginMultiError is an error wrapping multiple validation
// errors returned by ClientRejectedLogin.ValidateAll() if the designated
// constraints aren't met.
type ClientRejectedLoginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientRejectedLoginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientRejectedLoginMultiError) AllErrors() []error { return m }

// ClientRejectedLoginValidationError is the validation error returned by
// ClientRejectedLogin.Validate if the designated constraints aren't met.
type ClientRejectedLoginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientRejectedLoginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientRejectedLoginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientRejectedLoginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientRejectedLoginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientRejectedLoginValidationError) ErrorName() string {
	return "ClientRejectedLoginValidationError"
}

// Error satisfies the builtin error interface
func (e ClientRejectedLoginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientRejectedLogin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientRejectedLoginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientRejectedLoginValidationError{}

// Validate checks the field values on AirdropReceived with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AirdropReceived) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AirdropReceived with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AirdropReceivedMultiError, or nil if none found.
func (m *AirdropReceived) ValidateAll() error {
	return m.validate(true)
}

func (m *AirdropReceived) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _AirdropReceived_AirdropType_NotInLookup[m.GetAirdropType()]; ok {
		err := AirdropReceivedValidationError{
			field:  "AirdropType",
			reason: "value must not be in list [UNKNOWN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetExchangeData() == nil {
		err := AirdropReceivedValidationError{
			field:  "ExchangeData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetExchangeData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AirdropReceivedValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AirdropReceivedValidationError{
					field:  "ExchangeData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AirdropReceivedValidationError{
				field:  "ExchangeData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetTimestamp() == nil {
		err := AirdropReceivedValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AirdropReceivedMultiError(errors)
	}

	return nil
}

// AirdropReceivedMultiError is an error wrapping multiple validation errors
// returned by AirdropReceived.ValidateAll() if the designated constraints
// aren't met.
type AirdropReceivedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AirdropReceivedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AirdropReceivedMultiError) AllErrors() []error { return m }

// AirdropReceivedValidationError is the validation error returned by
// AirdropReceived.Validate if the designated constraints aren't met.
type AirdropReceivedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AirdropReceivedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AirdropReceivedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AirdropReceivedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AirdropReceivedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AirdropReceivedValidationError) ErrorName() string { return "AirdropReceivedValidationError" }

// Error satisfies the builtin error interface
func (e AirdropReceivedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAirdropReceived.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AirdropReceivedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AirdropReceivedValidationError{}

var _AirdropReceived_AirdropType_NotInLookup = map[transaction.AirdropType]struct{}{
	0: {},
}

// Validate checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MessageMultiError, or nil if none found.
func (m *Message) ValidateAll() error {
	return m.validate(true)
}

func (m *Message) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSendMessageRequestSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "SendMessageRequestSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "SendMessageRequestSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSendMessageRequestSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "SendMessageRequestSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	oneofKindPresent := false
	switch v := m.Kind.(type) {
	case *Message_RequestToGrabBill:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetRequestToGrabBill()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToGrabBill",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToGrabBill",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequestToGrabBill()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "RequestToGrabBill",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_RequestToReceiveBill:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetRequestToReceiveBill()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToReceiveBill",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToReceiveBill",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequestToReceiveBill()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "RequestToReceiveBill",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_CodeScanned:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetCodeScanned()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "CodeScanned",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "CodeScanned",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCodeScanned()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "CodeScanned",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_ClientRejectedPayment:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetClientRejectedPayment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "ClientRejectedPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "ClientRejectedPayment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClientRejectedPayment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "ClientRejectedPayment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_IntentSubmitted:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetIntentSubmitted()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "IntentSubmitted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "IntentSubmitted",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntentSubmitted()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "IntentSubmitted",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_WebhookCalled:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetWebhookCalled()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "WebhookCalled",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "WebhookCalled",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebhookCalled()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "WebhookCalled",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_RequestToLogin:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetRequestToLogin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToLogin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "RequestToLogin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequestToLogin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "RequestToLogin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_ClientRejectedLogin:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetClientRejectedLogin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "ClientRejectedLogin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "ClientRejectedLogin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClientRejectedLogin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "ClientRejectedLogin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Message_AirdropReceived:
		if v == nil {
			err := MessageValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofKindPresent = true

		if all {
			switch v := interface{}(m.GetAirdropReceived()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "AirdropReceived",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageValidationError{
						field:  "AirdropReceived",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAirdropReceived()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageValidationError{
					field:  "AirdropReceived",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofKindPresent {
		err := MessageValidationError{
			field:  "Kind",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MessageMultiError(errors)
	}

	return nil
}

// MessageMultiError is an error wrapping multiple validation errors returned
// by Message.ValidateAll() if the designated constraints aren't met.
type MessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageMultiError) AllErrors() []error { return m }

// MessageValidationError is the validation error returned by Message.Validate
// if the designated constraints aren't met.
type MessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageValidationError) ErrorName() string { return "MessageValidationError" }

// Error satisfies the builtin error interface
func (e MessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageValidationError{}
