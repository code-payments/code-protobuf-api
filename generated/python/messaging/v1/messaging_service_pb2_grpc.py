# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from messaging.v1 import messaging_service_pb2 as messaging_dot_v1_dot_messaging__service__pb2

GRPC_GENERATED_VERSION = '1.70.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in messaging/v1/messaging_service_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class MessagingStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.OpenMessageStream = channel.unary_stream(
                '/code.messaging.v1.Messaging/OpenMessageStream',
                request_serializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamRequest.SerializeToString,
                response_deserializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamResponse.FromString,
                _registered_method=True)
        self.OpenMessageStreamWithKeepAlive = channel.stream_stream(
                '/code.messaging.v1.Messaging/OpenMessageStreamWithKeepAlive',
                request_serializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveRequest.SerializeToString,
                response_deserializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveResponse.FromString,
                _registered_method=True)
        self.PollMessages = channel.unary_unary(
                '/code.messaging.v1.Messaging/PollMessages',
                request_serializer=messaging_dot_v1_dot_messaging__service__pb2.PollMessagesRequest.SerializeToString,
                response_deserializer=messaging_dot_v1_dot_messaging__service__pb2.PollMessagesResponse.FromString,
                _registered_method=True)
        self.AckMessages = channel.unary_unary(
                '/code.messaging.v1.Messaging/AckMessages',
                request_serializer=messaging_dot_v1_dot_messaging__service__pb2.AckMessagesRequest.SerializeToString,
                response_deserializer=messaging_dot_v1_dot_messaging__service__pb2.AckMesssagesResponse.FromString,
                _registered_method=True)
        self.SendMessage = channel.unary_unary(
                '/code.messaging.v1.Messaging/SendMessage',
                request_serializer=messaging_dot_v1_dot_messaging__service__pb2.SendMessageRequest.SerializeToString,
                response_deserializer=messaging_dot_v1_dot_messaging__service__pb2.SendMessageResponse.FromString,
                _registered_method=True)


class MessagingServicer(object):
    """Missing associated documentation comment in .proto file."""

    def OpenMessageStream(self, request, context):
        """OpenMessageStream opens a stream of messages. Messages are routed using the
        public key of a rendezvous keypair derived by both the sender and the
        recipient of the messages. The sender may be a client or server.

        Messages are expected to be acked once they have been processed by the client.
        Ack'd messages will no longer be delivered on future OpenMessageStream calls,
        and are eligible for deletion from the service. Clients should, however, handle
        duplicate delivery of messages.

        For grabbing a bill, the expected flow is as follows:
        1. The payment sender creates a cash scan code
        2. The payment sender calls OpenMessageStream on the rendezvous public key, which is
        derived by using sha256(scan payload) as the keypair seed.
        3. The payment recipient scans the code and uses SendMessage to send their account ID
        back to the sender via the rendezvous public key.
        4. The payment sender receives the message, submits the intent, and closes the stream.

        For receiving a bill of requested value, the expected flow is as follows:
        1. The payment recipient uses SendMessage to send their account ID and payment amount to
        the sender via the rendezvous public key, which is derived by using sha256(scan payload)
        as the keypair seed.
        2. The payment recipient calls OpenMessageStream on the rendezvous public key to listen
        for status messages generated by client/server. It must ignore the original message it sent
        as part of step 1.
        3. The payment recipient creates a payment request scan code
        4. The payment sender calls PollMessages on the rendezvous public key. This is ok because
        we know the message exists per step 1, and doesn't actually incur a long poll. This is a
        required hack because we don't have the infrastructure in place to allow multiple listens
        on the same stream, and the recipient needs real-time status updates.
        5. The payment sender receives the message (any status messages are ignored), and submits the
        intent.
        6. The payment recipient observes status message (eg. IntentSubmitted, ClientRejectedPayment,
        WebhookCalled) for payment state.
        7. The payment recipient closes the stream once the payment hits a terminal state, or times out.

        For logging in, the expected flow is as follows:
        1. The third party uses SendMessage to send their login challenge to the user via the rendezvous
        public key, which is derived by using sha256(scan payload) as the keypair seed.
        2. The third party calls OpenMessageStream on the rendezvous public key to listen for status
        messages generated by server. It must ignore the original message it sent as part of step 1.
        3. The third party creates a login scan code
        4. The user logging in calls PollMessages on the rendezvous public key. This is ok because
        we know the message exists per step 1, and doesn't actually incur a long poll. This is a
        required hack because we don't have the infrastructure in place to allow multiple listens
        on the same stream, and the recipient needs real-time status updates.
        5. The user logging in receives the message (any status messages are ignored), verifies it,
        then submits a login attempt.
        6. The third party observes status message (eg. IntentSubmitted, ClientRejectedLogin,
        WebhookCalled) for login state.
        7. The third party closes the stream once the login hits a terminal state, or times out.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OpenMessageStreamWithKeepAlive(self, request_iterator, context):
        """OpenMessageStreamWithKeepAlive is like OpenMessageStream, but enables a ping/pong
        keepalive to determine the health of the stream at both the client and server.

        The keepalive protocol is as follows:
        1. Client initiates a stream by sending an OpenMessageStreamRequest.
        2. Upon stream initialization, server begins the keepalive protocol.
        3. Server sends a ping to the client.
        4. Client responds with a pong as fast as possible, making note of
        the delay for when to expect the next ping.
        5. Steps 3 and 4 are repeated until the stream is explicitly terminated
        or is deemed to be unhealthy.

        Client notes:
        * Client should be careful to process messages async, so any responses to pings are
        not delayed.
        * Clients should implement a reasonable backoff strategy upon continued timeout failures.
        * Clients that abuse pong messages may have their streams terminated by server.

        At any point in the stream, server will respond with messages in real time as
        they are observed. Messages sent over the stream should not affect the ping/pong
        protocol timings. Individual protocols for payment flows remain the same, and are
        documented in OpenMessageStream.

        Note: This API will enforce OpenMessageStreamRequest.signature is set as part of migration
        to this newer protocol
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PollMessages(self, request, context):
        """PollMessages is like OpenMessageStream, but uses a polling flow for receiving
        messages. Updates are not real-time and depedent on the polling interval.
        This RPC supports all message types.

        This is a temporary RPC until OpenMessageStream can be built out generically on
        both client and server, while supporting things like multiple listeners.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AckMessages(self, request, context):
        """AckMessages acks one or more messages that have been successfully delivered to
        the client.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SendMessage(self, request, context):
        """SendMessage sends a message.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MessagingServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'OpenMessageStream': grpc.unary_stream_rpc_method_handler(
                    servicer.OpenMessageStream,
                    request_deserializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamRequest.FromString,
                    response_serializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamResponse.SerializeToString,
            ),
            'OpenMessageStreamWithKeepAlive': grpc.stream_stream_rpc_method_handler(
                    servicer.OpenMessageStreamWithKeepAlive,
                    request_deserializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveRequest.FromString,
                    response_serializer=messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveResponse.SerializeToString,
            ),
            'PollMessages': grpc.unary_unary_rpc_method_handler(
                    servicer.PollMessages,
                    request_deserializer=messaging_dot_v1_dot_messaging__service__pb2.PollMessagesRequest.FromString,
                    response_serializer=messaging_dot_v1_dot_messaging__service__pb2.PollMessagesResponse.SerializeToString,
            ),
            'AckMessages': grpc.unary_unary_rpc_method_handler(
                    servicer.AckMessages,
                    request_deserializer=messaging_dot_v1_dot_messaging__service__pb2.AckMessagesRequest.FromString,
                    response_serializer=messaging_dot_v1_dot_messaging__service__pb2.AckMesssagesResponse.SerializeToString,
            ),
            'SendMessage': grpc.unary_unary_rpc_method_handler(
                    servicer.SendMessage,
                    request_deserializer=messaging_dot_v1_dot_messaging__service__pb2.SendMessageRequest.FromString,
                    response_serializer=messaging_dot_v1_dot_messaging__service__pb2.SendMessageResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'code.messaging.v1.Messaging', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('code.messaging.v1.Messaging', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Messaging(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def OpenMessageStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/code.messaging.v1.Messaging/OpenMessageStream',
            messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamRequest.SerializeToString,
            messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def OpenMessageStreamWithKeepAlive(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/code.messaging.v1.Messaging/OpenMessageStreamWithKeepAlive',
            messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveRequest.SerializeToString,
            messaging_dot_v1_dot_messaging__service__pb2.OpenMessageStreamWithKeepAliveResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PollMessages(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/code.messaging.v1.Messaging/PollMessages',
            messaging_dot_v1_dot_messaging__service__pb2.PollMessagesRequest.SerializeToString,
            messaging_dot_v1_dot_messaging__service__pb2.PollMessagesResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AckMessages(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/code.messaging.v1.Messaging/AckMessages',
            messaging_dot_v1_dot_messaging__service__pb2.AckMessagesRequest.SerializeToString,
            messaging_dot_v1_dot_messaging__service__pb2.AckMesssagesResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SendMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/code.messaging.v1.Messaging/SendMessage',
            messaging_dot_v1_dot_messaging__service__pb2.SendMessageRequest.SerializeToString,
            messaging_dot_v1_dot_messaging__service__pb2.SendMessageResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
